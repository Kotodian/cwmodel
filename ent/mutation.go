// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"

	"github.com/Kotodian/ent-practice/ent/appmoduleinfo"
	"github.com/Kotodian/ent-practice/ent/connector"
	"github.com/Kotodian/ent-practice/ent/equipment"
	"github.com/Kotodian/ent-practice/ent/equipmentalarm"
	"github.com/Kotodian/ent-practice/ent/equipmentfirmwareeffect"
	"github.com/Kotodian/ent-practice/ent/equipmentinfo"
	"github.com/Kotodian/ent-practice/ent/equipmentiot"
	"github.com/Kotodian/ent-practice/ent/equipmentlog"
	"github.com/Kotodian/ent-practice/ent/evse"
	"github.com/Kotodian/ent-practice/ent/firmware"
	"github.com/Kotodian/ent-practice/ent/manufacturer"
	"github.com/Kotodian/ent-practice/ent/model"
	"github.com/Kotodian/ent-practice/ent/orderevent"
	"github.com/Kotodian/ent-practice/ent/orderinfo"
	"github.com/Kotodian/ent-practice/ent/predicate"
	"github.com/Kotodian/ent-practice/ent/reservation"
	"github.com/Kotodian/ent-practice/ent/smartchargingeffect"
	"github.com/Kotodian/ent-practice/ent/types"
	"github.com/Kotodian/gokit/datasource"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAppModuleInfo           = "AppModuleInfo"
	TypeConnector               = "Connector"
	TypeEquipment               = "Equipment"
	TypeEquipmentAlarm          = "EquipmentAlarm"
	TypeEquipmentFirmwareEffect = "EquipmentFirmwareEffect"
	TypeEquipmentInfo           = "EquipmentInfo"
	TypeEquipmentIot            = "EquipmentIot"
	TypeEquipmentLog            = "EquipmentLog"
	TypeEvse                    = "Evse"
	TypeFirmware                = "Firmware"
	TypeManufacturer            = "Manufacturer"
	TypeModel                   = "Model"
	TypeOrderEvent              = "OrderEvent"
	TypeOrderInfo               = "OrderInfo"
	TypeReservation             = "Reservation"
	TypeSmartChargingEffect     = "SmartChargingEffect"
)

// AppModuleInfoMutation represents an operation that mutates the AppModuleInfo nodes in the graph.
type AppModuleInfoMutation struct {
	config
	op            Op
	typ           string
	id            *int
	name          *string
	desc          *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*AppModuleInfo, error)
	predicates    []predicate.AppModuleInfo
}

var _ ent.Mutation = (*AppModuleInfoMutation)(nil)

// appmoduleinfoOption allows management of the mutation configuration using functional options.
type appmoduleinfoOption func(*AppModuleInfoMutation)

// newAppModuleInfoMutation creates new mutation for the AppModuleInfo entity.
func newAppModuleInfoMutation(c config, op Op, opts ...appmoduleinfoOption) *AppModuleInfoMutation {
	m := &AppModuleInfoMutation{
		config:        c,
		op:            op,
		typ:           TypeAppModuleInfo,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAppModuleInfoID sets the ID field of the mutation.
func withAppModuleInfoID(id int) appmoduleinfoOption {
	return func(m *AppModuleInfoMutation) {
		var (
			err   error
			once  sync.Once
			value *AppModuleInfo
		)
		m.oldValue = func(ctx context.Context) (*AppModuleInfo, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AppModuleInfo.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAppModuleInfo sets the old AppModuleInfo of the mutation.
func withAppModuleInfo(node *AppModuleInfo) appmoduleinfoOption {
	return func(m *AppModuleInfoMutation) {
		m.oldValue = func(context.Context) (*AppModuleInfo, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AppModuleInfoMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AppModuleInfoMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AppModuleInfoMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AppModuleInfoMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AppModuleInfo.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *AppModuleInfoMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AppModuleInfoMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the AppModuleInfo entity.
// If the AppModuleInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppModuleInfoMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *AppModuleInfoMutation) ResetName() {
	m.name = nil
}

// SetDesc sets the "desc" field.
func (m *AppModuleInfoMutation) SetDesc(s string) {
	m.desc = &s
}

// Desc returns the value of the "desc" field in the mutation.
func (m *AppModuleInfoMutation) Desc() (r string, exists bool) {
	v := m.desc
	if v == nil {
		return
	}
	return *v, true
}

// OldDesc returns the old "desc" field's value of the AppModuleInfo entity.
// If the AppModuleInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppModuleInfoMutation) OldDesc(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDesc is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDesc requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDesc: %w", err)
	}
	return oldValue.Desc, nil
}

// ResetDesc resets all changes to the "desc" field.
func (m *AppModuleInfoMutation) ResetDesc() {
	m.desc = nil
}

// Where appends a list predicates to the AppModuleInfoMutation builder.
func (m *AppModuleInfoMutation) Where(ps ...predicate.AppModuleInfo) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AppModuleInfoMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (AppModuleInfo).
func (m *AppModuleInfoMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AppModuleInfoMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.name != nil {
		fields = append(fields, appmoduleinfo.FieldName)
	}
	if m.desc != nil {
		fields = append(fields, appmoduleinfo.FieldDesc)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AppModuleInfoMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case appmoduleinfo.FieldName:
		return m.Name()
	case appmoduleinfo.FieldDesc:
		return m.Desc()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AppModuleInfoMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case appmoduleinfo.FieldName:
		return m.OldName(ctx)
	case appmoduleinfo.FieldDesc:
		return m.OldDesc(ctx)
	}
	return nil, fmt.Errorf("unknown AppModuleInfo field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppModuleInfoMutation) SetField(name string, value ent.Value) error {
	switch name {
	case appmoduleinfo.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case appmoduleinfo.FieldDesc:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDesc(v)
		return nil
	}
	return fmt.Errorf("unknown AppModuleInfo field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AppModuleInfoMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AppModuleInfoMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppModuleInfoMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AppModuleInfo numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AppModuleInfoMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AppModuleInfoMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AppModuleInfoMutation) ClearField(name string) error {
	return fmt.Errorf("unknown AppModuleInfo nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AppModuleInfoMutation) ResetField(name string) error {
	switch name {
	case appmoduleinfo.FieldName:
		m.ResetName()
		return nil
	case appmoduleinfo.FieldDesc:
		m.ResetDesc()
		return nil
	}
	return fmt.Errorf("unknown AppModuleInfo field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AppModuleInfoMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AppModuleInfoMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AppModuleInfoMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AppModuleInfoMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AppModuleInfoMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AppModuleInfoMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AppModuleInfoMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown AppModuleInfo unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AppModuleInfoMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown AppModuleInfo edge %s", name)
}

// ConnectorMutation represents an operation that mutates the Connector nodes in the graph.
type ConnectorMutation struct {
	config
	op                           Op
	typ                          string
	id                           *datasource.UUID
	version                      *int64
	addversion                   *int64
	created_by                   *datasource.UUID
	addcreated_by                *datasource.UUID
	created_at                   *int64
	addcreated_at                *int64
	updated_by                   *datasource.UUID
	addupdated_by                *datasource.UUID
	updated_at                   *int64
	addupdated_at                *int64
	equipment_sn                 *string
	evse_serial                  *string
	serial                       *string
	current_state                *int
	addcurrent_state             *int
	before_state                 *int
	addbefore_state              *int
	charging_state               *int
	addcharging_state            *int
	reservation_id               *datasource.UUID
	addreservation_id            *datasource.UUID
	park_no                      *string
	clearedFields                map[string]struct{}
	evse                         *datasource.UUID
	clearedevse                  bool
	equipment                    *datasource.UUID
	clearedequipment             bool
	order_info                   map[datasource.UUID]struct{}
	removedorder_info            map[datasource.UUID]struct{}
	clearedorder_info            bool
	reservation                  map[datasource.UUID]struct{}
	removedreservation           map[datasource.UUID]struct{}
	clearedreservation           bool
	smart_charging_effect        map[datasource.UUID]struct{}
	removedsmart_charging_effect map[datasource.UUID]struct{}
	clearedsmart_charging_effect bool
	done                         bool
	oldValue                     func(context.Context) (*Connector, error)
	predicates                   []predicate.Connector
}

var _ ent.Mutation = (*ConnectorMutation)(nil)

// connectorOption allows management of the mutation configuration using functional options.
type connectorOption func(*ConnectorMutation)

// newConnectorMutation creates new mutation for the Connector entity.
func newConnectorMutation(c config, op Op, opts ...connectorOption) *ConnectorMutation {
	m := &ConnectorMutation{
		config:        c,
		op:            op,
		typ:           TypeConnector,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withConnectorID sets the ID field of the mutation.
func withConnectorID(id datasource.UUID) connectorOption {
	return func(m *ConnectorMutation) {
		var (
			err   error
			once  sync.Once
			value *Connector
		)
		m.oldValue = func(ctx context.Context) (*Connector, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Connector.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withConnector sets the old Connector of the mutation.
func withConnector(node *Connector) connectorOption {
	return func(m *ConnectorMutation) {
		m.oldValue = func(context.Context) (*Connector, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ConnectorMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ConnectorMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Connector entities.
func (m *ConnectorMutation) SetID(id datasource.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ConnectorMutation) ID() (id datasource.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ConnectorMutation) IDs(ctx context.Context) ([]datasource.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []datasource.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Connector.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetVersion sets the "version" field.
func (m *ConnectorMutation) SetVersion(i int64) {
	m.version = &i
	m.addversion = nil
}

// Version returns the value of the "version" field in the mutation.
func (m *ConnectorMutation) Version() (r int64, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the Connector entity.
// If the Connector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConnectorMutation) OldVersion(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// AddVersion adds i to the "version" field.
func (m *ConnectorMutation) AddVersion(i int64) {
	if m.addversion != nil {
		*m.addversion += i
	} else {
		m.addversion = &i
	}
}

// AddedVersion returns the value that was added to the "version" field in this mutation.
func (m *ConnectorMutation) AddedVersion() (r int64, exists bool) {
	v := m.addversion
	if v == nil {
		return
	}
	return *v, true
}

// ResetVersion resets all changes to the "version" field.
func (m *ConnectorMutation) ResetVersion() {
	m.version = nil
	m.addversion = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *ConnectorMutation) SetCreatedBy(d datasource.UUID) {
	m.created_by = &d
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *ConnectorMutation) CreatedBy() (r datasource.UUID, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Connector entity.
// If the Connector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConnectorMutation) OldCreatedBy(ctx context.Context) (v datasource.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds d to the "created_by" field.
func (m *ConnectorMutation) AddCreatedBy(d datasource.UUID) {
	if m.addcreated_by != nil {
		*m.addcreated_by += d
	} else {
		m.addcreated_by = &d
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *ConnectorMutation) AddedCreatedBy() (r datasource.UUID, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *ConnectorMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ConnectorMutation) SetCreatedAt(i int64) {
	m.created_at = &i
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ConnectorMutation) CreatedAt() (r int64, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Connector entity.
// If the Connector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConnectorMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to the "created_at" field.
func (m *ConnectorMutation) AddCreatedAt(i int64) {
	if m.addcreated_at != nil {
		*m.addcreated_at += i
	} else {
		m.addcreated_at = &i
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *ConnectorMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ConnectorMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *ConnectorMutation) SetUpdatedBy(d datasource.UUID) {
	m.updated_by = &d
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *ConnectorMutation) UpdatedBy() (r datasource.UUID, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Connector entity.
// If the Connector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConnectorMutation) OldUpdatedBy(ctx context.Context) (v datasource.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds d to the "updated_by" field.
func (m *ConnectorMutation) AddUpdatedBy(d datasource.UUID) {
	if m.addupdated_by != nil {
		*m.addupdated_by += d
	} else {
		m.addupdated_by = &d
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *ConnectorMutation) AddedUpdatedBy() (r datasource.UUID, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *ConnectorMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ConnectorMutation) SetUpdatedAt(i int64) {
	m.updated_at = &i
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ConnectorMutation) UpdatedAt() (r int64, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Connector entity.
// If the Connector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConnectorMutation) OldUpdatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to the "updated_at" field.
func (m *ConnectorMutation) AddUpdatedAt(i int64) {
	if m.addupdated_at != nil {
		*m.addupdated_at += i
	} else {
		m.addupdated_at = &i
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *ConnectorMutation) AddedUpdatedAt() (r int64, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ConnectorMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetEquipmentSn sets the "equipment_sn" field.
func (m *ConnectorMutation) SetEquipmentSn(s string) {
	m.equipment_sn = &s
}

// EquipmentSn returns the value of the "equipment_sn" field in the mutation.
func (m *ConnectorMutation) EquipmentSn() (r string, exists bool) {
	v := m.equipment_sn
	if v == nil {
		return
	}
	return *v, true
}

// OldEquipmentSn returns the old "equipment_sn" field's value of the Connector entity.
// If the Connector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConnectorMutation) OldEquipmentSn(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEquipmentSn is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEquipmentSn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEquipmentSn: %w", err)
	}
	return oldValue.EquipmentSn, nil
}

// ResetEquipmentSn resets all changes to the "equipment_sn" field.
func (m *ConnectorMutation) ResetEquipmentSn() {
	m.equipment_sn = nil
}

// SetEvseSerial sets the "evse_serial" field.
func (m *ConnectorMutation) SetEvseSerial(s string) {
	m.evse_serial = &s
}

// EvseSerial returns the value of the "evse_serial" field in the mutation.
func (m *ConnectorMutation) EvseSerial() (r string, exists bool) {
	v := m.evse_serial
	if v == nil {
		return
	}
	return *v, true
}

// OldEvseSerial returns the old "evse_serial" field's value of the Connector entity.
// If the Connector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConnectorMutation) OldEvseSerial(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEvseSerial is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEvseSerial requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEvseSerial: %w", err)
	}
	return oldValue.EvseSerial, nil
}

// ResetEvseSerial resets all changes to the "evse_serial" field.
func (m *ConnectorMutation) ResetEvseSerial() {
	m.evse_serial = nil
}

// SetSerial sets the "serial" field.
func (m *ConnectorMutation) SetSerial(s string) {
	m.serial = &s
}

// Serial returns the value of the "serial" field in the mutation.
func (m *ConnectorMutation) Serial() (r string, exists bool) {
	v := m.serial
	if v == nil {
		return
	}
	return *v, true
}

// OldSerial returns the old "serial" field's value of the Connector entity.
// If the Connector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConnectorMutation) OldSerial(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSerial is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSerial requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSerial: %w", err)
	}
	return oldValue.Serial, nil
}

// ResetSerial resets all changes to the "serial" field.
func (m *ConnectorMutation) ResetSerial() {
	m.serial = nil
}

// SetCurrentState sets the "current_state" field.
func (m *ConnectorMutation) SetCurrentState(i int) {
	m.current_state = &i
	m.addcurrent_state = nil
}

// CurrentState returns the value of the "current_state" field in the mutation.
func (m *ConnectorMutation) CurrentState() (r int, exists bool) {
	v := m.current_state
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrentState returns the old "current_state" field's value of the Connector entity.
// If the Connector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConnectorMutation) OldCurrentState(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrentState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrentState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrentState: %w", err)
	}
	return oldValue.CurrentState, nil
}

// AddCurrentState adds i to the "current_state" field.
func (m *ConnectorMutation) AddCurrentState(i int) {
	if m.addcurrent_state != nil {
		*m.addcurrent_state += i
	} else {
		m.addcurrent_state = &i
	}
}

// AddedCurrentState returns the value that was added to the "current_state" field in this mutation.
func (m *ConnectorMutation) AddedCurrentState() (r int, exists bool) {
	v := m.addcurrent_state
	if v == nil {
		return
	}
	return *v, true
}

// ResetCurrentState resets all changes to the "current_state" field.
func (m *ConnectorMutation) ResetCurrentState() {
	m.current_state = nil
	m.addcurrent_state = nil
}

// SetBeforeState sets the "before_state" field.
func (m *ConnectorMutation) SetBeforeState(i int) {
	m.before_state = &i
	m.addbefore_state = nil
}

// BeforeState returns the value of the "before_state" field in the mutation.
func (m *ConnectorMutation) BeforeState() (r int, exists bool) {
	v := m.before_state
	if v == nil {
		return
	}
	return *v, true
}

// OldBeforeState returns the old "before_state" field's value of the Connector entity.
// If the Connector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConnectorMutation) OldBeforeState(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBeforeState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBeforeState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBeforeState: %w", err)
	}
	return oldValue.BeforeState, nil
}

// AddBeforeState adds i to the "before_state" field.
func (m *ConnectorMutation) AddBeforeState(i int) {
	if m.addbefore_state != nil {
		*m.addbefore_state += i
	} else {
		m.addbefore_state = &i
	}
}

// AddedBeforeState returns the value that was added to the "before_state" field in this mutation.
func (m *ConnectorMutation) AddedBeforeState() (r int, exists bool) {
	v := m.addbefore_state
	if v == nil {
		return
	}
	return *v, true
}

// ResetBeforeState resets all changes to the "before_state" field.
func (m *ConnectorMutation) ResetBeforeState() {
	m.before_state = nil
	m.addbefore_state = nil
}

// SetChargingState sets the "charging_state" field.
func (m *ConnectorMutation) SetChargingState(i int) {
	m.charging_state = &i
	m.addcharging_state = nil
}

// ChargingState returns the value of the "charging_state" field in the mutation.
func (m *ConnectorMutation) ChargingState() (r int, exists bool) {
	v := m.charging_state
	if v == nil {
		return
	}
	return *v, true
}

// OldChargingState returns the old "charging_state" field's value of the Connector entity.
// If the Connector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConnectorMutation) OldChargingState(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChargingState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChargingState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChargingState: %w", err)
	}
	return oldValue.ChargingState, nil
}

// AddChargingState adds i to the "charging_state" field.
func (m *ConnectorMutation) AddChargingState(i int) {
	if m.addcharging_state != nil {
		*m.addcharging_state += i
	} else {
		m.addcharging_state = &i
	}
}

// AddedChargingState returns the value that was added to the "charging_state" field in this mutation.
func (m *ConnectorMutation) AddedChargingState() (r int, exists bool) {
	v := m.addcharging_state
	if v == nil {
		return
	}
	return *v, true
}

// ClearChargingState clears the value of the "charging_state" field.
func (m *ConnectorMutation) ClearChargingState() {
	m.charging_state = nil
	m.addcharging_state = nil
	m.clearedFields[connector.FieldChargingState] = struct{}{}
}

// ChargingStateCleared returns if the "charging_state" field was cleared in this mutation.
func (m *ConnectorMutation) ChargingStateCleared() bool {
	_, ok := m.clearedFields[connector.FieldChargingState]
	return ok
}

// ResetChargingState resets all changes to the "charging_state" field.
func (m *ConnectorMutation) ResetChargingState() {
	m.charging_state = nil
	m.addcharging_state = nil
	delete(m.clearedFields, connector.FieldChargingState)
}

// SetReservationID sets the "reservation_id" field.
func (m *ConnectorMutation) SetReservationID(d datasource.UUID) {
	m.reservation_id = &d
	m.addreservation_id = nil
}

// ReservationID returns the value of the "reservation_id" field in the mutation.
func (m *ConnectorMutation) ReservationID() (r datasource.UUID, exists bool) {
	v := m.reservation_id
	if v == nil {
		return
	}
	return *v, true
}

// OldReservationID returns the old "reservation_id" field's value of the Connector entity.
// If the Connector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConnectorMutation) OldReservationID(ctx context.Context) (v *datasource.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReservationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReservationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReservationID: %w", err)
	}
	return oldValue.ReservationID, nil
}

// AddReservationID adds d to the "reservation_id" field.
func (m *ConnectorMutation) AddReservationID(d datasource.UUID) {
	if m.addreservation_id != nil {
		*m.addreservation_id += d
	} else {
		m.addreservation_id = &d
	}
}

// AddedReservationID returns the value that was added to the "reservation_id" field in this mutation.
func (m *ConnectorMutation) AddedReservationID() (r datasource.UUID, exists bool) {
	v := m.addreservation_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearReservationID clears the value of the "reservation_id" field.
func (m *ConnectorMutation) ClearReservationID() {
	m.reservation_id = nil
	m.addreservation_id = nil
	m.clearedFields[connector.FieldReservationID] = struct{}{}
}

// ReservationIDCleared returns if the "reservation_id" field was cleared in this mutation.
func (m *ConnectorMutation) ReservationIDCleared() bool {
	_, ok := m.clearedFields[connector.FieldReservationID]
	return ok
}

// ResetReservationID resets all changes to the "reservation_id" field.
func (m *ConnectorMutation) ResetReservationID() {
	m.reservation_id = nil
	m.addreservation_id = nil
	delete(m.clearedFields, connector.FieldReservationID)
}

// SetParkNo sets the "park_no" field.
func (m *ConnectorMutation) SetParkNo(s string) {
	m.park_no = &s
}

// ParkNo returns the value of the "park_no" field in the mutation.
func (m *ConnectorMutation) ParkNo() (r string, exists bool) {
	v := m.park_no
	if v == nil {
		return
	}
	return *v, true
}

// OldParkNo returns the old "park_no" field's value of the Connector entity.
// If the Connector object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConnectorMutation) OldParkNo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParkNo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParkNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParkNo: %w", err)
	}
	return oldValue.ParkNo, nil
}

// ResetParkNo resets all changes to the "park_no" field.
func (m *ConnectorMutation) ResetParkNo() {
	m.park_no = nil
}

// SetEvseID sets the "evse" edge to the Evse entity by id.
func (m *ConnectorMutation) SetEvseID(id datasource.UUID) {
	m.evse = &id
}

// ClearEvse clears the "evse" edge to the Evse entity.
func (m *ConnectorMutation) ClearEvse() {
	m.clearedevse = true
}

// EvseCleared reports if the "evse" edge to the Evse entity was cleared.
func (m *ConnectorMutation) EvseCleared() bool {
	return m.clearedevse
}

// EvseID returns the "evse" edge ID in the mutation.
func (m *ConnectorMutation) EvseID() (id datasource.UUID, exists bool) {
	if m.evse != nil {
		return *m.evse, true
	}
	return
}

// EvseIDs returns the "evse" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EvseID instead. It exists only for internal usage by the builders.
func (m *ConnectorMutation) EvseIDs() (ids []datasource.UUID) {
	if id := m.evse; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEvse resets all changes to the "evse" edge.
func (m *ConnectorMutation) ResetEvse() {
	m.evse = nil
	m.clearedevse = false
}

// SetEquipmentID sets the "equipment" edge to the Equipment entity by id.
func (m *ConnectorMutation) SetEquipmentID(id datasource.UUID) {
	m.equipment = &id
}

// ClearEquipment clears the "equipment" edge to the Equipment entity.
func (m *ConnectorMutation) ClearEquipment() {
	m.clearedequipment = true
}

// EquipmentCleared reports if the "equipment" edge to the Equipment entity was cleared.
func (m *ConnectorMutation) EquipmentCleared() bool {
	return m.clearedequipment
}

// EquipmentID returns the "equipment" edge ID in the mutation.
func (m *ConnectorMutation) EquipmentID() (id datasource.UUID, exists bool) {
	if m.equipment != nil {
		return *m.equipment, true
	}
	return
}

// EquipmentIDs returns the "equipment" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EquipmentID instead. It exists only for internal usage by the builders.
func (m *ConnectorMutation) EquipmentIDs() (ids []datasource.UUID) {
	if id := m.equipment; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEquipment resets all changes to the "equipment" edge.
func (m *ConnectorMutation) ResetEquipment() {
	m.equipment = nil
	m.clearedequipment = false
}

// AddOrderInfoIDs adds the "order_info" edge to the OrderInfo entity by ids.
func (m *ConnectorMutation) AddOrderInfoIDs(ids ...datasource.UUID) {
	if m.order_info == nil {
		m.order_info = make(map[datasource.UUID]struct{})
	}
	for i := range ids {
		m.order_info[ids[i]] = struct{}{}
	}
}

// ClearOrderInfo clears the "order_info" edge to the OrderInfo entity.
func (m *ConnectorMutation) ClearOrderInfo() {
	m.clearedorder_info = true
}

// OrderInfoCleared reports if the "order_info" edge to the OrderInfo entity was cleared.
func (m *ConnectorMutation) OrderInfoCleared() bool {
	return m.clearedorder_info
}

// RemoveOrderInfoIDs removes the "order_info" edge to the OrderInfo entity by IDs.
func (m *ConnectorMutation) RemoveOrderInfoIDs(ids ...datasource.UUID) {
	if m.removedorder_info == nil {
		m.removedorder_info = make(map[datasource.UUID]struct{})
	}
	for i := range ids {
		delete(m.order_info, ids[i])
		m.removedorder_info[ids[i]] = struct{}{}
	}
}

// RemovedOrderInfo returns the removed IDs of the "order_info" edge to the OrderInfo entity.
func (m *ConnectorMutation) RemovedOrderInfoIDs() (ids []datasource.UUID) {
	for id := range m.removedorder_info {
		ids = append(ids, id)
	}
	return
}

// OrderInfoIDs returns the "order_info" edge IDs in the mutation.
func (m *ConnectorMutation) OrderInfoIDs() (ids []datasource.UUID) {
	for id := range m.order_info {
		ids = append(ids, id)
	}
	return
}

// ResetOrderInfo resets all changes to the "order_info" edge.
func (m *ConnectorMutation) ResetOrderInfo() {
	m.order_info = nil
	m.clearedorder_info = false
	m.removedorder_info = nil
}

// AddReservationIDs adds the "reservation" edge to the Reservation entity by ids.
func (m *ConnectorMutation) AddReservationIDs(ids ...datasource.UUID) {
	if m.reservation == nil {
		m.reservation = make(map[datasource.UUID]struct{})
	}
	for i := range ids {
		m.reservation[ids[i]] = struct{}{}
	}
}

// ClearReservation clears the "reservation" edge to the Reservation entity.
func (m *ConnectorMutation) ClearReservation() {
	m.clearedreservation = true
}

// ReservationCleared reports if the "reservation" edge to the Reservation entity was cleared.
func (m *ConnectorMutation) ReservationCleared() bool {
	return m.clearedreservation
}

// RemoveReservationIDs removes the "reservation" edge to the Reservation entity by IDs.
func (m *ConnectorMutation) RemoveReservationIDs(ids ...datasource.UUID) {
	if m.removedreservation == nil {
		m.removedreservation = make(map[datasource.UUID]struct{})
	}
	for i := range ids {
		delete(m.reservation, ids[i])
		m.removedreservation[ids[i]] = struct{}{}
	}
}

// RemovedReservation returns the removed IDs of the "reservation" edge to the Reservation entity.
func (m *ConnectorMutation) RemovedReservationIDs() (ids []datasource.UUID) {
	for id := range m.removedreservation {
		ids = append(ids, id)
	}
	return
}

// ReservationIDs returns the "reservation" edge IDs in the mutation.
func (m *ConnectorMutation) ReservationIDs() (ids []datasource.UUID) {
	for id := range m.reservation {
		ids = append(ids, id)
	}
	return
}

// ResetReservation resets all changes to the "reservation" edge.
func (m *ConnectorMutation) ResetReservation() {
	m.reservation = nil
	m.clearedreservation = false
	m.removedreservation = nil
}

// AddSmartChargingEffectIDs adds the "smart_charging_effect" edge to the SmartChargingEffect entity by ids.
func (m *ConnectorMutation) AddSmartChargingEffectIDs(ids ...datasource.UUID) {
	if m.smart_charging_effect == nil {
		m.smart_charging_effect = make(map[datasource.UUID]struct{})
	}
	for i := range ids {
		m.smart_charging_effect[ids[i]] = struct{}{}
	}
}

// ClearSmartChargingEffect clears the "smart_charging_effect" edge to the SmartChargingEffect entity.
func (m *ConnectorMutation) ClearSmartChargingEffect() {
	m.clearedsmart_charging_effect = true
}

// SmartChargingEffectCleared reports if the "smart_charging_effect" edge to the SmartChargingEffect entity was cleared.
func (m *ConnectorMutation) SmartChargingEffectCleared() bool {
	return m.clearedsmart_charging_effect
}

// RemoveSmartChargingEffectIDs removes the "smart_charging_effect" edge to the SmartChargingEffect entity by IDs.
func (m *ConnectorMutation) RemoveSmartChargingEffectIDs(ids ...datasource.UUID) {
	if m.removedsmart_charging_effect == nil {
		m.removedsmart_charging_effect = make(map[datasource.UUID]struct{})
	}
	for i := range ids {
		delete(m.smart_charging_effect, ids[i])
		m.removedsmart_charging_effect[ids[i]] = struct{}{}
	}
}

// RemovedSmartChargingEffect returns the removed IDs of the "smart_charging_effect" edge to the SmartChargingEffect entity.
func (m *ConnectorMutation) RemovedSmartChargingEffectIDs() (ids []datasource.UUID) {
	for id := range m.removedsmart_charging_effect {
		ids = append(ids, id)
	}
	return
}

// SmartChargingEffectIDs returns the "smart_charging_effect" edge IDs in the mutation.
func (m *ConnectorMutation) SmartChargingEffectIDs() (ids []datasource.UUID) {
	for id := range m.smart_charging_effect {
		ids = append(ids, id)
	}
	return
}

// ResetSmartChargingEffect resets all changes to the "smart_charging_effect" edge.
func (m *ConnectorMutation) ResetSmartChargingEffect() {
	m.smart_charging_effect = nil
	m.clearedsmart_charging_effect = false
	m.removedsmart_charging_effect = nil
}

// Where appends a list predicates to the ConnectorMutation builder.
func (m *ConnectorMutation) Where(ps ...predicate.Connector) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ConnectorMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Connector).
func (m *ConnectorMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ConnectorMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.version != nil {
		fields = append(fields, connector.FieldVersion)
	}
	if m.created_by != nil {
		fields = append(fields, connector.FieldCreatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, connector.FieldCreatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, connector.FieldUpdatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, connector.FieldUpdatedAt)
	}
	if m.equipment_sn != nil {
		fields = append(fields, connector.FieldEquipmentSn)
	}
	if m.evse_serial != nil {
		fields = append(fields, connector.FieldEvseSerial)
	}
	if m.serial != nil {
		fields = append(fields, connector.FieldSerial)
	}
	if m.current_state != nil {
		fields = append(fields, connector.FieldCurrentState)
	}
	if m.before_state != nil {
		fields = append(fields, connector.FieldBeforeState)
	}
	if m.charging_state != nil {
		fields = append(fields, connector.FieldChargingState)
	}
	if m.reservation_id != nil {
		fields = append(fields, connector.FieldReservationID)
	}
	if m.park_no != nil {
		fields = append(fields, connector.FieldParkNo)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ConnectorMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case connector.FieldVersion:
		return m.Version()
	case connector.FieldCreatedBy:
		return m.CreatedBy()
	case connector.FieldCreatedAt:
		return m.CreatedAt()
	case connector.FieldUpdatedBy:
		return m.UpdatedBy()
	case connector.FieldUpdatedAt:
		return m.UpdatedAt()
	case connector.FieldEquipmentSn:
		return m.EquipmentSn()
	case connector.FieldEvseSerial:
		return m.EvseSerial()
	case connector.FieldSerial:
		return m.Serial()
	case connector.FieldCurrentState:
		return m.CurrentState()
	case connector.FieldBeforeState:
		return m.BeforeState()
	case connector.FieldChargingState:
		return m.ChargingState()
	case connector.FieldReservationID:
		return m.ReservationID()
	case connector.FieldParkNo:
		return m.ParkNo()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ConnectorMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case connector.FieldVersion:
		return m.OldVersion(ctx)
	case connector.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case connector.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case connector.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case connector.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case connector.FieldEquipmentSn:
		return m.OldEquipmentSn(ctx)
	case connector.FieldEvseSerial:
		return m.OldEvseSerial(ctx)
	case connector.FieldSerial:
		return m.OldSerial(ctx)
	case connector.FieldCurrentState:
		return m.OldCurrentState(ctx)
	case connector.FieldBeforeState:
		return m.OldBeforeState(ctx)
	case connector.FieldChargingState:
		return m.OldChargingState(ctx)
	case connector.FieldReservationID:
		return m.OldReservationID(ctx)
	case connector.FieldParkNo:
		return m.OldParkNo(ctx)
	}
	return nil, fmt.Errorf("unknown Connector field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ConnectorMutation) SetField(name string, value ent.Value) error {
	switch name {
	case connector.FieldVersion:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case connector.FieldCreatedBy:
		v, ok := value.(datasource.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case connector.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case connector.FieldUpdatedBy:
		v, ok := value.(datasource.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case connector.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case connector.FieldEquipmentSn:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEquipmentSn(v)
		return nil
	case connector.FieldEvseSerial:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEvseSerial(v)
		return nil
	case connector.FieldSerial:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSerial(v)
		return nil
	case connector.FieldCurrentState:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrentState(v)
		return nil
	case connector.FieldBeforeState:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBeforeState(v)
		return nil
	case connector.FieldChargingState:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChargingState(v)
		return nil
	case connector.FieldReservationID:
		v, ok := value.(datasource.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReservationID(v)
		return nil
	case connector.FieldParkNo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParkNo(v)
		return nil
	}
	return fmt.Errorf("unknown Connector field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ConnectorMutation) AddedFields() []string {
	var fields []string
	if m.addversion != nil {
		fields = append(fields, connector.FieldVersion)
	}
	if m.addcreated_by != nil {
		fields = append(fields, connector.FieldCreatedBy)
	}
	if m.addcreated_at != nil {
		fields = append(fields, connector.FieldCreatedAt)
	}
	if m.addupdated_by != nil {
		fields = append(fields, connector.FieldUpdatedBy)
	}
	if m.addupdated_at != nil {
		fields = append(fields, connector.FieldUpdatedAt)
	}
	if m.addcurrent_state != nil {
		fields = append(fields, connector.FieldCurrentState)
	}
	if m.addbefore_state != nil {
		fields = append(fields, connector.FieldBeforeState)
	}
	if m.addcharging_state != nil {
		fields = append(fields, connector.FieldChargingState)
	}
	if m.addreservation_id != nil {
		fields = append(fields, connector.FieldReservationID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ConnectorMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case connector.FieldVersion:
		return m.AddedVersion()
	case connector.FieldCreatedBy:
		return m.AddedCreatedBy()
	case connector.FieldCreatedAt:
		return m.AddedCreatedAt()
	case connector.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case connector.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case connector.FieldCurrentState:
		return m.AddedCurrentState()
	case connector.FieldBeforeState:
		return m.AddedBeforeState()
	case connector.FieldChargingState:
		return m.AddedChargingState()
	case connector.FieldReservationID:
		return m.AddedReservationID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ConnectorMutation) AddField(name string, value ent.Value) error {
	switch name {
	case connector.FieldVersion:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVersion(v)
		return nil
	case connector.FieldCreatedBy:
		v, ok := value.(datasource.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case connector.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case connector.FieldUpdatedBy:
		v, ok := value.(datasource.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case connector.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case connector.FieldCurrentState:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCurrentState(v)
		return nil
	case connector.FieldBeforeState:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBeforeState(v)
		return nil
	case connector.FieldChargingState:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddChargingState(v)
		return nil
	case connector.FieldReservationID:
		v, ok := value.(datasource.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddReservationID(v)
		return nil
	}
	return fmt.Errorf("unknown Connector numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ConnectorMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(connector.FieldChargingState) {
		fields = append(fields, connector.FieldChargingState)
	}
	if m.FieldCleared(connector.FieldReservationID) {
		fields = append(fields, connector.FieldReservationID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ConnectorMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ConnectorMutation) ClearField(name string) error {
	switch name {
	case connector.FieldChargingState:
		m.ClearChargingState()
		return nil
	case connector.FieldReservationID:
		m.ClearReservationID()
		return nil
	}
	return fmt.Errorf("unknown Connector nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ConnectorMutation) ResetField(name string) error {
	switch name {
	case connector.FieldVersion:
		m.ResetVersion()
		return nil
	case connector.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case connector.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case connector.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case connector.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case connector.FieldEquipmentSn:
		m.ResetEquipmentSn()
		return nil
	case connector.FieldEvseSerial:
		m.ResetEvseSerial()
		return nil
	case connector.FieldSerial:
		m.ResetSerial()
		return nil
	case connector.FieldCurrentState:
		m.ResetCurrentState()
		return nil
	case connector.FieldBeforeState:
		m.ResetBeforeState()
		return nil
	case connector.FieldChargingState:
		m.ResetChargingState()
		return nil
	case connector.FieldReservationID:
		m.ResetReservationID()
		return nil
	case connector.FieldParkNo:
		m.ResetParkNo()
		return nil
	}
	return fmt.Errorf("unknown Connector field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ConnectorMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.evse != nil {
		edges = append(edges, connector.EdgeEvse)
	}
	if m.equipment != nil {
		edges = append(edges, connector.EdgeEquipment)
	}
	if m.order_info != nil {
		edges = append(edges, connector.EdgeOrderInfo)
	}
	if m.reservation != nil {
		edges = append(edges, connector.EdgeReservation)
	}
	if m.smart_charging_effect != nil {
		edges = append(edges, connector.EdgeSmartChargingEffect)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ConnectorMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case connector.EdgeEvse:
		if id := m.evse; id != nil {
			return []ent.Value{*id}
		}
	case connector.EdgeEquipment:
		if id := m.equipment; id != nil {
			return []ent.Value{*id}
		}
	case connector.EdgeOrderInfo:
		ids := make([]ent.Value, 0, len(m.order_info))
		for id := range m.order_info {
			ids = append(ids, id)
		}
		return ids
	case connector.EdgeReservation:
		ids := make([]ent.Value, 0, len(m.reservation))
		for id := range m.reservation {
			ids = append(ids, id)
		}
		return ids
	case connector.EdgeSmartChargingEffect:
		ids := make([]ent.Value, 0, len(m.smart_charging_effect))
		for id := range m.smart_charging_effect {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ConnectorMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedorder_info != nil {
		edges = append(edges, connector.EdgeOrderInfo)
	}
	if m.removedreservation != nil {
		edges = append(edges, connector.EdgeReservation)
	}
	if m.removedsmart_charging_effect != nil {
		edges = append(edges, connector.EdgeSmartChargingEffect)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ConnectorMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case connector.EdgeOrderInfo:
		ids := make([]ent.Value, 0, len(m.removedorder_info))
		for id := range m.removedorder_info {
			ids = append(ids, id)
		}
		return ids
	case connector.EdgeReservation:
		ids := make([]ent.Value, 0, len(m.removedreservation))
		for id := range m.removedreservation {
			ids = append(ids, id)
		}
		return ids
	case connector.EdgeSmartChargingEffect:
		ids := make([]ent.Value, 0, len(m.removedsmart_charging_effect))
		for id := range m.removedsmart_charging_effect {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ConnectorMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedevse {
		edges = append(edges, connector.EdgeEvse)
	}
	if m.clearedequipment {
		edges = append(edges, connector.EdgeEquipment)
	}
	if m.clearedorder_info {
		edges = append(edges, connector.EdgeOrderInfo)
	}
	if m.clearedreservation {
		edges = append(edges, connector.EdgeReservation)
	}
	if m.clearedsmart_charging_effect {
		edges = append(edges, connector.EdgeSmartChargingEffect)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ConnectorMutation) EdgeCleared(name string) bool {
	switch name {
	case connector.EdgeEvse:
		return m.clearedevse
	case connector.EdgeEquipment:
		return m.clearedequipment
	case connector.EdgeOrderInfo:
		return m.clearedorder_info
	case connector.EdgeReservation:
		return m.clearedreservation
	case connector.EdgeSmartChargingEffect:
		return m.clearedsmart_charging_effect
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ConnectorMutation) ClearEdge(name string) error {
	switch name {
	case connector.EdgeEvse:
		m.ClearEvse()
		return nil
	case connector.EdgeEquipment:
		m.ClearEquipment()
		return nil
	}
	return fmt.Errorf("unknown Connector unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ConnectorMutation) ResetEdge(name string) error {
	switch name {
	case connector.EdgeEvse:
		m.ResetEvse()
		return nil
	case connector.EdgeEquipment:
		m.ResetEquipment()
		return nil
	case connector.EdgeOrderInfo:
		m.ResetOrderInfo()
		return nil
	case connector.EdgeReservation:
		m.ResetReservation()
		return nil
	case connector.EdgeSmartChargingEffect:
		m.ResetSmartChargingEffect()
		return nil
	}
	return fmt.Errorf("unknown Connector edge %s", name)
}

// EquipmentMutation represents an operation that mutates the Equipment nodes in the graph.
type EquipmentMutation struct {
	config
	op                               Op
	typ                              string
	id                               *datasource.UUID
	version                          *int64
	addversion                       *int64
	created_by                       *datasource.UUID
	addcreated_by                    *datasource.UUID
	created_at                       *int64
	addcreated_at                    *int64
	updated_by                       *datasource.UUID
	addupdated_by                    *datasource.UUID
	updated_at                       *int64
	addupdated_at                    *int64
	sn                               *string
	operator_id                      *datasource.UUID
	addoperator_id                   *datasource.UUID
	station_id                       *datasource.UUID
	addstation_id                    *datasource.UUID
	clearedFields                    map[string]struct{}
	equipment_info                   *datasource.UUID
	clearedequipment_info            bool
	evse                             map[datasource.UUID]struct{}
	removedevse                      map[datasource.UUID]struct{}
	clearedevse                      bool
	connector                        map[datasource.UUID]struct{}
	removedconnector                 map[datasource.UUID]struct{}
	clearedconnector                 bool
	equipment_alarm                  map[datasource.UUID]struct{}
	removedequipment_alarm           map[datasource.UUID]struct{}
	clearedequipment_alarm           bool
	equipment_iot                    *datasource.UUID
	clearedequipment_iot             bool
	equipment_firmware_effect        map[datasource.UUID]struct{}
	removedequipment_firmware_effect map[datasource.UUID]struct{}
	clearedequipment_firmware_effect bool
	order_info                       map[datasource.UUID]struct{}
	removedorder_info                map[datasource.UUID]struct{}
	clearedorder_info                bool
	reservation                      map[datasource.UUID]struct{}
	removedreservation               map[datasource.UUID]struct{}
	clearedreservation               bool
	equipment_log                    map[datasource.UUID]struct{}
	removedequipment_log             map[datasource.UUID]struct{}
	clearedequipment_log             bool
	smart_charging_effect            map[datasource.UUID]struct{}
	removedsmart_charging_effect     map[datasource.UUID]struct{}
	clearedsmart_charging_effect     bool
	done                             bool
	oldValue                         func(context.Context) (*Equipment, error)
	predicates                       []predicate.Equipment
}

var _ ent.Mutation = (*EquipmentMutation)(nil)

// equipmentOption allows management of the mutation configuration using functional options.
type equipmentOption func(*EquipmentMutation)

// newEquipmentMutation creates new mutation for the Equipment entity.
func newEquipmentMutation(c config, op Op, opts ...equipmentOption) *EquipmentMutation {
	m := &EquipmentMutation{
		config:        c,
		op:            op,
		typ:           TypeEquipment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEquipmentID sets the ID field of the mutation.
func withEquipmentID(id datasource.UUID) equipmentOption {
	return func(m *EquipmentMutation) {
		var (
			err   error
			once  sync.Once
			value *Equipment
		)
		m.oldValue = func(ctx context.Context) (*Equipment, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Equipment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEquipment sets the old Equipment of the mutation.
func withEquipment(node *Equipment) equipmentOption {
	return func(m *EquipmentMutation) {
		m.oldValue = func(context.Context) (*Equipment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EquipmentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EquipmentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Equipment entities.
func (m *EquipmentMutation) SetID(id datasource.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EquipmentMutation) ID() (id datasource.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EquipmentMutation) IDs(ctx context.Context) ([]datasource.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []datasource.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Equipment.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetVersion sets the "version" field.
func (m *EquipmentMutation) SetVersion(i int64) {
	m.version = &i
	m.addversion = nil
}

// Version returns the value of the "version" field in the mutation.
func (m *EquipmentMutation) Version() (r int64, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the Equipment entity.
// If the Equipment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EquipmentMutation) OldVersion(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// AddVersion adds i to the "version" field.
func (m *EquipmentMutation) AddVersion(i int64) {
	if m.addversion != nil {
		*m.addversion += i
	} else {
		m.addversion = &i
	}
}

// AddedVersion returns the value that was added to the "version" field in this mutation.
func (m *EquipmentMutation) AddedVersion() (r int64, exists bool) {
	v := m.addversion
	if v == nil {
		return
	}
	return *v, true
}

// ResetVersion resets all changes to the "version" field.
func (m *EquipmentMutation) ResetVersion() {
	m.version = nil
	m.addversion = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *EquipmentMutation) SetCreatedBy(d datasource.UUID) {
	m.created_by = &d
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *EquipmentMutation) CreatedBy() (r datasource.UUID, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Equipment entity.
// If the Equipment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EquipmentMutation) OldCreatedBy(ctx context.Context) (v datasource.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds d to the "created_by" field.
func (m *EquipmentMutation) AddCreatedBy(d datasource.UUID) {
	if m.addcreated_by != nil {
		*m.addcreated_by += d
	} else {
		m.addcreated_by = &d
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *EquipmentMutation) AddedCreatedBy() (r datasource.UUID, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *EquipmentMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *EquipmentMutation) SetCreatedAt(i int64) {
	m.created_at = &i
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EquipmentMutation) CreatedAt() (r int64, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Equipment entity.
// If the Equipment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EquipmentMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to the "created_at" field.
func (m *EquipmentMutation) AddCreatedAt(i int64) {
	if m.addcreated_at != nil {
		*m.addcreated_at += i
	} else {
		m.addcreated_at = &i
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *EquipmentMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EquipmentMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *EquipmentMutation) SetUpdatedBy(d datasource.UUID) {
	m.updated_by = &d
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *EquipmentMutation) UpdatedBy() (r datasource.UUID, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Equipment entity.
// If the Equipment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EquipmentMutation) OldUpdatedBy(ctx context.Context) (v datasource.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds d to the "updated_by" field.
func (m *EquipmentMutation) AddUpdatedBy(d datasource.UUID) {
	if m.addupdated_by != nil {
		*m.addupdated_by += d
	} else {
		m.addupdated_by = &d
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *EquipmentMutation) AddedUpdatedBy() (r datasource.UUID, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *EquipmentMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *EquipmentMutation) SetUpdatedAt(i int64) {
	m.updated_at = &i
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *EquipmentMutation) UpdatedAt() (r int64, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Equipment entity.
// If the Equipment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EquipmentMutation) OldUpdatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to the "updated_at" field.
func (m *EquipmentMutation) AddUpdatedAt(i int64) {
	if m.addupdated_at != nil {
		*m.addupdated_at += i
	} else {
		m.addupdated_at = &i
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *EquipmentMutation) AddedUpdatedAt() (r int64, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *EquipmentMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetSn sets the "sn" field.
func (m *EquipmentMutation) SetSn(s string) {
	m.sn = &s
}

// Sn returns the value of the "sn" field in the mutation.
func (m *EquipmentMutation) Sn() (r string, exists bool) {
	v := m.sn
	if v == nil {
		return
	}
	return *v, true
}

// OldSn returns the old "sn" field's value of the Equipment entity.
// If the Equipment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EquipmentMutation) OldSn(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSn is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSn: %w", err)
	}
	return oldValue.Sn, nil
}

// ResetSn resets all changes to the "sn" field.
func (m *EquipmentMutation) ResetSn() {
	m.sn = nil
}

// SetOperatorID sets the "operator_id" field.
func (m *EquipmentMutation) SetOperatorID(d datasource.UUID) {
	m.operator_id = &d
	m.addoperator_id = nil
}

// OperatorID returns the value of the "operator_id" field in the mutation.
func (m *EquipmentMutation) OperatorID() (r datasource.UUID, exists bool) {
	v := m.operator_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOperatorID returns the old "operator_id" field's value of the Equipment entity.
// If the Equipment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EquipmentMutation) OldOperatorID(ctx context.Context) (v datasource.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperatorID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperatorID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperatorID: %w", err)
	}
	return oldValue.OperatorID, nil
}

// AddOperatorID adds d to the "operator_id" field.
func (m *EquipmentMutation) AddOperatorID(d datasource.UUID) {
	if m.addoperator_id != nil {
		*m.addoperator_id += d
	} else {
		m.addoperator_id = &d
	}
}

// AddedOperatorID returns the value that was added to the "operator_id" field in this mutation.
func (m *EquipmentMutation) AddedOperatorID() (r datasource.UUID, exists bool) {
	v := m.addoperator_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetOperatorID resets all changes to the "operator_id" field.
func (m *EquipmentMutation) ResetOperatorID() {
	m.operator_id = nil
	m.addoperator_id = nil
}

// SetStationID sets the "station_id" field.
func (m *EquipmentMutation) SetStationID(d datasource.UUID) {
	m.station_id = &d
	m.addstation_id = nil
}

// StationID returns the value of the "station_id" field in the mutation.
func (m *EquipmentMutation) StationID() (r datasource.UUID, exists bool) {
	v := m.station_id
	if v == nil {
		return
	}
	return *v, true
}

// OldStationID returns the old "station_id" field's value of the Equipment entity.
// If the Equipment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EquipmentMutation) OldStationID(ctx context.Context) (v datasource.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStationID: %w", err)
	}
	return oldValue.StationID, nil
}

// AddStationID adds d to the "station_id" field.
func (m *EquipmentMutation) AddStationID(d datasource.UUID) {
	if m.addstation_id != nil {
		*m.addstation_id += d
	} else {
		m.addstation_id = &d
	}
}

// AddedStationID returns the value that was added to the "station_id" field in this mutation.
func (m *EquipmentMutation) AddedStationID() (r datasource.UUID, exists bool) {
	v := m.addstation_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetStationID resets all changes to the "station_id" field.
func (m *EquipmentMutation) ResetStationID() {
	m.station_id = nil
	m.addstation_id = nil
}

// SetEquipmentInfoID sets the "equipment_info" edge to the EquipmentInfo entity by id.
func (m *EquipmentMutation) SetEquipmentInfoID(id datasource.UUID) {
	m.equipment_info = &id
}

// ClearEquipmentInfo clears the "equipment_info" edge to the EquipmentInfo entity.
func (m *EquipmentMutation) ClearEquipmentInfo() {
	m.clearedequipment_info = true
}

// EquipmentInfoCleared reports if the "equipment_info" edge to the EquipmentInfo entity was cleared.
func (m *EquipmentMutation) EquipmentInfoCleared() bool {
	return m.clearedequipment_info
}

// EquipmentInfoID returns the "equipment_info" edge ID in the mutation.
func (m *EquipmentMutation) EquipmentInfoID() (id datasource.UUID, exists bool) {
	if m.equipment_info != nil {
		return *m.equipment_info, true
	}
	return
}

// EquipmentInfoIDs returns the "equipment_info" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EquipmentInfoID instead. It exists only for internal usage by the builders.
func (m *EquipmentMutation) EquipmentInfoIDs() (ids []datasource.UUID) {
	if id := m.equipment_info; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEquipmentInfo resets all changes to the "equipment_info" edge.
func (m *EquipmentMutation) ResetEquipmentInfo() {
	m.equipment_info = nil
	m.clearedequipment_info = false
}

// AddEvseIDs adds the "evse" edge to the Evse entity by ids.
func (m *EquipmentMutation) AddEvseIDs(ids ...datasource.UUID) {
	if m.evse == nil {
		m.evse = make(map[datasource.UUID]struct{})
	}
	for i := range ids {
		m.evse[ids[i]] = struct{}{}
	}
}

// ClearEvse clears the "evse" edge to the Evse entity.
func (m *EquipmentMutation) ClearEvse() {
	m.clearedevse = true
}

// EvseCleared reports if the "evse" edge to the Evse entity was cleared.
func (m *EquipmentMutation) EvseCleared() bool {
	return m.clearedevse
}

// RemoveEvseIDs removes the "evse" edge to the Evse entity by IDs.
func (m *EquipmentMutation) RemoveEvseIDs(ids ...datasource.UUID) {
	if m.removedevse == nil {
		m.removedevse = make(map[datasource.UUID]struct{})
	}
	for i := range ids {
		delete(m.evse, ids[i])
		m.removedevse[ids[i]] = struct{}{}
	}
}

// RemovedEvse returns the removed IDs of the "evse" edge to the Evse entity.
func (m *EquipmentMutation) RemovedEvseIDs() (ids []datasource.UUID) {
	for id := range m.removedevse {
		ids = append(ids, id)
	}
	return
}

// EvseIDs returns the "evse" edge IDs in the mutation.
func (m *EquipmentMutation) EvseIDs() (ids []datasource.UUID) {
	for id := range m.evse {
		ids = append(ids, id)
	}
	return
}

// ResetEvse resets all changes to the "evse" edge.
func (m *EquipmentMutation) ResetEvse() {
	m.evse = nil
	m.clearedevse = false
	m.removedevse = nil
}

// AddConnectorIDs adds the "connector" edge to the Connector entity by ids.
func (m *EquipmentMutation) AddConnectorIDs(ids ...datasource.UUID) {
	if m.connector == nil {
		m.connector = make(map[datasource.UUID]struct{})
	}
	for i := range ids {
		m.connector[ids[i]] = struct{}{}
	}
}

// ClearConnector clears the "connector" edge to the Connector entity.
func (m *EquipmentMutation) ClearConnector() {
	m.clearedconnector = true
}

// ConnectorCleared reports if the "connector" edge to the Connector entity was cleared.
func (m *EquipmentMutation) ConnectorCleared() bool {
	return m.clearedconnector
}

// RemoveConnectorIDs removes the "connector" edge to the Connector entity by IDs.
func (m *EquipmentMutation) RemoveConnectorIDs(ids ...datasource.UUID) {
	if m.removedconnector == nil {
		m.removedconnector = make(map[datasource.UUID]struct{})
	}
	for i := range ids {
		delete(m.connector, ids[i])
		m.removedconnector[ids[i]] = struct{}{}
	}
}

// RemovedConnector returns the removed IDs of the "connector" edge to the Connector entity.
func (m *EquipmentMutation) RemovedConnectorIDs() (ids []datasource.UUID) {
	for id := range m.removedconnector {
		ids = append(ids, id)
	}
	return
}

// ConnectorIDs returns the "connector" edge IDs in the mutation.
func (m *EquipmentMutation) ConnectorIDs() (ids []datasource.UUID) {
	for id := range m.connector {
		ids = append(ids, id)
	}
	return
}

// ResetConnector resets all changes to the "connector" edge.
func (m *EquipmentMutation) ResetConnector() {
	m.connector = nil
	m.clearedconnector = false
	m.removedconnector = nil
}

// AddEquipmentAlarmIDs adds the "equipment_alarm" edge to the EquipmentAlarm entity by ids.
func (m *EquipmentMutation) AddEquipmentAlarmIDs(ids ...datasource.UUID) {
	if m.equipment_alarm == nil {
		m.equipment_alarm = make(map[datasource.UUID]struct{})
	}
	for i := range ids {
		m.equipment_alarm[ids[i]] = struct{}{}
	}
}

// ClearEquipmentAlarm clears the "equipment_alarm" edge to the EquipmentAlarm entity.
func (m *EquipmentMutation) ClearEquipmentAlarm() {
	m.clearedequipment_alarm = true
}

// EquipmentAlarmCleared reports if the "equipment_alarm" edge to the EquipmentAlarm entity was cleared.
func (m *EquipmentMutation) EquipmentAlarmCleared() bool {
	return m.clearedequipment_alarm
}

// RemoveEquipmentAlarmIDs removes the "equipment_alarm" edge to the EquipmentAlarm entity by IDs.
func (m *EquipmentMutation) RemoveEquipmentAlarmIDs(ids ...datasource.UUID) {
	if m.removedequipment_alarm == nil {
		m.removedequipment_alarm = make(map[datasource.UUID]struct{})
	}
	for i := range ids {
		delete(m.equipment_alarm, ids[i])
		m.removedequipment_alarm[ids[i]] = struct{}{}
	}
}

// RemovedEquipmentAlarm returns the removed IDs of the "equipment_alarm" edge to the EquipmentAlarm entity.
func (m *EquipmentMutation) RemovedEquipmentAlarmIDs() (ids []datasource.UUID) {
	for id := range m.removedequipment_alarm {
		ids = append(ids, id)
	}
	return
}

// EquipmentAlarmIDs returns the "equipment_alarm" edge IDs in the mutation.
func (m *EquipmentMutation) EquipmentAlarmIDs() (ids []datasource.UUID) {
	for id := range m.equipment_alarm {
		ids = append(ids, id)
	}
	return
}

// ResetEquipmentAlarm resets all changes to the "equipment_alarm" edge.
func (m *EquipmentMutation) ResetEquipmentAlarm() {
	m.equipment_alarm = nil
	m.clearedequipment_alarm = false
	m.removedequipment_alarm = nil
}

// SetEquipmentIotID sets the "equipment_iot" edge to the EquipmentIot entity by id.
func (m *EquipmentMutation) SetEquipmentIotID(id datasource.UUID) {
	m.equipment_iot = &id
}

// ClearEquipmentIot clears the "equipment_iot" edge to the EquipmentIot entity.
func (m *EquipmentMutation) ClearEquipmentIot() {
	m.clearedequipment_iot = true
}

// EquipmentIotCleared reports if the "equipment_iot" edge to the EquipmentIot entity was cleared.
func (m *EquipmentMutation) EquipmentIotCleared() bool {
	return m.clearedequipment_iot
}

// EquipmentIotID returns the "equipment_iot" edge ID in the mutation.
func (m *EquipmentMutation) EquipmentIotID() (id datasource.UUID, exists bool) {
	if m.equipment_iot != nil {
		return *m.equipment_iot, true
	}
	return
}

// EquipmentIotIDs returns the "equipment_iot" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EquipmentIotID instead. It exists only for internal usage by the builders.
func (m *EquipmentMutation) EquipmentIotIDs() (ids []datasource.UUID) {
	if id := m.equipment_iot; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEquipmentIot resets all changes to the "equipment_iot" edge.
func (m *EquipmentMutation) ResetEquipmentIot() {
	m.equipment_iot = nil
	m.clearedequipment_iot = false
}

// AddEquipmentFirmwareEffectIDs adds the "equipment_firmware_effect" edge to the EquipmentFirmwareEffect entity by ids.
func (m *EquipmentMutation) AddEquipmentFirmwareEffectIDs(ids ...datasource.UUID) {
	if m.equipment_firmware_effect == nil {
		m.equipment_firmware_effect = make(map[datasource.UUID]struct{})
	}
	for i := range ids {
		m.equipment_firmware_effect[ids[i]] = struct{}{}
	}
}

// ClearEquipmentFirmwareEffect clears the "equipment_firmware_effect" edge to the EquipmentFirmwareEffect entity.
func (m *EquipmentMutation) ClearEquipmentFirmwareEffect() {
	m.clearedequipment_firmware_effect = true
}

// EquipmentFirmwareEffectCleared reports if the "equipment_firmware_effect" edge to the EquipmentFirmwareEffect entity was cleared.
func (m *EquipmentMutation) EquipmentFirmwareEffectCleared() bool {
	return m.clearedequipment_firmware_effect
}

// RemoveEquipmentFirmwareEffectIDs removes the "equipment_firmware_effect" edge to the EquipmentFirmwareEffect entity by IDs.
func (m *EquipmentMutation) RemoveEquipmentFirmwareEffectIDs(ids ...datasource.UUID) {
	if m.removedequipment_firmware_effect == nil {
		m.removedequipment_firmware_effect = make(map[datasource.UUID]struct{})
	}
	for i := range ids {
		delete(m.equipment_firmware_effect, ids[i])
		m.removedequipment_firmware_effect[ids[i]] = struct{}{}
	}
}

// RemovedEquipmentFirmwareEffect returns the removed IDs of the "equipment_firmware_effect" edge to the EquipmentFirmwareEffect entity.
func (m *EquipmentMutation) RemovedEquipmentFirmwareEffectIDs() (ids []datasource.UUID) {
	for id := range m.removedequipment_firmware_effect {
		ids = append(ids, id)
	}
	return
}

// EquipmentFirmwareEffectIDs returns the "equipment_firmware_effect" edge IDs in the mutation.
func (m *EquipmentMutation) EquipmentFirmwareEffectIDs() (ids []datasource.UUID) {
	for id := range m.equipment_firmware_effect {
		ids = append(ids, id)
	}
	return
}

// ResetEquipmentFirmwareEffect resets all changes to the "equipment_firmware_effect" edge.
func (m *EquipmentMutation) ResetEquipmentFirmwareEffect() {
	m.equipment_firmware_effect = nil
	m.clearedequipment_firmware_effect = false
	m.removedequipment_firmware_effect = nil
}

// AddOrderInfoIDs adds the "order_info" edge to the OrderInfo entity by ids.
func (m *EquipmentMutation) AddOrderInfoIDs(ids ...datasource.UUID) {
	if m.order_info == nil {
		m.order_info = make(map[datasource.UUID]struct{})
	}
	for i := range ids {
		m.order_info[ids[i]] = struct{}{}
	}
}

// ClearOrderInfo clears the "order_info" edge to the OrderInfo entity.
func (m *EquipmentMutation) ClearOrderInfo() {
	m.clearedorder_info = true
}

// OrderInfoCleared reports if the "order_info" edge to the OrderInfo entity was cleared.
func (m *EquipmentMutation) OrderInfoCleared() bool {
	return m.clearedorder_info
}

// RemoveOrderInfoIDs removes the "order_info" edge to the OrderInfo entity by IDs.
func (m *EquipmentMutation) RemoveOrderInfoIDs(ids ...datasource.UUID) {
	if m.removedorder_info == nil {
		m.removedorder_info = make(map[datasource.UUID]struct{})
	}
	for i := range ids {
		delete(m.order_info, ids[i])
		m.removedorder_info[ids[i]] = struct{}{}
	}
}

// RemovedOrderInfo returns the removed IDs of the "order_info" edge to the OrderInfo entity.
func (m *EquipmentMutation) RemovedOrderInfoIDs() (ids []datasource.UUID) {
	for id := range m.removedorder_info {
		ids = append(ids, id)
	}
	return
}

// OrderInfoIDs returns the "order_info" edge IDs in the mutation.
func (m *EquipmentMutation) OrderInfoIDs() (ids []datasource.UUID) {
	for id := range m.order_info {
		ids = append(ids, id)
	}
	return
}

// ResetOrderInfo resets all changes to the "order_info" edge.
func (m *EquipmentMutation) ResetOrderInfo() {
	m.order_info = nil
	m.clearedorder_info = false
	m.removedorder_info = nil
}

// AddReservationIDs adds the "reservation" edge to the Reservation entity by ids.
func (m *EquipmentMutation) AddReservationIDs(ids ...datasource.UUID) {
	if m.reservation == nil {
		m.reservation = make(map[datasource.UUID]struct{})
	}
	for i := range ids {
		m.reservation[ids[i]] = struct{}{}
	}
}

// ClearReservation clears the "reservation" edge to the Reservation entity.
func (m *EquipmentMutation) ClearReservation() {
	m.clearedreservation = true
}

// ReservationCleared reports if the "reservation" edge to the Reservation entity was cleared.
func (m *EquipmentMutation) ReservationCleared() bool {
	return m.clearedreservation
}

// RemoveReservationIDs removes the "reservation" edge to the Reservation entity by IDs.
func (m *EquipmentMutation) RemoveReservationIDs(ids ...datasource.UUID) {
	if m.removedreservation == nil {
		m.removedreservation = make(map[datasource.UUID]struct{})
	}
	for i := range ids {
		delete(m.reservation, ids[i])
		m.removedreservation[ids[i]] = struct{}{}
	}
}

// RemovedReservation returns the removed IDs of the "reservation" edge to the Reservation entity.
func (m *EquipmentMutation) RemovedReservationIDs() (ids []datasource.UUID) {
	for id := range m.removedreservation {
		ids = append(ids, id)
	}
	return
}

// ReservationIDs returns the "reservation" edge IDs in the mutation.
func (m *EquipmentMutation) ReservationIDs() (ids []datasource.UUID) {
	for id := range m.reservation {
		ids = append(ids, id)
	}
	return
}

// ResetReservation resets all changes to the "reservation" edge.
func (m *EquipmentMutation) ResetReservation() {
	m.reservation = nil
	m.clearedreservation = false
	m.removedreservation = nil
}

// AddEquipmentLogIDs adds the "equipment_log" edge to the EquipmentLog entity by ids.
func (m *EquipmentMutation) AddEquipmentLogIDs(ids ...datasource.UUID) {
	if m.equipment_log == nil {
		m.equipment_log = make(map[datasource.UUID]struct{})
	}
	for i := range ids {
		m.equipment_log[ids[i]] = struct{}{}
	}
}

// ClearEquipmentLog clears the "equipment_log" edge to the EquipmentLog entity.
func (m *EquipmentMutation) ClearEquipmentLog() {
	m.clearedequipment_log = true
}

// EquipmentLogCleared reports if the "equipment_log" edge to the EquipmentLog entity was cleared.
func (m *EquipmentMutation) EquipmentLogCleared() bool {
	return m.clearedequipment_log
}

// RemoveEquipmentLogIDs removes the "equipment_log" edge to the EquipmentLog entity by IDs.
func (m *EquipmentMutation) RemoveEquipmentLogIDs(ids ...datasource.UUID) {
	if m.removedequipment_log == nil {
		m.removedequipment_log = make(map[datasource.UUID]struct{})
	}
	for i := range ids {
		delete(m.equipment_log, ids[i])
		m.removedequipment_log[ids[i]] = struct{}{}
	}
}

// RemovedEquipmentLog returns the removed IDs of the "equipment_log" edge to the EquipmentLog entity.
func (m *EquipmentMutation) RemovedEquipmentLogIDs() (ids []datasource.UUID) {
	for id := range m.removedequipment_log {
		ids = append(ids, id)
	}
	return
}

// EquipmentLogIDs returns the "equipment_log" edge IDs in the mutation.
func (m *EquipmentMutation) EquipmentLogIDs() (ids []datasource.UUID) {
	for id := range m.equipment_log {
		ids = append(ids, id)
	}
	return
}

// ResetEquipmentLog resets all changes to the "equipment_log" edge.
func (m *EquipmentMutation) ResetEquipmentLog() {
	m.equipment_log = nil
	m.clearedequipment_log = false
	m.removedequipment_log = nil
}

// AddSmartChargingEffectIDs adds the "smart_charging_effect" edge to the SmartChargingEffect entity by ids.
func (m *EquipmentMutation) AddSmartChargingEffectIDs(ids ...datasource.UUID) {
	if m.smart_charging_effect == nil {
		m.smart_charging_effect = make(map[datasource.UUID]struct{})
	}
	for i := range ids {
		m.smart_charging_effect[ids[i]] = struct{}{}
	}
}

// ClearSmartChargingEffect clears the "smart_charging_effect" edge to the SmartChargingEffect entity.
func (m *EquipmentMutation) ClearSmartChargingEffect() {
	m.clearedsmart_charging_effect = true
}

// SmartChargingEffectCleared reports if the "smart_charging_effect" edge to the SmartChargingEffect entity was cleared.
func (m *EquipmentMutation) SmartChargingEffectCleared() bool {
	return m.clearedsmart_charging_effect
}

// RemoveSmartChargingEffectIDs removes the "smart_charging_effect" edge to the SmartChargingEffect entity by IDs.
func (m *EquipmentMutation) RemoveSmartChargingEffectIDs(ids ...datasource.UUID) {
	if m.removedsmart_charging_effect == nil {
		m.removedsmart_charging_effect = make(map[datasource.UUID]struct{})
	}
	for i := range ids {
		delete(m.smart_charging_effect, ids[i])
		m.removedsmart_charging_effect[ids[i]] = struct{}{}
	}
}

// RemovedSmartChargingEffect returns the removed IDs of the "smart_charging_effect" edge to the SmartChargingEffect entity.
func (m *EquipmentMutation) RemovedSmartChargingEffectIDs() (ids []datasource.UUID) {
	for id := range m.removedsmart_charging_effect {
		ids = append(ids, id)
	}
	return
}

// SmartChargingEffectIDs returns the "smart_charging_effect" edge IDs in the mutation.
func (m *EquipmentMutation) SmartChargingEffectIDs() (ids []datasource.UUID) {
	for id := range m.smart_charging_effect {
		ids = append(ids, id)
	}
	return
}

// ResetSmartChargingEffect resets all changes to the "smart_charging_effect" edge.
func (m *EquipmentMutation) ResetSmartChargingEffect() {
	m.smart_charging_effect = nil
	m.clearedsmart_charging_effect = false
	m.removedsmart_charging_effect = nil
}

// Where appends a list predicates to the EquipmentMutation builder.
func (m *EquipmentMutation) Where(ps ...predicate.Equipment) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *EquipmentMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Equipment).
func (m *EquipmentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EquipmentMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.version != nil {
		fields = append(fields, equipment.FieldVersion)
	}
	if m.created_by != nil {
		fields = append(fields, equipment.FieldCreatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, equipment.FieldCreatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, equipment.FieldUpdatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, equipment.FieldUpdatedAt)
	}
	if m.sn != nil {
		fields = append(fields, equipment.FieldSn)
	}
	if m.operator_id != nil {
		fields = append(fields, equipment.FieldOperatorID)
	}
	if m.station_id != nil {
		fields = append(fields, equipment.FieldStationID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EquipmentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case equipment.FieldVersion:
		return m.Version()
	case equipment.FieldCreatedBy:
		return m.CreatedBy()
	case equipment.FieldCreatedAt:
		return m.CreatedAt()
	case equipment.FieldUpdatedBy:
		return m.UpdatedBy()
	case equipment.FieldUpdatedAt:
		return m.UpdatedAt()
	case equipment.FieldSn:
		return m.Sn()
	case equipment.FieldOperatorID:
		return m.OperatorID()
	case equipment.FieldStationID:
		return m.StationID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EquipmentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case equipment.FieldVersion:
		return m.OldVersion(ctx)
	case equipment.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case equipment.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case equipment.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case equipment.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case equipment.FieldSn:
		return m.OldSn(ctx)
	case equipment.FieldOperatorID:
		return m.OldOperatorID(ctx)
	case equipment.FieldStationID:
		return m.OldStationID(ctx)
	}
	return nil, fmt.Errorf("unknown Equipment field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EquipmentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case equipment.FieldVersion:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case equipment.FieldCreatedBy:
		v, ok := value.(datasource.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case equipment.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case equipment.FieldUpdatedBy:
		v, ok := value.(datasource.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case equipment.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case equipment.FieldSn:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSn(v)
		return nil
	case equipment.FieldOperatorID:
		v, ok := value.(datasource.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperatorID(v)
		return nil
	case equipment.FieldStationID:
		v, ok := value.(datasource.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStationID(v)
		return nil
	}
	return fmt.Errorf("unknown Equipment field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EquipmentMutation) AddedFields() []string {
	var fields []string
	if m.addversion != nil {
		fields = append(fields, equipment.FieldVersion)
	}
	if m.addcreated_by != nil {
		fields = append(fields, equipment.FieldCreatedBy)
	}
	if m.addcreated_at != nil {
		fields = append(fields, equipment.FieldCreatedAt)
	}
	if m.addupdated_by != nil {
		fields = append(fields, equipment.FieldUpdatedBy)
	}
	if m.addupdated_at != nil {
		fields = append(fields, equipment.FieldUpdatedAt)
	}
	if m.addoperator_id != nil {
		fields = append(fields, equipment.FieldOperatorID)
	}
	if m.addstation_id != nil {
		fields = append(fields, equipment.FieldStationID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EquipmentMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case equipment.FieldVersion:
		return m.AddedVersion()
	case equipment.FieldCreatedBy:
		return m.AddedCreatedBy()
	case equipment.FieldCreatedAt:
		return m.AddedCreatedAt()
	case equipment.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case equipment.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case equipment.FieldOperatorID:
		return m.AddedOperatorID()
	case equipment.FieldStationID:
		return m.AddedStationID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EquipmentMutation) AddField(name string, value ent.Value) error {
	switch name {
	case equipment.FieldVersion:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVersion(v)
		return nil
	case equipment.FieldCreatedBy:
		v, ok := value.(datasource.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case equipment.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case equipment.FieldUpdatedBy:
		v, ok := value.(datasource.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case equipment.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case equipment.FieldOperatorID:
		v, ok := value.(datasource.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOperatorID(v)
		return nil
	case equipment.FieldStationID:
		v, ok := value.(datasource.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStationID(v)
		return nil
	}
	return fmt.Errorf("unknown Equipment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EquipmentMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EquipmentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EquipmentMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Equipment nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EquipmentMutation) ResetField(name string) error {
	switch name {
	case equipment.FieldVersion:
		m.ResetVersion()
		return nil
	case equipment.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case equipment.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case equipment.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case equipment.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case equipment.FieldSn:
		m.ResetSn()
		return nil
	case equipment.FieldOperatorID:
		m.ResetOperatorID()
		return nil
	case equipment.FieldStationID:
		m.ResetStationID()
		return nil
	}
	return fmt.Errorf("unknown Equipment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EquipmentMutation) AddedEdges() []string {
	edges := make([]string, 0, 10)
	if m.equipment_info != nil {
		edges = append(edges, equipment.EdgeEquipmentInfo)
	}
	if m.evse != nil {
		edges = append(edges, equipment.EdgeEvse)
	}
	if m.connector != nil {
		edges = append(edges, equipment.EdgeConnector)
	}
	if m.equipment_alarm != nil {
		edges = append(edges, equipment.EdgeEquipmentAlarm)
	}
	if m.equipment_iot != nil {
		edges = append(edges, equipment.EdgeEquipmentIot)
	}
	if m.equipment_firmware_effect != nil {
		edges = append(edges, equipment.EdgeEquipmentFirmwareEffect)
	}
	if m.order_info != nil {
		edges = append(edges, equipment.EdgeOrderInfo)
	}
	if m.reservation != nil {
		edges = append(edges, equipment.EdgeReservation)
	}
	if m.equipment_log != nil {
		edges = append(edges, equipment.EdgeEquipmentLog)
	}
	if m.smart_charging_effect != nil {
		edges = append(edges, equipment.EdgeSmartChargingEffect)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EquipmentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case equipment.EdgeEquipmentInfo:
		if id := m.equipment_info; id != nil {
			return []ent.Value{*id}
		}
	case equipment.EdgeEvse:
		ids := make([]ent.Value, 0, len(m.evse))
		for id := range m.evse {
			ids = append(ids, id)
		}
		return ids
	case equipment.EdgeConnector:
		ids := make([]ent.Value, 0, len(m.connector))
		for id := range m.connector {
			ids = append(ids, id)
		}
		return ids
	case equipment.EdgeEquipmentAlarm:
		ids := make([]ent.Value, 0, len(m.equipment_alarm))
		for id := range m.equipment_alarm {
			ids = append(ids, id)
		}
		return ids
	case equipment.EdgeEquipmentIot:
		if id := m.equipment_iot; id != nil {
			return []ent.Value{*id}
		}
	case equipment.EdgeEquipmentFirmwareEffect:
		ids := make([]ent.Value, 0, len(m.equipment_firmware_effect))
		for id := range m.equipment_firmware_effect {
			ids = append(ids, id)
		}
		return ids
	case equipment.EdgeOrderInfo:
		ids := make([]ent.Value, 0, len(m.order_info))
		for id := range m.order_info {
			ids = append(ids, id)
		}
		return ids
	case equipment.EdgeReservation:
		ids := make([]ent.Value, 0, len(m.reservation))
		for id := range m.reservation {
			ids = append(ids, id)
		}
		return ids
	case equipment.EdgeEquipmentLog:
		ids := make([]ent.Value, 0, len(m.equipment_log))
		for id := range m.equipment_log {
			ids = append(ids, id)
		}
		return ids
	case equipment.EdgeSmartChargingEffect:
		ids := make([]ent.Value, 0, len(m.smart_charging_effect))
		for id := range m.smart_charging_effect {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EquipmentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 10)
	if m.removedevse != nil {
		edges = append(edges, equipment.EdgeEvse)
	}
	if m.removedconnector != nil {
		edges = append(edges, equipment.EdgeConnector)
	}
	if m.removedequipment_alarm != nil {
		edges = append(edges, equipment.EdgeEquipmentAlarm)
	}
	if m.removedequipment_firmware_effect != nil {
		edges = append(edges, equipment.EdgeEquipmentFirmwareEffect)
	}
	if m.removedorder_info != nil {
		edges = append(edges, equipment.EdgeOrderInfo)
	}
	if m.removedreservation != nil {
		edges = append(edges, equipment.EdgeReservation)
	}
	if m.removedequipment_log != nil {
		edges = append(edges, equipment.EdgeEquipmentLog)
	}
	if m.removedsmart_charging_effect != nil {
		edges = append(edges, equipment.EdgeSmartChargingEffect)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EquipmentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case equipment.EdgeEvse:
		ids := make([]ent.Value, 0, len(m.removedevse))
		for id := range m.removedevse {
			ids = append(ids, id)
		}
		return ids
	case equipment.EdgeConnector:
		ids := make([]ent.Value, 0, len(m.removedconnector))
		for id := range m.removedconnector {
			ids = append(ids, id)
		}
		return ids
	case equipment.EdgeEquipmentAlarm:
		ids := make([]ent.Value, 0, len(m.removedequipment_alarm))
		for id := range m.removedequipment_alarm {
			ids = append(ids, id)
		}
		return ids
	case equipment.EdgeEquipmentFirmwareEffect:
		ids := make([]ent.Value, 0, len(m.removedequipment_firmware_effect))
		for id := range m.removedequipment_firmware_effect {
			ids = append(ids, id)
		}
		return ids
	case equipment.EdgeOrderInfo:
		ids := make([]ent.Value, 0, len(m.removedorder_info))
		for id := range m.removedorder_info {
			ids = append(ids, id)
		}
		return ids
	case equipment.EdgeReservation:
		ids := make([]ent.Value, 0, len(m.removedreservation))
		for id := range m.removedreservation {
			ids = append(ids, id)
		}
		return ids
	case equipment.EdgeEquipmentLog:
		ids := make([]ent.Value, 0, len(m.removedequipment_log))
		for id := range m.removedequipment_log {
			ids = append(ids, id)
		}
		return ids
	case equipment.EdgeSmartChargingEffect:
		ids := make([]ent.Value, 0, len(m.removedsmart_charging_effect))
		for id := range m.removedsmart_charging_effect {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EquipmentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 10)
	if m.clearedequipment_info {
		edges = append(edges, equipment.EdgeEquipmentInfo)
	}
	if m.clearedevse {
		edges = append(edges, equipment.EdgeEvse)
	}
	if m.clearedconnector {
		edges = append(edges, equipment.EdgeConnector)
	}
	if m.clearedequipment_alarm {
		edges = append(edges, equipment.EdgeEquipmentAlarm)
	}
	if m.clearedequipment_iot {
		edges = append(edges, equipment.EdgeEquipmentIot)
	}
	if m.clearedequipment_firmware_effect {
		edges = append(edges, equipment.EdgeEquipmentFirmwareEffect)
	}
	if m.clearedorder_info {
		edges = append(edges, equipment.EdgeOrderInfo)
	}
	if m.clearedreservation {
		edges = append(edges, equipment.EdgeReservation)
	}
	if m.clearedequipment_log {
		edges = append(edges, equipment.EdgeEquipmentLog)
	}
	if m.clearedsmart_charging_effect {
		edges = append(edges, equipment.EdgeSmartChargingEffect)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EquipmentMutation) EdgeCleared(name string) bool {
	switch name {
	case equipment.EdgeEquipmentInfo:
		return m.clearedequipment_info
	case equipment.EdgeEvse:
		return m.clearedevse
	case equipment.EdgeConnector:
		return m.clearedconnector
	case equipment.EdgeEquipmentAlarm:
		return m.clearedequipment_alarm
	case equipment.EdgeEquipmentIot:
		return m.clearedequipment_iot
	case equipment.EdgeEquipmentFirmwareEffect:
		return m.clearedequipment_firmware_effect
	case equipment.EdgeOrderInfo:
		return m.clearedorder_info
	case equipment.EdgeReservation:
		return m.clearedreservation
	case equipment.EdgeEquipmentLog:
		return m.clearedequipment_log
	case equipment.EdgeSmartChargingEffect:
		return m.clearedsmart_charging_effect
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EquipmentMutation) ClearEdge(name string) error {
	switch name {
	case equipment.EdgeEquipmentInfo:
		m.ClearEquipmentInfo()
		return nil
	case equipment.EdgeEquipmentIot:
		m.ClearEquipmentIot()
		return nil
	}
	return fmt.Errorf("unknown Equipment unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EquipmentMutation) ResetEdge(name string) error {
	switch name {
	case equipment.EdgeEquipmentInfo:
		m.ResetEquipmentInfo()
		return nil
	case equipment.EdgeEvse:
		m.ResetEvse()
		return nil
	case equipment.EdgeConnector:
		m.ResetConnector()
		return nil
	case equipment.EdgeEquipmentAlarm:
		m.ResetEquipmentAlarm()
		return nil
	case equipment.EdgeEquipmentIot:
		m.ResetEquipmentIot()
		return nil
	case equipment.EdgeEquipmentFirmwareEffect:
		m.ResetEquipmentFirmwareEffect()
		return nil
	case equipment.EdgeOrderInfo:
		m.ResetOrderInfo()
		return nil
	case equipment.EdgeReservation:
		m.ResetReservation()
		return nil
	case equipment.EdgeEquipmentLog:
		m.ResetEquipmentLog()
		return nil
	case equipment.EdgeSmartChargingEffect:
		m.ResetSmartChargingEffect()
		return nil
	}
	return fmt.Errorf("unknown Equipment edge %s", name)
}

// EquipmentAlarmMutation represents an operation that mutates the EquipmentAlarm nodes in the graph.
type EquipmentAlarmMutation struct {
	config
	op               Op
	typ              string
	id               *datasource.UUID
	version          *int64
	addversion       *int64
	created_by       *datasource.UUID
	addcreated_by    *datasource.UUID
	created_at       *int64
	addcreated_at    *int64
	updated_by       *datasource.UUID
	addupdated_by    *datasource.UUID
	updated_at       *int64
	addupdated_at    *int64
	dtc_code         *int64
	adddtc_code      *int64
	remote_address   *string
	trigger_time     *int64
	addtrigger_time  *int64
	final_time       *int64
	addfinal_time    *int64
	count            *int
	addcount         *int
	clearedFields    map[string]struct{}
	equipment        *datasource.UUID
	clearedequipment bool
	done             bool
	oldValue         func(context.Context) (*EquipmentAlarm, error)
	predicates       []predicate.EquipmentAlarm
}

var _ ent.Mutation = (*EquipmentAlarmMutation)(nil)

// equipmentalarmOption allows management of the mutation configuration using functional options.
type equipmentalarmOption func(*EquipmentAlarmMutation)

// newEquipmentAlarmMutation creates new mutation for the EquipmentAlarm entity.
func newEquipmentAlarmMutation(c config, op Op, opts ...equipmentalarmOption) *EquipmentAlarmMutation {
	m := &EquipmentAlarmMutation{
		config:        c,
		op:            op,
		typ:           TypeEquipmentAlarm,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEquipmentAlarmID sets the ID field of the mutation.
func withEquipmentAlarmID(id datasource.UUID) equipmentalarmOption {
	return func(m *EquipmentAlarmMutation) {
		var (
			err   error
			once  sync.Once
			value *EquipmentAlarm
		)
		m.oldValue = func(ctx context.Context) (*EquipmentAlarm, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().EquipmentAlarm.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEquipmentAlarm sets the old EquipmentAlarm of the mutation.
func withEquipmentAlarm(node *EquipmentAlarm) equipmentalarmOption {
	return func(m *EquipmentAlarmMutation) {
		m.oldValue = func(context.Context) (*EquipmentAlarm, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EquipmentAlarmMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EquipmentAlarmMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of EquipmentAlarm entities.
func (m *EquipmentAlarmMutation) SetID(id datasource.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EquipmentAlarmMutation) ID() (id datasource.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EquipmentAlarmMutation) IDs(ctx context.Context) ([]datasource.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []datasource.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().EquipmentAlarm.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetVersion sets the "version" field.
func (m *EquipmentAlarmMutation) SetVersion(i int64) {
	m.version = &i
	m.addversion = nil
}

// Version returns the value of the "version" field in the mutation.
func (m *EquipmentAlarmMutation) Version() (r int64, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the EquipmentAlarm entity.
// If the EquipmentAlarm object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EquipmentAlarmMutation) OldVersion(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// AddVersion adds i to the "version" field.
func (m *EquipmentAlarmMutation) AddVersion(i int64) {
	if m.addversion != nil {
		*m.addversion += i
	} else {
		m.addversion = &i
	}
}

// AddedVersion returns the value that was added to the "version" field in this mutation.
func (m *EquipmentAlarmMutation) AddedVersion() (r int64, exists bool) {
	v := m.addversion
	if v == nil {
		return
	}
	return *v, true
}

// ResetVersion resets all changes to the "version" field.
func (m *EquipmentAlarmMutation) ResetVersion() {
	m.version = nil
	m.addversion = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *EquipmentAlarmMutation) SetCreatedBy(d datasource.UUID) {
	m.created_by = &d
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *EquipmentAlarmMutation) CreatedBy() (r datasource.UUID, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the EquipmentAlarm entity.
// If the EquipmentAlarm object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EquipmentAlarmMutation) OldCreatedBy(ctx context.Context) (v datasource.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds d to the "created_by" field.
func (m *EquipmentAlarmMutation) AddCreatedBy(d datasource.UUID) {
	if m.addcreated_by != nil {
		*m.addcreated_by += d
	} else {
		m.addcreated_by = &d
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *EquipmentAlarmMutation) AddedCreatedBy() (r datasource.UUID, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *EquipmentAlarmMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *EquipmentAlarmMutation) SetCreatedAt(i int64) {
	m.created_at = &i
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EquipmentAlarmMutation) CreatedAt() (r int64, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the EquipmentAlarm entity.
// If the EquipmentAlarm object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EquipmentAlarmMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to the "created_at" field.
func (m *EquipmentAlarmMutation) AddCreatedAt(i int64) {
	if m.addcreated_at != nil {
		*m.addcreated_at += i
	} else {
		m.addcreated_at = &i
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *EquipmentAlarmMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EquipmentAlarmMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *EquipmentAlarmMutation) SetUpdatedBy(d datasource.UUID) {
	m.updated_by = &d
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *EquipmentAlarmMutation) UpdatedBy() (r datasource.UUID, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the EquipmentAlarm entity.
// If the EquipmentAlarm object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EquipmentAlarmMutation) OldUpdatedBy(ctx context.Context) (v datasource.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds d to the "updated_by" field.
func (m *EquipmentAlarmMutation) AddUpdatedBy(d datasource.UUID) {
	if m.addupdated_by != nil {
		*m.addupdated_by += d
	} else {
		m.addupdated_by = &d
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *EquipmentAlarmMutation) AddedUpdatedBy() (r datasource.UUID, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *EquipmentAlarmMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *EquipmentAlarmMutation) SetUpdatedAt(i int64) {
	m.updated_at = &i
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *EquipmentAlarmMutation) UpdatedAt() (r int64, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the EquipmentAlarm entity.
// If the EquipmentAlarm object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EquipmentAlarmMutation) OldUpdatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to the "updated_at" field.
func (m *EquipmentAlarmMutation) AddUpdatedAt(i int64) {
	if m.addupdated_at != nil {
		*m.addupdated_at += i
	} else {
		m.addupdated_at = &i
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *EquipmentAlarmMutation) AddedUpdatedAt() (r int64, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *EquipmentAlarmMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDtcCode sets the "dtc_code" field.
func (m *EquipmentAlarmMutation) SetDtcCode(i int64) {
	m.dtc_code = &i
	m.adddtc_code = nil
}

// DtcCode returns the value of the "dtc_code" field in the mutation.
func (m *EquipmentAlarmMutation) DtcCode() (r int64, exists bool) {
	v := m.dtc_code
	if v == nil {
		return
	}
	return *v, true
}

// OldDtcCode returns the old "dtc_code" field's value of the EquipmentAlarm entity.
// If the EquipmentAlarm object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EquipmentAlarmMutation) OldDtcCode(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDtcCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDtcCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDtcCode: %w", err)
	}
	return oldValue.DtcCode, nil
}

// AddDtcCode adds i to the "dtc_code" field.
func (m *EquipmentAlarmMutation) AddDtcCode(i int64) {
	if m.adddtc_code != nil {
		*m.adddtc_code += i
	} else {
		m.adddtc_code = &i
	}
}

// AddedDtcCode returns the value that was added to the "dtc_code" field in this mutation.
func (m *EquipmentAlarmMutation) AddedDtcCode() (r int64, exists bool) {
	v := m.adddtc_code
	if v == nil {
		return
	}
	return *v, true
}

// ResetDtcCode resets all changes to the "dtc_code" field.
func (m *EquipmentAlarmMutation) ResetDtcCode() {
	m.dtc_code = nil
	m.adddtc_code = nil
}

// SetRemoteAddress sets the "remote_address" field.
func (m *EquipmentAlarmMutation) SetRemoteAddress(s string) {
	m.remote_address = &s
}

// RemoteAddress returns the value of the "remote_address" field in the mutation.
func (m *EquipmentAlarmMutation) RemoteAddress() (r string, exists bool) {
	v := m.remote_address
	if v == nil {
		return
	}
	return *v, true
}

// OldRemoteAddress returns the old "remote_address" field's value of the EquipmentAlarm entity.
// If the EquipmentAlarm object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EquipmentAlarmMutation) OldRemoteAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemoteAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemoteAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemoteAddress: %w", err)
	}
	return oldValue.RemoteAddress, nil
}

// ResetRemoteAddress resets all changes to the "remote_address" field.
func (m *EquipmentAlarmMutation) ResetRemoteAddress() {
	m.remote_address = nil
}

// SetTriggerTime sets the "trigger_time" field.
func (m *EquipmentAlarmMutation) SetTriggerTime(i int64) {
	m.trigger_time = &i
	m.addtrigger_time = nil
}

// TriggerTime returns the value of the "trigger_time" field in the mutation.
func (m *EquipmentAlarmMutation) TriggerTime() (r int64, exists bool) {
	v := m.trigger_time
	if v == nil {
		return
	}
	return *v, true
}

// OldTriggerTime returns the old "trigger_time" field's value of the EquipmentAlarm entity.
// If the EquipmentAlarm object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EquipmentAlarmMutation) OldTriggerTime(ctx context.Context) (v *int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTriggerTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTriggerTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTriggerTime: %w", err)
	}
	return oldValue.TriggerTime, nil
}

// AddTriggerTime adds i to the "trigger_time" field.
func (m *EquipmentAlarmMutation) AddTriggerTime(i int64) {
	if m.addtrigger_time != nil {
		*m.addtrigger_time += i
	} else {
		m.addtrigger_time = &i
	}
}

// AddedTriggerTime returns the value that was added to the "trigger_time" field in this mutation.
func (m *EquipmentAlarmMutation) AddedTriggerTime() (r int64, exists bool) {
	v := m.addtrigger_time
	if v == nil {
		return
	}
	return *v, true
}

// ClearTriggerTime clears the value of the "trigger_time" field.
func (m *EquipmentAlarmMutation) ClearTriggerTime() {
	m.trigger_time = nil
	m.addtrigger_time = nil
	m.clearedFields[equipmentalarm.FieldTriggerTime] = struct{}{}
}

// TriggerTimeCleared returns if the "trigger_time" field was cleared in this mutation.
func (m *EquipmentAlarmMutation) TriggerTimeCleared() bool {
	_, ok := m.clearedFields[equipmentalarm.FieldTriggerTime]
	return ok
}

// ResetTriggerTime resets all changes to the "trigger_time" field.
func (m *EquipmentAlarmMutation) ResetTriggerTime() {
	m.trigger_time = nil
	m.addtrigger_time = nil
	delete(m.clearedFields, equipmentalarm.FieldTriggerTime)
}

// SetFinalTime sets the "final_time" field.
func (m *EquipmentAlarmMutation) SetFinalTime(i int64) {
	m.final_time = &i
	m.addfinal_time = nil
}

// FinalTime returns the value of the "final_time" field in the mutation.
func (m *EquipmentAlarmMutation) FinalTime() (r int64, exists bool) {
	v := m.final_time
	if v == nil {
		return
	}
	return *v, true
}

// OldFinalTime returns the old "final_time" field's value of the EquipmentAlarm entity.
// If the EquipmentAlarm object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EquipmentAlarmMutation) OldFinalTime(ctx context.Context) (v *int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFinalTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFinalTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFinalTime: %w", err)
	}
	return oldValue.FinalTime, nil
}

// AddFinalTime adds i to the "final_time" field.
func (m *EquipmentAlarmMutation) AddFinalTime(i int64) {
	if m.addfinal_time != nil {
		*m.addfinal_time += i
	} else {
		m.addfinal_time = &i
	}
}

// AddedFinalTime returns the value that was added to the "final_time" field in this mutation.
func (m *EquipmentAlarmMutation) AddedFinalTime() (r int64, exists bool) {
	v := m.addfinal_time
	if v == nil {
		return
	}
	return *v, true
}

// ClearFinalTime clears the value of the "final_time" field.
func (m *EquipmentAlarmMutation) ClearFinalTime() {
	m.final_time = nil
	m.addfinal_time = nil
	m.clearedFields[equipmentalarm.FieldFinalTime] = struct{}{}
}

// FinalTimeCleared returns if the "final_time" field was cleared in this mutation.
func (m *EquipmentAlarmMutation) FinalTimeCleared() bool {
	_, ok := m.clearedFields[equipmentalarm.FieldFinalTime]
	return ok
}

// ResetFinalTime resets all changes to the "final_time" field.
func (m *EquipmentAlarmMutation) ResetFinalTime() {
	m.final_time = nil
	m.addfinal_time = nil
	delete(m.clearedFields, equipmentalarm.FieldFinalTime)
}

// SetCount sets the "count" field.
func (m *EquipmentAlarmMutation) SetCount(i int) {
	m.count = &i
	m.addcount = nil
}

// Count returns the value of the "count" field in the mutation.
func (m *EquipmentAlarmMutation) Count() (r int, exists bool) {
	v := m.count
	if v == nil {
		return
	}
	return *v, true
}

// OldCount returns the old "count" field's value of the EquipmentAlarm entity.
// If the EquipmentAlarm object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EquipmentAlarmMutation) OldCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCount: %w", err)
	}
	return oldValue.Count, nil
}

// AddCount adds i to the "count" field.
func (m *EquipmentAlarmMutation) AddCount(i int) {
	if m.addcount != nil {
		*m.addcount += i
	} else {
		m.addcount = &i
	}
}

// AddedCount returns the value that was added to the "count" field in this mutation.
func (m *EquipmentAlarmMutation) AddedCount() (r int, exists bool) {
	v := m.addcount
	if v == nil {
		return
	}
	return *v, true
}

// ResetCount resets all changes to the "count" field.
func (m *EquipmentAlarmMutation) ResetCount() {
	m.count = nil
	m.addcount = nil
}

// SetEquipmentID sets the "equipment" edge to the Equipment entity by id.
func (m *EquipmentAlarmMutation) SetEquipmentID(id datasource.UUID) {
	m.equipment = &id
}

// ClearEquipment clears the "equipment" edge to the Equipment entity.
func (m *EquipmentAlarmMutation) ClearEquipment() {
	m.clearedequipment = true
}

// EquipmentCleared reports if the "equipment" edge to the Equipment entity was cleared.
func (m *EquipmentAlarmMutation) EquipmentCleared() bool {
	return m.clearedequipment
}

// EquipmentID returns the "equipment" edge ID in the mutation.
func (m *EquipmentAlarmMutation) EquipmentID() (id datasource.UUID, exists bool) {
	if m.equipment != nil {
		return *m.equipment, true
	}
	return
}

// EquipmentIDs returns the "equipment" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EquipmentID instead. It exists only for internal usage by the builders.
func (m *EquipmentAlarmMutation) EquipmentIDs() (ids []datasource.UUID) {
	if id := m.equipment; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEquipment resets all changes to the "equipment" edge.
func (m *EquipmentAlarmMutation) ResetEquipment() {
	m.equipment = nil
	m.clearedequipment = false
}

// Where appends a list predicates to the EquipmentAlarmMutation builder.
func (m *EquipmentAlarmMutation) Where(ps ...predicate.EquipmentAlarm) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *EquipmentAlarmMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (EquipmentAlarm).
func (m *EquipmentAlarmMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EquipmentAlarmMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.version != nil {
		fields = append(fields, equipmentalarm.FieldVersion)
	}
	if m.created_by != nil {
		fields = append(fields, equipmentalarm.FieldCreatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, equipmentalarm.FieldCreatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, equipmentalarm.FieldUpdatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, equipmentalarm.FieldUpdatedAt)
	}
	if m.dtc_code != nil {
		fields = append(fields, equipmentalarm.FieldDtcCode)
	}
	if m.remote_address != nil {
		fields = append(fields, equipmentalarm.FieldRemoteAddress)
	}
	if m.trigger_time != nil {
		fields = append(fields, equipmentalarm.FieldTriggerTime)
	}
	if m.final_time != nil {
		fields = append(fields, equipmentalarm.FieldFinalTime)
	}
	if m.count != nil {
		fields = append(fields, equipmentalarm.FieldCount)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EquipmentAlarmMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case equipmentalarm.FieldVersion:
		return m.Version()
	case equipmentalarm.FieldCreatedBy:
		return m.CreatedBy()
	case equipmentalarm.FieldCreatedAt:
		return m.CreatedAt()
	case equipmentalarm.FieldUpdatedBy:
		return m.UpdatedBy()
	case equipmentalarm.FieldUpdatedAt:
		return m.UpdatedAt()
	case equipmentalarm.FieldDtcCode:
		return m.DtcCode()
	case equipmentalarm.FieldRemoteAddress:
		return m.RemoteAddress()
	case equipmentalarm.FieldTriggerTime:
		return m.TriggerTime()
	case equipmentalarm.FieldFinalTime:
		return m.FinalTime()
	case equipmentalarm.FieldCount:
		return m.Count()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EquipmentAlarmMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case equipmentalarm.FieldVersion:
		return m.OldVersion(ctx)
	case equipmentalarm.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case equipmentalarm.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case equipmentalarm.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case equipmentalarm.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case equipmentalarm.FieldDtcCode:
		return m.OldDtcCode(ctx)
	case equipmentalarm.FieldRemoteAddress:
		return m.OldRemoteAddress(ctx)
	case equipmentalarm.FieldTriggerTime:
		return m.OldTriggerTime(ctx)
	case equipmentalarm.FieldFinalTime:
		return m.OldFinalTime(ctx)
	case equipmentalarm.FieldCount:
		return m.OldCount(ctx)
	}
	return nil, fmt.Errorf("unknown EquipmentAlarm field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EquipmentAlarmMutation) SetField(name string, value ent.Value) error {
	switch name {
	case equipmentalarm.FieldVersion:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case equipmentalarm.FieldCreatedBy:
		v, ok := value.(datasource.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case equipmentalarm.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case equipmentalarm.FieldUpdatedBy:
		v, ok := value.(datasource.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case equipmentalarm.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case equipmentalarm.FieldDtcCode:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDtcCode(v)
		return nil
	case equipmentalarm.FieldRemoteAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemoteAddress(v)
		return nil
	case equipmentalarm.FieldTriggerTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTriggerTime(v)
		return nil
	case equipmentalarm.FieldFinalTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFinalTime(v)
		return nil
	case equipmentalarm.FieldCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCount(v)
		return nil
	}
	return fmt.Errorf("unknown EquipmentAlarm field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EquipmentAlarmMutation) AddedFields() []string {
	var fields []string
	if m.addversion != nil {
		fields = append(fields, equipmentalarm.FieldVersion)
	}
	if m.addcreated_by != nil {
		fields = append(fields, equipmentalarm.FieldCreatedBy)
	}
	if m.addcreated_at != nil {
		fields = append(fields, equipmentalarm.FieldCreatedAt)
	}
	if m.addupdated_by != nil {
		fields = append(fields, equipmentalarm.FieldUpdatedBy)
	}
	if m.addupdated_at != nil {
		fields = append(fields, equipmentalarm.FieldUpdatedAt)
	}
	if m.adddtc_code != nil {
		fields = append(fields, equipmentalarm.FieldDtcCode)
	}
	if m.addtrigger_time != nil {
		fields = append(fields, equipmentalarm.FieldTriggerTime)
	}
	if m.addfinal_time != nil {
		fields = append(fields, equipmentalarm.FieldFinalTime)
	}
	if m.addcount != nil {
		fields = append(fields, equipmentalarm.FieldCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EquipmentAlarmMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case equipmentalarm.FieldVersion:
		return m.AddedVersion()
	case equipmentalarm.FieldCreatedBy:
		return m.AddedCreatedBy()
	case equipmentalarm.FieldCreatedAt:
		return m.AddedCreatedAt()
	case equipmentalarm.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case equipmentalarm.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case equipmentalarm.FieldDtcCode:
		return m.AddedDtcCode()
	case equipmentalarm.FieldTriggerTime:
		return m.AddedTriggerTime()
	case equipmentalarm.FieldFinalTime:
		return m.AddedFinalTime()
	case equipmentalarm.FieldCount:
		return m.AddedCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EquipmentAlarmMutation) AddField(name string, value ent.Value) error {
	switch name {
	case equipmentalarm.FieldVersion:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVersion(v)
		return nil
	case equipmentalarm.FieldCreatedBy:
		v, ok := value.(datasource.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case equipmentalarm.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case equipmentalarm.FieldUpdatedBy:
		v, ok := value.(datasource.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case equipmentalarm.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case equipmentalarm.FieldDtcCode:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDtcCode(v)
		return nil
	case equipmentalarm.FieldTriggerTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTriggerTime(v)
		return nil
	case equipmentalarm.FieldFinalTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFinalTime(v)
		return nil
	case equipmentalarm.FieldCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCount(v)
		return nil
	}
	return fmt.Errorf("unknown EquipmentAlarm numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EquipmentAlarmMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(equipmentalarm.FieldTriggerTime) {
		fields = append(fields, equipmentalarm.FieldTriggerTime)
	}
	if m.FieldCleared(equipmentalarm.FieldFinalTime) {
		fields = append(fields, equipmentalarm.FieldFinalTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EquipmentAlarmMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EquipmentAlarmMutation) ClearField(name string) error {
	switch name {
	case equipmentalarm.FieldTriggerTime:
		m.ClearTriggerTime()
		return nil
	case equipmentalarm.FieldFinalTime:
		m.ClearFinalTime()
		return nil
	}
	return fmt.Errorf("unknown EquipmentAlarm nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EquipmentAlarmMutation) ResetField(name string) error {
	switch name {
	case equipmentalarm.FieldVersion:
		m.ResetVersion()
		return nil
	case equipmentalarm.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case equipmentalarm.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case equipmentalarm.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case equipmentalarm.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case equipmentalarm.FieldDtcCode:
		m.ResetDtcCode()
		return nil
	case equipmentalarm.FieldRemoteAddress:
		m.ResetRemoteAddress()
		return nil
	case equipmentalarm.FieldTriggerTime:
		m.ResetTriggerTime()
		return nil
	case equipmentalarm.FieldFinalTime:
		m.ResetFinalTime()
		return nil
	case equipmentalarm.FieldCount:
		m.ResetCount()
		return nil
	}
	return fmt.Errorf("unknown EquipmentAlarm field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EquipmentAlarmMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.equipment != nil {
		edges = append(edges, equipmentalarm.EdgeEquipment)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EquipmentAlarmMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case equipmentalarm.EdgeEquipment:
		if id := m.equipment; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EquipmentAlarmMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EquipmentAlarmMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EquipmentAlarmMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedequipment {
		edges = append(edges, equipmentalarm.EdgeEquipment)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EquipmentAlarmMutation) EdgeCleared(name string) bool {
	switch name {
	case equipmentalarm.EdgeEquipment:
		return m.clearedequipment
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EquipmentAlarmMutation) ClearEdge(name string) error {
	switch name {
	case equipmentalarm.EdgeEquipment:
		m.ClearEquipment()
		return nil
	}
	return fmt.Errorf("unknown EquipmentAlarm unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EquipmentAlarmMutation) ResetEdge(name string) error {
	switch name {
	case equipmentalarm.EdgeEquipment:
		m.ResetEquipment()
		return nil
	}
	return fmt.Errorf("unknown EquipmentAlarm edge %s", name)
}

// EquipmentFirmwareEffectMutation represents an operation that mutates the EquipmentFirmwareEffect nodes in the graph.
type EquipmentFirmwareEffectMutation struct {
	config
	op               Op
	typ              string
	id               *datasource.UUID
	version          *int64
	addversion       *int64
	created_by       *datasource.UUID
	addcreated_by    *datasource.UUID
	created_at       *int64
	addcreated_at    *int64
	updated_by       *datasource.UUID
	addupdated_by    *datasource.UUID
	updated_at       *int64
	addupdated_at    *int64
	request_id       *int64
	addrequest_id    *int64
	state            *int
	addstate         *int
	clearedFields    map[string]struct{}
	equipment        *datasource.UUID
	clearedequipment bool
	firmware         *datasource.UUID
	clearedfirmware  bool
	done             bool
	oldValue         func(context.Context) (*EquipmentFirmwareEffect, error)
	predicates       []predicate.EquipmentFirmwareEffect
}

var _ ent.Mutation = (*EquipmentFirmwareEffectMutation)(nil)

// equipmentfirmwareeffectOption allows management of the mutation configuration using functional options.
type equipmentfirmwareeffectOption func(*EquipmentFirmwareEffectMutation)

// newEquipmentFirmwareEffectMutation creates new mutation for the EquipmentFirmwareEffect entity.
func newEquipmentFirmwareEffectMutation(c config, op Op, opts ...equipmentfirmwareeffectOption) *EquipmentFirmwareEffectMutation {
	m := &EquipmentFirmwareEffectMutation{
		config:        c,
		op:            op,
		typ:           TypeEquipmentFirmwareEffect,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEquipmentFirmwareEffectID sets the ID field of the mutation.
func withEquipmentFirmwareEffectID(id datasource.UUID) equipmentfirmwareeffectOption {
	return func(m *EquipmentFirmwareEffectMutation) {
		var (
			err   error
			once  sync.Once
			value *EquipmentFirmwareEffect
		)
		m.oldValue = func(ctx context.Context) (*EquipmentFirmwareEffect, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().EquipmentFirmwareEffect.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEquipmentFirmwareEffect sets the old EquipmentFirmwareEffect of the mutation.
func withEquipmentFirmwareEffect(node *EquipmentFirmwareEffect) equipmentfirmwareeffectOption {
	return func(m *EquipmentFirmwareEffectMutation) {
		m.oldValue = func(context.Context) (*EquipmentFirmwareEffect, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EquipmentFirmwareEffectMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EquipmentFirmwareEffectMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of EquipmentFirmwareEffect entities.
func (m *EquipmentFirmwareEffectMutation) SetID(id datasource.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EquipmentFirmwareEffectMutation) ID() (id datasource.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EquipmentFirmwareEffectMutation) IDs(ctx context.Context) ([]datasource.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []datasource.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().EquipmentFirmwareEffect.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetVersion sets the "version" field.
func (m *EquipmentFirmwareEffectMutation) SetVersion(i int64) {
	m.version = &i
	m.addversion = nil
}

// Version returns the value of the "version" field in the mutation.
func (m *EquipmentFirmwareEffectMutation) Version() (r int64, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the EquipmentFirmwareEffect entity.
// If the EquipmentFirmwareEffect object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EquipmentFirmwareEffectMutation) OldVersion(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// AddVersion adds i to the "version" field.
func (m *EquipmentFirmwareEffectMutation) AddVersion(i int64) {
	if m.addversion != nil {
		*m.addversion += i
	} else {
		m.addversion = &i
	}
}

// AddedVersion returns the value that was added to the "version" field in this mutation.
func (m *EquipmentFirmwareEffectMutation) AddedVersion() (r int64, exists bool) {
	v := m.addversion
	if v == nil {
		return
	}
	return *v, true
}

// ResetVersion resets all changes to the "version" field.
func (m *EquipmentFirmwareEffectMutation) ResetVersion() {
	m.version = nil
	m.addversion = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *EquipmentFirmwareEffectMutation) SetCreatedBy(d datasource.UUID) {
	m.created_by = &d
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *EquipmentFirmwareEffectMutation) CreatedBy() (r datasource.UUID, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the EquipmentFirmwareEffect entity.
// If the EquipmentFirmwareEffect object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EquipmentFirmwareEffectMutation) OldCreatedBy(ctx context.Context) (v datasource.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds d to the "created_by" field.
func (m *EquipmentFirmwareEffectMutation) AddCreatedBy(d datasource.UUID) {
	if m.addcreated_by != nil {
		*m.addcreated_by += d
	} else {
		m.addcreated_by = &d
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *EquipmentFirmwareEffectMutation) AddedCreatedBy() (r datasource.UUID, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *EquipmentFirmwareEffectMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *EquipmentFirmwareEffectMutation) SetCreatedAt(i int64) {
	m.created_at = &i
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EquipmentFirmwareEffectMutation) CreatedAt() (r int64, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the EquipmentFirmwareEffect entity.
// If the EquipmentFirmwareEffect object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EquipmentFirmwareEffectMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to the "created_at" field.
func (m *EquipmentFirmwareEffectMutation) AddCreatedAt(i int64) {
	if m.addcreated_at != nil {
		*m.addcreated_at += i
	} else {
		m.addcreated_at = &i
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *EquipmentFirmwareEffectMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EquipmentFirmwareEffectMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *EquipmentFirmwareEffectMutation) SetUpdatedBy(d datasource.UUID) {
	m.updated_by = &d
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *EquipmentFirmwareEffectMutation) UpdatedBy() (r datasource.UUID, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the EquipmentFirmwareEffect entity.
// If the EquipmentFirmwareEffect object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EquipmentFirmwareEffectMutation) OldUpdatedBy(ctx context.Context) (v datasource.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds d to the "updated_by" field.
func (m *EquipmentFirmwareEffectMutation) AddUpdatedBy(d datasource.UUID) {
	if m.addupdated_by != nil {
		*m.addupdated_by += d
	} else {
		m.addupdated_by = &d
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *EquipmentFirmwareEffectMutation) AddedUpdatedBy() (r datasource.UUID, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *EquipmentFirmwareEffectMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *EquipmentFirmwareEffectMutation) SetUpdatedAt(i int64) {
	m.updated_at = &i
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *EquipmentFirmwareEffectMutation) UpdatedAt() (r int64, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the EquipmentFirmwareEffect entity.
// If the EquipmentFirmwareEffect object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EquipmentFirmwareEffectMutation) OldUpdatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to the "updated_at" field.
func (m *EquipmentFirmwareEffectMutation) AddUpdatedAt(i int64) {
	if m.addupdated_at != nil {
		*m.addupdated_at += i
	} else {
		m.addupdated_at = &i
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *EquipmentFirmwareEffectMutation) AddedUpdatedAt() (r int64, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *EquipmentFirmwareEffectMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetRequestID sets the "request_id" field.
func (m *EquipmentFirmwareEffectMutation) SetRequestID(i int64) {
	m.request_id = &i
	m.addrequest_id = nil
}

// RequestID returns the value of the "request_id" field in the mutation.
func (m *EquipmentFirmwareEffectMutation) RequestID() (r int64, exists bool) {
	v := m.request_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRequestID returns the old "request_id" field's value of the EquipmentFirmwareEffect entity.
// If the EquipmentFirmwareEffect object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EquipmentFirmwareEffectMutation) OldRequestID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequestID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequestID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequestID: %w", err)
	}
	return oldValue.RequestID, nil
}

// AddRequestID adds i to the "request_id" field.
func (m *EquipmentFirmwareEffectMutation) AddRequestID(i int64) {
	if m.addrequest_id != nil {
		*m.addrequest_id += i
	} else {
		m.addrequest_id = &i
	}
}

// AddedRequestID returns the value that was added to the "request_id" field in this mutation.
func (m *EquipmentFirmwareEffectMutation) AddedRequestID() (r int64, exists bool) {
	v := m.addrequest_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetRequestID resets all changes to the "request_id" field.
func (m *EquipmentFirmwareEffectMutation) ResetRequestID() {
	m.request_id = nil
	m.addrequest_id = nil
}

// SetState sets the "state" field.
func (m *EquipmentFirmwareEffectMutation) SetState(i int) {
	m.state = &i
	m.addstate = nil
}

// State returns the value of the "state" field in the mutation.
func (m *EquipmentFirmwareEffectMutation) State() (r int, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the EquipmentFirmwareEffect entity.
// If the EquipmentFirmwareEffect object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EquipmentFirmwareEffectMutation) OldState(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// AddState adds i to the "state" field.
func (m *EquipmentFirmwareEffectMutation) AddState(i int) {
	if m.addstate != nil {
		*m.addstate += i
	} else {
		m.addstate = &i
	}
}

// AddedState returns the value that was added to the "state" field in this mutation.
func (m *EquipmentFirmwareEffectMutation) AddedState() (r int, exists bool) {
	v := m.addstate
	if v == nil {
		return
	}
	return *v, true
}

// ResetState resets all changes to the "state" field.
func (m *EquipmentFirmwareEffectMutation) ResetState() {
	m.state = nil
	m.addstate = nil
}

// SetEquipmentID sets the "equipment" edge to the Equipment entity by id.
func (m *EquipmentFirmwareEffectMutation) SetEquipmentID(id datasource.UUID) {
	m.equipment = &id
}

// ClearEquipment clears the "equipment" edge to the Equipment entity.
func (m *EquipmentFirmwareEffectMutation) ClearEquipment() {
	m.clearedequipment = true
}

// EquipmentCleared reports if the "equipment" edge to the Equipment entity was cleared.
func (m *EquipmentFirmwareEffectMutation) EquipmentCleared() bool {
	return m.clearedequipment
}

// EquipmentID returns the "equipment" edge ID in the mutation.
func (m *EquipmentFirmwareEffectMutation) EquipmentID() (id datasource.UUID, exists bool) {
	if m.equipment != nil {
		return *m.equipment, true
	}
	return
}

// EquipmentIDs returns the "equipment" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EquipmentID instead. It exists only for internal usage by the builders.
func (m *EquipmentFirmwareEffectMutation) EquipmentIDs() (ids []datasource.UUID) {
	if id := m.equipment; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEquipment resets all changes to the "equipment" edge.
func (m *EquipmentFirmwareEffectMutation) ResetEquipment() {
	m.equipment = nil
	m.clearedequipment = false
}

// SetFirmwareID sets the "firmware" edge to the Firmware entity by id.
func (m *EquipmentFirmwareEffectMutation) SetFirmwareID(id datasource.UUID) {
	m.firmware = &id
}

// ClearFirmware clears the "firmware" edge to the Firmware entity.
func (m *EquipmentFirmwareEffectMutation) ClearFirmware() {
	m.clearedfirmware = true
}

// FirmwareCleared reports if the "firmware" edge to the Firmware entity was cleared.
func (m *EquipmentFirmwareEffectMutation) FirmwareCleared() bool {
	return m.clearedfirmware
}

// FirmwareID returns the "firmware" edge ID in the mutation.
func (m *EquipmentFirmwareEffectMutation) FirmwareID() (id datasource.UUID, exists bool) {
	if m.firmware != nil {
		return *m.firmware, true
	}
	return
}

// FirmwareIDs returns the "firmware" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FirmwareID instead. It exists only for internal usage by the builders.
func (m *EquipmentFirmwareEffectMutation) FirmwareIDs() (ids []datasource.UUID) {
	if id := m.firmware; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFirmware resets all changes to the "firmware" edge.
func (m *EquipmentFirmwareEffectMutation) ResetFirmware() {
	m.firmware = nil
	m.clearedfirmware = false
}

// Where appends a list predicates to the EquipmentFirmwareEffectMutation builder.
func (m *EquipmentFirmwareEffectMutation) Where(ps ...predicate.EquipmentFirmwareEffect) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *EquipmentFirmwareEffectMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (EquipmentFirmwareEffect).
func (m *EquipmentFirmwareEffectMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EquipmentFirmwareEffectMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.version != nil {
		fields = append(fields, equipmentfirmwareeffect.FieldVersion)
	}
	if m.created_by != nil {
		fields = append(fields, equipmentfirmwareeffect.FieldCreatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, equipmentfirmwareeffect.FieldCreatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, equipmentfirmwareeffect.FieldUpdatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, equipmentfirmwareeffect.FieldUpdatedAt)
	}
	if m.request_id != nil {
		fields = append(fields, equipmentfirmwareeffect.FieldRequestID)
	}
	if m.state != nil {
		fields = append(fields, equipmentfirmwareeffect.FieldState)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EquipmentFirmwareEffectMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case equipmentfirmwareeffect.FieldVersion:
		return m.Version()
	case equipmentfirmwareeffect.FieldCreatedBy:
		return m.CreatedBy()
	case equipmentfirmwareeffect.FieldCreatedAt:
		return m.CreatedAt()
	case equipmentfirmwareeffect.FieldUpdatedBy:
		return m.UpdatedBy()
	case equipmentfirmwareeffect.FieldUpdatedAt:
		return m.UpdatedAt()
	case equipmentfirmwareeffect.FieldRequestID:
		return m.RequestID()
	case equipmentfirmwareeffect.FieldState:
		return m.State()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EquipmentFirmwareEffectMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case equipmentfirmwareeffect.FieldVersion:
		return m.OldVersion(ctx)
	case equipmentfirmwareeffect.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case equipmentfirmwareeffect.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case equipmentfirmwareeffect.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case equipmentfirmwareeffect.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case equipmentfirmwareeffect.FieldRequestID:
		return m.OldRequestID(ctx)
	case equipmentfirmwareeffect.FieldState:
		return m.OldState(ctx)
	}
	return nil, fmt.Errorf("unknown EquipmentFirmwareEffect field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EquipmentFirmwareEffectMutation) SetField(name string, value ent.Value) error {
	switch name {
	case equipmentfirmwareeffect.FieldVersion:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case equipmentfirmwareeffect.FieldCreatedBy:
		v, ok := value.(datasource.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case equipmentfirmwareeffect.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case equipmentfirmwareeffect.FieldUpdatedBy:
		v, ok := value.(datasource.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case equipmentfirmwareeffect.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case equipmentfirmwareeffect.FieldRequestID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequestID(v)
		return nil
	case equipmentfirmwareeffect.FieldState:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	}
	return fmt.Errorf("unknown EquipmentFirmwareEffect field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EquipmentFirmwareEffectMutation) AddedFields() []string {
	var fields []string
	if m.addversion != nil {
		fields = append(fields, equipmentfirmwareeffect.FieldVersion)
	}
	if m.addcreated_by != nil {
		fields = append(fields, equipmentfirmwareeffect.FieldCreatedBy)
	}
	if m.addcreated_at != nil {
		fields = append(fields, equipmentfirmwareeffect.FieldCreatedAt)
	}
	if m.addupdated_by != nil {
		fields = append(fields, equipmentfirmwareeffect.FieldUpdatedBy)
	}
	if m.addupdated_at != nil {
		fields = append(fields, equipmentfirmwareeffect.FieldUpdatedAt)
	}
	if m.addrequest_id != nil {
		fields = append(fields, equipmentfirmwareeffect.FieldRequestID)
	}
	if m.addstate != nil {
		fields = append(fields, equipmentfirmwareeffect.FieldState)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EquipmentFirmwareEffectMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case equipmentfirmwareeffect.FieldVersion:
		return m.AddedVersion()
	case equipmentfirmwareeffect.FieldCreatedBy:
		return m.AddedCreatedBy()
	case equipmentfirmwareeffect.FieldCreatedAt:
		return m.AddedCreatedAt()
	case equipmentfirmwareeffect.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case equipmentfirmwareeffect.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case equipmentfirmwareeffect.FieldRequestID:
		return m.AddedRequestID()
	case equipmentfirmwareeffect.FieldState:
		return m.AddedState()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EquipmentFirmwareEffectMutation) AddField(name string, value ent.Value) error {
	switch name {
	case equipmentfirmwareeffect.FieldVersion:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVersion(v)
		return nil
	case equipmentfirmwareeffect.FieldCreatedBy:
		v, ok := value.(datasource.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case equipmentfirmwareeffect.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case equipmentfirmwareeffect.FieldUpdatedBy:
		v, ok := value.(datasource.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case equipmentfirmwareeffect.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case equipmentfirmwareeffect.FieldRequestID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRequestID(v)
		return nil
	case equipmentfirmwareeffect.FieldState:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddState(v)
		return nil
	}
	return fmt.Errorf("unknown EquipmentFirmwareEffect numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EquipmentFirmwareEffectMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EquipmentFirmwareEffectMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EquipmentFirmwareEffectMutation) ClearField(name string) error {
	return fmt.Errorf("unknown EquipmentFirmwareEffect nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EquipmentFirmwareEffectMutation) ResetField(name string) error {
	switch name {
	case equipmentfirmwareeffect.FieldVersion:
		m.ResetVersion()
		return nil
	case equipmentfirmwareeffect.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case equipmentfirmwareeffect.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case equipmentfirmwareeffect.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case equipmentfirmwareeffect.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case equipmentfirmwareeffect.FieldRequestID:
		m.ResetRequestID()
		return nil
	case equipmentfirmwareeffect.FieldState:
		m.ResetState()
		return nil
	}
	return fmt.Errorf("unknown EquipmentFirmwareEffect field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EquipmentFirmwareEffectMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.equipment != nil {
		edges = append(edges, equipmentfirmwareeffect.EdgeEquipment)
	}
	if m.firmware != nil {
		edges = append(edges, equipmentfirmwareeffect.EdgeFirmware)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EquipmentFirmwareEffectMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case equipmentfirmwareeffect.EdgeEquipment:
		if id := m.equipment; id != nil {
			return []ent.Value{*id}
		}
	case equipmentfirmwareeffect.EdgeFirmware:
		if id := m.firmware; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EquipmentFirmwareEffectMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EquipmentFirmwareEffectMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EquipmentFirmwareEffectMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedequipment {
		edges = append(edges, equipmentfirmwareeffect.EdgeEquipment)
	}
	if m.clearedfirmware {
		edges = append(edges, equipmentfirmwareeffect.EdgeFirmware)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EquipmentFirmwareEffectMutation) EdgeCleared(name string) bool {
	switch name {
	case equipmentfirmwareeffect.EdgeEquipment:
		return m.clearedequipment
	case equipmentfirmwareeffect.EdgeFirmware:
		return m.clearedfirmware
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EquipmentFirmwareEffectMutation) ClearEdge(name string) error {
	switch name {
	case equipmentfirmwareeffect.EdgeEquipment:
		m.ClearEquipment()
		return nil
	case equipmentfirmwareeffect.EdgeFirmware:
		m.ClearFirmware()
		return nil
	}
	return fmt.Errorf("unknown EquipmentFirmwareEffect unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EquipmentFirmwareEffectMutation) ResetEdge(name string) error {
	switch name {
	case equipmentfirmwareeffect.EdgeEquipment:
		m.ResetEquipment()
		return nil
	case equipmentfirmwareeffect.EdgeFirmware:
		m.ResetFirmware()
		return nil
	}
	return fmt.Errorf("unknown EquipmentFirmwareEffect edge %s", name)
}

// EquipmentInfoMutation represents an operation that mutates the EquipmentInfo nodes in the graph.
type EquipmentInfoMutation struct {
	config
	op                   Op
	typ                  string
	id                   *datasource.UUID
	version              *int64
	addversion           *int64
	created_by           *datasource.UUID
	addcreated_by        *datasource.UUID
	created_at           *int64
	addcreated_at        *int64
	updated_by           *datasource.UUID
	addupdated_by        *datasource.UUID
	updated_at           *int64
	addupdated_at        *int64
	equipment_sn         *string
	model_id             *datasource.UUID
	addmodel_id          *datasource.UUID
	manufacturer_id      *datasource.UUID
	addmanufacturer_id   *datasource.UUID
	firmware_id          *datasource.UUID
	addfirmware_id       *datasource.UUID
	access_pod           *string
	state                *bool
	evse_number          *uint
	addevse_number       *int
	alarm_number         *uint
	addalarm_number      *int
	register_datetime    *int64
	addregister_datetime *int64
	remote_address       *string
	clearedFields        map[string]struct{}
	equipment            *datasource.UUID
	clearedequipment     bool
	done                 bool
	oldValue             func(context.Context) (*EquipmentInfo, error)
	predicates           []predicate.EquipmentInfo
}

var _ ent.Mutation = (*EquipmentInfoMutation)(nil)

// equipmentinfoOption allows management of the mutation configuration using functional options.
type equipmentinfoOption func(*EquipmentInfoMutation)

// newEquipmentInfoMutation creates new mutation for the EquipmentInfo entity.
func newEquipmentInfoMutation(c config, op Op, opts ...equipmentinfoOption) *EquipmentInfoMutation {
	m := &EquipmentInfoMutation{
		config:        c,
		op:            op,
		typ:           TypeEquipmentInfo,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEquipmentInfoID sets the ID field of the mutation.
func withEquipmentInfoID(id datasource.UUID) equipmentinfoOption {
	return func(m *EquipmentInfoMutation) {
		var (
			err   error
			once  sync.Once
			value *EquipmentInfo
		)
		m.oldValue = func(ctx context.Context) (*EquipmentInfo, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().EquipmentInfo.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEquipmentInfo sets the old EquipmentInfo of the mutation.
func withEquipmentInfo(node *EquipmentInfo) equipmentinfoOption {
	return func(m *EquipmentInfoMutation) {
		m.oldValue = func(context.Context) (*EquipmentInfo, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EquipmentInfoMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EquipmentInfoMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of EquipmentInfo entities.
func (m *EquipmentInfoMutation) SetID(id datasource.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EquipmentInfoMutation) ID() (id datasource.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EquipmentInfoMutation) IDs(ctx context.Context) ([]datasource.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []datasource.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().EquipmentInfo.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetVersion sets the "version" field.
func (m *EquipmentInfoMutation) SetVersion(i int64) {
	m.version = &i
	m.addversion = nil
}

// Version returns the value of the "version" field in the mutation.
func (m *EquipmentInfoMutation) Version() (r int64, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the EquipmentInfo entity.
// If the EquipmentInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EquipmentInfoMutation) OldVersion(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// AddVersion adds i to the "version" field.
func (m *EquipmentInfoMutation) AddVersion(i int64) {
	if m.addversion != nil {
		*m.addversion += i
	} else {
		m.addversion = &i
	}
}

// AddedVersion returns the value that was added to the "version" field in this mutation.
func (m *EquipmentInfoMutation) AddedVersion() (r int64, exists bool) {
	v := m.addversion
	if v == nil {
		return
	}
	return *v, true
}

// ResetVersion resets all changes to the "version" field.
func (m *EquipmentInfoMutation) ResetVersion() {
	m.version = nil
	m.addversion = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *EquipmentInfoMutation) SetCreatedBy(d datasource.UUID) {
	m.created_by = &d
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *EquipmentInfoMutation) CreatedBy() (r datasource.UUID, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the EquipmentInfo entity.
// If the EquipmentInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EquipmentInfoMutation) OldCreatedBy(ctx context.Context) (v datasource.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds d to the "created_by" field.
func (m *EquipmentInfoMutation) AddCreatedBy(d datasource.UUID) {
	if m.addcreated_by != nil {
		*m.addcreated_by += d
	} else {
		m.addcreated_by = &d
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *EquipmentInfoMutation) AddedCreatedBy() (r datasource.UUID, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *EquipmentInfoMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *EquipmentInfoMutation) SetCreatedAt(i int64) {
	m.created_at = &i
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EquipmentInfoMutation) CreatedAt() (r int64, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the EquipmentInfo entity.
// If the EquipmentInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EquipmentInfoMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to the "created_at" field.
func (m *EquipmentInfoMutation) AddCreatedAt(i int64) {
	if m.addcreated_at != nil {
		*m.addcreated_at += i
	} else {
		m.addcreated_at = &i
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *EquipmentInfoMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EquipmentInfoMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *EquipmentInfoMutation) SetUpdatedBy(d datasource.UUID) {
	m.updated_by = &d
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *EquipmentInfoMutation) UpdatedBy() (r datasource.UUID, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the EquipmentInfo entity.
// If the EquipmentInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EquipmentInfoMutation) OldUpdatedBy(ctx context.Context) (v datasource.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds d to the "updated_by" field.
func (m *EquipmentInfoMutation) AddUpdatedBy(d datasource.UUID) {
	if m.addupdated_by != nil {
		*m.addupdated_by += d
	} else {
		m.addupdated_by = &d
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *EquipmentInfoMutation) AddedUpdatedBy() (r datasource.UUID, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *EquipmentInfoMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *EquipmentInfoMutation) SetUpdatedAt(i int64) {
	m.updated_at = &i
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *EquipmentInfoMutation) UpdatedAt() (r int64, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the EquipmentInfo entity.
// If the EquipmentInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EquipmentInfoMutation) OldUpdatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to the "updated_at" field.
func (m *EquipmentInfoMutation) AddUpdatedAt(i int64) {
	if m.addupdated_at != nil {
		*m.addupdated_at += i
	} else {
		m.addupdated_at = &i
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *EquipmentInfoMutation) AddedUpdatedAt() (r int64, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *EquipmentInfoMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetEquipmentSn sets the "equipment_sn" field.
func (m *EquipmentInfoMutation) SetEquipmentSn(s string) {
	m.equipment_sn = &s
}

// EquipmentSn returns the value of the "equipment_sn" field in the mutation.
func (m *EquipmentInfoMutation) EquipmentSn() (r string, exists bool) {
	v := m.equipment_sn
	if v == nil {
		return
	}
	return *v, true
}

// OldEquipmentSn returns the old "equipment_sn" field's value of the EquipmentInfo entity.
// If the EquipmentInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EquipmentInfoMutation) OldEquipmentSn(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEquipmentSn is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEquipmentSn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEquipmentSn: %w", err)
	}
	return oldValue.EquipmentSn, nil
}

// ResetEquipmentSn resets all changes to the "equipment_sn" field.
func (m *EquipmentInfoMutation) ResetEquipmentSn() {
	m.equipment_sn = nil
}

// SetModelID sets the "model_id" field.
func (m *EquipmentInfoMutation) SetModelID(d datasource.UUID) {
	m.model_id = &d
	m.addmodel_id = nil
}

// ModelID returns the value of the "model_id" field in the mutation.
func (m *EquipmentInfoMutation) ModelID() (r datasource.UUID, exists bool) {
	v := m.model_id
	if v == nil {
		return
	}
	return *v, true
}

// OldModelID returns the old "model_id" field's value of the EquipmentInfo entity.
// If the EquipmentInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EquipmentInfoMutation) OldModelID(ctx context.Context) (v datasource.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModelID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModelID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModelID: %w", err)
	}
	return oldValue.ModelID, nil
}

// AddModelID adds d to the "model_id" field.
func (m *EquipmentInfoMutation) AddModelID(d datasource.UUID) {
	if m.addmodel_id != nil {
		*m.addmodel_id += d
	} else {
		m.addmodel_id = &d
	}
}

// AddedModelID returns the value that was added to the "model_id" field in this mutation.
func (m *EquipmentInfoMutation) AddedModelID() (r datasource.UUID, exists bool) {
	v := m.addmodel_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetModelID resets all changes to the "model_id" field.
func (m *EquipmentInfoMutation) ResetModelID() {
	m.model_id = nil
	m.addmodel_id = nil
}

// SetManufacturerID sets the "manufacturer_id" field.
func (m *EquipmentInfoMutation) SetManufacturerID(d datasource.UUID) {
	m.manufacturer_id = &d
	m.addmanufacturer_id = nil
}

// ManufacturerID returns the value of the "manufacturer_id" field in the mutation.
func (m *EquipmentInfoMutation) ManufacturerID() (r datasource.UUID, exists bool) {
	v := m.manufacturer_id
	if v == nil {
		return
	}
	return *v, true
}

// OldManufacturerID returns the old "manufacturer_id" field's value of the EquipmentInfo entity.
// If the EquipmentInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EquipmentInfoMutation) OldManufacturerID(ctx context.Context) (v datasource.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldManufacturerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldManufacturerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldManufacturerID: %w", err)
	}
	return oldValue.ManufacturerID, nil
}

// AddManufacturerID adds d to the "manufacturer_id" field.
func (m *EquipmentInfoMutation) AddManufacturerID(d datasource.UUID) {
	if m.addmanufacturer_id != nil {
		*m.addmanufacturer_id += d
	} else {
		m.addmanufacturer_id = &d
	}
}

// AddedManufacturerID returns the value that was added to the "manufacturer_id" field in this mutation.
func (m *EquipmentInfoMutation) AddedManufacturerID() (r datasource.UUID, exists bool) {
	v := m.addmanufacturer_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetManufacturerID resets all changes to the "manufacturer_id" field.
func (m *EquipmentInfoMutation) ResetManufacturerID() {
	m.manufacturer_id = nil
	m.addmanufacturer_id = nil
}

// SetFirmwareID sets the "firmware_id" field.
func (m *EquipmentInfoMutation) SetFirmwareID(d datasource.UUID) {
	m.firmware_id = &d
	m.addfirmware_id = nil
}

// FirmwareID returns the value of the "firmware_id" field in the mutation.
func (m *EquipmentInfoMutation) FirmwareID() (r datasource.UUID, exists bool) {
	v := m.firmware_id
	if v == nil {
		return
	}
	return *v, true
}

// OldFirmwareID returns the old "firmware_id" field's value of the EquipmentInfo entity.
// If the EquipmentInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EquipmentInfoMutation) OldFirmwareID(ctx context.Context) (v datasource.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFirmwareID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFirmwareID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirmwareID: %w", err)
	}
	return oldValue.FirmwareID, nil
}

// AddFirmwareID adds d to the "firmware_id" field.
func (m *EquipmentInfoMutation) AddFirmwareID(d datasource.UUID) {
	if m.addfirmware_id != nil {
		*m.addfirmware_id += d
	} else {
		m.addfirmware_id = &d
	}
}

// AddedFirmwareID returns the value that was added to the "firmware_id" field in this mutation.
func (m *EquipmentInfoMutation) AddedFirmwareID() (r datasource.UUID, exists bool) {
	v := m.addfirmware_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetFirmwareID resets all changes to the "firmware_id" field.
func (m *EquipmentInfoMutation) ResetFirmwareID() {
	m.firmware_id = nil
	m.addfirmware_id = nil
}

// SetAccessPod sets the "access_pod" field.
func (m *EquipmentInfoMutation) SetAccessPod(s string) {
	m.access_pod = &s
}

// AccessPod returns the value of the "access_pod" field in the mutation.
func (m *EquipmentInfoMutation) AccessPod() (r string, exists bool) {
	v := m.access_pod
	if v == nil {
		return
	}
	return *v, true
}

// OldAccessPod returns the old "access_pod" field's value of the EquipmentInfo entity.
// If the EquipmentInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EquipmentInfoMutation) OldAccessPod(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccessPod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccessPod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccessPod: %w", err)
	}
	return oldValue.AccessPod, nil
}

// ResetAccessPod resets all changes to the "access_pod" field.
func (m *EquipmentInfoMutation) ResetAccessPod() {
	m.access_pod = nil
}

// SetState sets the "state" field.
func (m *EquipmentInfoMutation) SetState(b bool) {
	m.state = &b
}

// State returns the value of the "state" field in the mutation.
func (m *EquipmentInfoMutation) State() (r bool, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the EquipmentInfo entity.
// If the EquipmentInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EquipmentInfoMutation) OldState(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// ResetState resets all changes to the "state" field.
func (m *EquipmentInfoMutation) ResetState() {
	m.state = nil
}

// SetEvseNumber sets the "evse_number" field.
func (m *EquipmentInfoMutation) SetEvseNumber(u uint) {
	m.evse_number = &u
	m.addevse_number = nil
}

// EvseNumber returns the value of the "evse_number" field in the mutation.
func (m *EquipmentInfoMutation) EvseNumber() (r uint, exists bool) {
	v := m.evse_number
	if v == nil {
		return
	}
	return *v, true
}

// OldEvseNumber returns the old "evse_number" field's value of the EquipmentInfo entity.
// If the EquipmentInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EquipmentInfoMutation) OldEvseNumber(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEvseNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEvseNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEvseNumber: %w", err)
	}
	return oldValue.EvseNumber, nil
}

// AddEvseNumber adds u to the "evse_number" field.
func (m *EquipmentInfoMutation) AddEvseNumber(u int) {
	if m.addevse_number != nil {
		*m.addevse_number += u
	} else {
		m.addevse_number = &u
	}
}

// AddedEvseNumber returns the value that was added to the "evse_number" field in this mutation.
func (m *EquipmentInfoMutation) AddedEvseNumber() (r int, exists bool) {
	v := m.addevse_number
	if v == nil {
		return
	}
	return *v, true
}

// ResetEvseNumber resets all changes to the "evse_number" field.
func (m *EquipmentInfoMutation) ResetEvseNumber() {
	m.evse_number = nil
	m.addevse_number = nil
}

// SetAlarmNumber sets the "alarm_number" field.
func (m *EquipmentInfoMutation) SetAlarmNumber(u uint) {
	m.alarm_number = &u
	m.addalarm_number = nil
}

// AlarmNumber returns the value of the "alarm_number" field in the mutation.
func (m *EquipmentInfoMutation) AlarmNumber() (r uint, exists bool) {
	v := m.alarm_number
	if v == nil {
		return
	}
	return *v, true
}

// OldAlarmNumber returns the old "alarm_number" field's value of the EquipmentInfo entity.
// If the EquipmentInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EquipmentInfoMutation) OldAlarmNumber(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAlarmNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAlarmNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAlarmNumber: %w", err)
	}
	return oldValue.AlarmNumber, nil
}

// AddAlarmNumber adds u to the "alarm_number" field.
func (m *EquipmentInfoMutation) AddAlarmNumber(u int) {
	if m.addalarm_number != nil {
		*m.addalarm_number += u
	} else {
		m.addalarm_number = &u
	}
}

// AddedAlarmNumber returns the value that was added to the "alarm_number" field in this mutation.
func (m *EquipmentInfoMutation) AddedAlarmNumber() (r int, exists bool) {
	v := m.addalarm_number
	if v == nil {
		return
	}
	return *v, true
}

// ResetAlarmNumber resets all changes to the "alarm_number" field.
func (m *EquipmentInfoMutation) ResetAlarmNumber() {
	m.alarm_number = nil
	m.addalarm_number = nil
}

// SetRegisterDatetime sets the "register_datetime" field.
func (m *EquipmentInfoMutation) SetRegisterDatetime(i int64) {
	m.register_datetime = &i
	m.addregister_datetime = nil
}

// RegisterDatetime returns the value of the "register_datetime" field in the mutation.
func (m *EquipmentInfoMutation) RegisterDatetime() (r int64, exists bool) {
	v := m.register_datetime
	if v == nil {
		return
	}
	return *v, true
}

// OldRegisterDatetime returns the old "register_datetime" field's value of the EquipmentInfo entity.
// If the EquipmentInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EquipmentInfoMutation) OldRegisterDatetime(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRegisterDatetime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRegisterDatetime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRegisterDatetime: %w", err)
	}
	return oldValue.RegisterDatetime, nil
}

// AddRegisterDatetime adds i to the "register_datetime" field.
func (m *EquipmentInfoMutation) AddRegisterDatetime(i int64) {
	if m.addregister_datetime != nil {
		*m.addregister_datetime += i
	} else {
		m.addregister_datetime = &i
	}
}

// AddedRegisterDatetime returns the value that was added to the "register_datetime" field in this mutation.
func (m *EquipmentInfoMutation) AddedRegisterDatetime() (r int64, exists bool) {
	v := m.addregister_datetime
	if v == nil {
		return
	}
	return *v, true
}

// ResetRegisterDatetime resets all changes to the "register_datetime" field.
func (m *EquipmentInfoMutation) ResetRegisterDatetime() {
	m.register_datetime = nil
	m.addregister_datetime = nil
}

// SetRemoteAddress sets the "remote_address" field.
func (m *EquipmentInfoMutation) SetRemoteAddress(s string) {
	m.remote_address = &s
}

// RemoteAddress returns the value of the "remote_address" field in the mutation.
func (m *EquipmentInfoMutation) RemoteAddress() (r string, exists bool) {
	v := m.remote_address
	if v == nil {
		return
	}
	return *v, true
}

// OldRemoteAddress returns the old "remote_address" field's value of the EquipmentInfo entity.
// If the EquipmentInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EquipmentInfoMutation) OldRemoteAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemoteAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemoteAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemoteAddress: %w", err)
	}
	return oldValue.RemoteAddress, nil
}

// ResetRemoteAddress resets all changes to the "remote_address" field.
func (m *EquipmentInfoMutation) ResetRemoteAddress() {
	m.remote_address = nil
}

// SetEquipmentID sets the "equipment" edge to the Equipment entity by id.
func (m *EquipmentInfoMutation) SetEquipmentID(id datasource.UUID) {
	m.equipment = &id
}

// ClearEquipment clears the "equipment" edge to the Equipment entity.
func (m *EquipmentInfoMutation) ClearEquipment() {
	m.clearedequipment = true
}

// EquipmentCleared reports if the "equipment" edge to the Equipment entity was cleared.
func (m *EquipmentInfoMutation) EquipmentCleared() bool {
	return m.clearedequipment
}

// EquipmentID returns the "equipment" edge ID in the mutation.
func (m *EquipmentInfoMutation) EquipmentID() (id datasource.UUID, exists bool) {
	if m.equipment != nil {
		return *m.equipment, true
	}
	return
}

// EquipmentIDs returns the "equipment" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EquipmentID instead. It exists only for internal usage by the builders.
func (m *EquipmentInfoMutation) EquipmentIDs() (ids []datasource.UUID) {
	if id := m.equipment; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEquipment resets all changes to the "equipment" edge.
func (m *EquipmentInfoMutation) ResetEquipment() {
	m.equipment = nil
	m.clearedequipment = false
}

// Where appends a list predicates to the EquipmentInfoMutation builder.
func (m *EquipmentInfoMutation) Where(ps ...predicate.EquipmentInfo) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *EquipmentInfoMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (EquipmentInfo).
func (m *EquipmentInfoMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EquipmentInfoMutation) Fields() []string {
	fields := make([]string, 0, 15)
	if m.version != nil {
		fields = append(fields, equipmentinfo.FieldVersion)
	}
	if m.created_by != nil {
		fields = append(fields, equipmentinfo.FieldCreatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, equipmentinfo.FieldCreatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, equipmentinfo.FieldUpdatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, equipmentinfo.FieldUpdatedAt)
	}
	if m.equipment_sn != nil {
		fields = append(fields, equipmentinfo.FieldEquipmentSn)
	}
	if m.model_id != nil {
		fields = append(fields, equipmentinfo.FieldModelID)
	}
	if m.manufacturer_id != nil {
		fields = append(fields, equipmentinfo.FieldManufacturerID)
	}
	if m.firmware_id != nil {
		fields = append(fields, equipmentinfo.FieldFirmwareID)
	}
	if m.access_pod != nil {
		fields = append(fields, equipmentinfo.FieldAccessPod)
	}
	if m.state != nil {
		fields = append(fields, equipmentinfo.FieldState)
	}
	if m.evse_number != nil {
		fields = append(fields, equipmentinfo.FieldEvseNumber)
	}
	if m.alarm_number != nil {
		fields = append(fields, equipmentinfo.FieldAlarmNumber)
	}
	if m.register_datetime != nil {
		fields = append(fields, equipmentinfo.FieldRegisterDatetime)
	}
	if m.remote_address != nil {
		fields = append(fields, equipmentinfo.FieldRemoteAddress)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EquipmentInfoMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case equipmentinfo.FieldVersion:
		return m.Version()
	case equipmentinfo.FieldCreatedBy:
		return m.CreatedBy()
	case equipmentinfo.FieldCreatedAt:
		return m.CreatedAt()
	case equipmentinfo.FieldUpdatedBy:
		return m.UpdatedBy()
	case equipmentinfo.FieldUpdatedAt:
		return m.UpdatedAt()
	case equipmentinfo.FieldEquipmentSn:
		return m.EquipmentSn()
	case equipmentinfo.FieldModelID:
		return m.ModelID()
	case equipmentinfo.FieldManufacturerID:
		return m.ManufacturerID()
	case equipmentinfo.FieldFirmwareID:
		return m.FirmwareID()
	case equipmentinfo.FieldAccessPod:
		return m.AccessPod()
	case equipmentinfo.FieldState:
		return m.State()
	case equipmentinfo.FieldEvseNumber:
		return m.EvseNumber()
	case equipmentinfo.FieldAlarmNumber:
		return m.AlarmNumber()
	case equipmentinfo.FieldRegisterDatetime:
		return m.RegisterDatetime()
	case equipmentinfo.FieldRemoteAddress:
		return m.RemoteAddress()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EquipmentInfoMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case equipmentinfo.FieldVersion:
		return m.OldVersion(ctx)
	case equipmentinfo.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case equipmentinfo.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case equipmentinfo.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case equipmentinfo.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case equipmentinfo.FieldEquipmentSn:
		return m.OldEquipmentSn(ctx)
	case equipmentinfo.FieldModelID:
		return m.OldModelID(ctx)
	case equipmentinfo.FieldManufacturerID:
		return m.OldManufacturerID(ctx)
	case equipmentinfo.FieldFirmwareID:
		return m.OldFirmwareID(ctx)
	case equipmentinfo.FieldAccessPod:
		return m.OldAccessPod(ctx)
	case equipmentinfo.FieldState:
		return m.OldState(ctx)
	case equipmentinfo.FieldEvseNumber:
		return m.OldEvseNumber(ctx)
	case equipmentinfo.FieldAlarmNumber:
		return m.OldAlarmNumber(ctx)
	case equipmentinfo.FieldRegisterDatetime:
		return m.OldRegisterDatetime(ctx)
	case equipmentinfo.FieldRemoteAddress:
		return m.OldRemoteAddress(ctx)
	}
	return nil, fmt.Errorf("unknown EquipmentInfo field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EquipmentInfoMutation) SetField(name string, value ent.Value) error {
	switch name {
	case equipmentinfo.FieldVersion:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case equipmentinfo.FieldCreatedBy:
		v, ok := value.(datasource.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case equipmentinfo.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case equipmentinfo.FieldUpdatedBy:
		v, ok := value.(datasource.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case equipmentinfo.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case equipmentinfo.FieldEquipmentSn:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEquipmentSn(v)
		return nil
	case equipmentinfo.FieldModelID:
		v, ok := value.(datasource.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModelID(v)
		return nil
	case equipmentinfo.FieldManufacturerID:
		v, ok := value.(datasource.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetManufacturerID(v)
		return nil
	case equipmentinfo.FieldFirmwareID:
		v, ok := value.(datasource.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirmwareID(v)
		return nil
	case equipmentinfo.FieldAccessPod:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccessPod(v)
		return nil
	case equipmentinfo.FieldState:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	case equipmentinfo.FieldEvseNumber:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEvseNumber(v)
		return nil
	case equipmentinfo.FieldAlarmNumber:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAlarmNumber(v)
		return nil
	case equipmentinfo.FieldRegisterDatetime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRegisterDatetime(v)
		return nil
	case equipmentinfo.FieldRemoteAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemoteAddress(v)
		return nil
	}
	return fmt.Errorf("unknown EquipmentInfo field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EquipmentInfoMutation) AddedFields() []string {
	var fields []string
	if m.addversion != nil {
		fields = append(fields, equipmentinfo.FieldVersion)
	}
	if m.addcreated_by != nil {
		fields = append(fields, equipmentinfo.FieldCreatedBy)
	}
	if m.addcreated_at != nil {
		fields = append(fields, equipmentinfo.FieldCreatedAt)
	}
	if m.addupdated_by != nil {
		fields = append(fields, equipmentinfo.FieldUpdatedBy)
	}
	if m.addupdated_at != nil {
		fields = append(fields, equipmentinfo.FieldUpdatedAt)
	}
	if m.addmodel_id != nil {
		fields = append(fields, equipmentinfo.FieldModelID)
	}
	if m.addmanufacturer_id != nil {
		fields = append(fields, equipmentinfo.FieldManufacturerID)
	}
	if m.addfirmware_id != nil {
		fields = append(fields, equipmentinfo.FieldFirmwareID)
	}
	if m.addevse_number != nil {
		fields = append(fields, equipmentinfo.FieldEvseNumber)
	}
	if m.addalarm_number != nil {
		fields = append(fields, equipmentinfo.FieldAlarmNumber)
	}
	if m.addregister_datetime != nil {
		fields = append(fields, equipmentinfo.FieldRegisterDatetime)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EquipmentInfoMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case equipmentinfo.FieldVersion:
		return m.AddedVersion()
	case equipmentinfo.FieldCreatedBy:
		return m.AddedCreatedBy()
	case equipmentinfo.FieldCreatedAt:
		return m.AddedCreatedAt()
	case equipmentinfo.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case equipmentinfo.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case equipmentinfo.FieldModelID:
		return m.AddedModelID()
	case equipmentinfo.FieldManufacturerID:
		return m.AddedManufacturerID()
	case equipmentinfo.FieldFirmwareID:
		return m.AddedFirmwareID()
	case equipmentinfo.FieldEvseNumber:
		return m.AddedEvseNumber()
	case equipmentinfo.FieldAlarmNumber:
		return m.AddedAlarmNumber()
	case equipmentinfo.FieldRegisterDatetime:
		return m.AddedRegisterDatetime()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EquipmentInfoMutation) AddField(name string, value ent.Value) error {
	switch name {
	case equipmentinfo.FieldVersion:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVersion(v)
		return nil
	case equipmentinfo.FieldCreatedBy:
		v, ok := value.(datasource.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case equipmentinfo.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case equipmentinfo.FieldUpdatedBy:
		v, ok := value.(datasource.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case equipmentinfo.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case equipmentinfo.FieldModelID:
		v, ok := value.(datasource.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddModelID(v)
		return nil
	case equipmentinfo.FieldManufacturerID:
		v, ok := value.(datasource.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddManufacturerID(v)
		return nil
	case equipmentinfo.FieldFirmwareID:
		v, ok := value.(datasource.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFirmwareID(v)
		return nil
	case equipmentinfo.FieldEvseNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEvseNumber(v)
		return nil
	case equipmentinfo.FieldAlarmNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAlarmNumber(v)
		return nil
	case equipmentinfo.FieldRegisterDatetime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRegisterDatetime(v)
		return nil
	}
	return fmt.Errorf("unknown EquipmentInfo numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EquipmentInfoMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EquipmentInfoMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EquipmentInfoMutation) ClearField(name string) error {
	return fmt.Errorf("unknown EquipmentInfo nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EquipmentInfoMutation) ResetField(name string) error {
	switch name {
	case equipmentinfo.FieldVersion:
		m.ResetVersion()
		return nil
	case equipmentinfo.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case equipmentinfo.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case equipmentinfo.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case equipmentinfo.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case equipmentinfo.FieldEquipmentSn:
		m.ResetEquipmentSn()
		return nil
	case equipmentinfo.FieldModelID:
		m.ResetModelID()
		return nil
	case equipmentinfo.FieldManufacturerID:
		m.ResetManufacturerID()
		return nil
	case equipmentinfo.FieldFirmwareID:
		m.ResetFirmwareID()
		return nil
	case equipmentinfo.FieldAccessPod:
		m.ResetAccessPod()
		return nil
	case equipmentinfo.FieldState:
		m.ResetState()
		return nil
	case equipmentinfo.FieldEvseNumber:
		m.ResetEvseNumber()
		return nil
	case equipmentinfo.FieldAlarmNumber:
		m.ResetAlarmNumber()
		return nil
	case equipmentinfo.FieldRegisterDatetime:
		m.ResetRegisterDatetime()
		return nil
	case equipmentinfo.FieldRemoteAddress:
		m.ResetRemoteAddress()
		return nil
	}
	return fmt.Errorf("unknown EquipmentInfo field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EquipmentInfoMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.equipment != nil {
		edges = append(edges, equipmentinfo.EdgeEquipment)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EquipmentInfoMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case equipmentinfo.EdgeEquipment:
		if id := m.equipment; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EquipmentInfoMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EquipmentInfoMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EquipmentInfoMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedequipment {
		edges = append(edges, equipmentinfo.EdgeEquipment)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EquipmentInfoMutation) EdgeCleared(name string) bool {
	switch name {
	case equipmentinfo.EdgeEquipment:
		return m.clearedequipment
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EquipmentInfoMutation) ClearEdge(name string) error {
	switch name {
	case equipmentinfo.EdgeEquipment:
		m.ClearEquipment()
		return nil
	}
	return fmt.Errorf("unknown EquipmentInfo unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EquipmentInfoMutation) ResetEdge(name string) error {
	switch name {
	case equipmentinfo.EdgeEquipment:
		m.ResetEquipment()
		return nil
	}
	return fmt.Errorf("unknown EquipmentInfo edge %s", name)
}

// EquipmentIotMutation represents an operation that mutates the EquipmentIot nodes in the graph.
type EquipmentIotMutation struct {
	config
	op               Op
	typ              string
	id               *datasource.UUID
	version          *int64
	addversion       *int64
	created_by       *datasource.UUID
	addcreated_by    *datasource.UUID
	created_at       *int64
	addcreated_at    *int64
	updated_by       *datasource.UUID
	addupdated_by    *datasource.UUID
	updated_at       *int64
	addupdated_at    *int64
	iccid            *string
	imei             *string
	remote_address   *string
	clearedFields    map[string]struct{}
	equipment        *datasource.UUID
	clearedequipment bool
	done             bool
	oldValue         func(context.Context) (*EquipmentIot, error)
	predicates       []predicate.EquipmentIot
}

var _ ent.Mutation = (*EquipmentIotMutation)(nil)

// equipmentiotOption allows management of the mutation configuration using functional options.
type equipmentiotOption func(*EquipmentIotMutation)

// newEquipmentIotMutation creates new mutation for the EquipmentIot entity.
func newEquipmentIotMutation(c config, op Op, opts ...equipmentiotOption) *EquipmentIotMutation {
	m := &EquipmentIotMutation{
		config:        c,
		op:            op,
		typ:           TypeEquipmentIot,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEquipmentIotID sets the ID field of the mutation.
func withEquipmentIotID(id datasource.UUID) equipmentiotOption {
	return func(m *EquipmentIotMutation) {
		var (
			err   error
			once  sync.Once
			value *EquipmentIot
		)
		m.oldValue = func(ctx context.Context) (*EquipmentIot, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().EquipmentIot.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEquipmentIot sets the old EquipmentIot of the mutation.
func withEquipmentIot(node *EquipmentIot) equipmentiotOption {
	return func(m *EquipmentIotMutation) {
		m.oldValue = func(context.Context) (*EquipmentIot, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EquipmentIotMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EquipmentIotMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of EquipmentIot entities.
func (m *EquipmentIotMutation) SetID(id datasource.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EquipmentIotMutation) ID() (id datasource.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EquipmentIotMutation) IDs(ctx context.Context) ([]datasource.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []datasource.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().EquipmentIot.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetVersion sets the "version" field.
func (m *EquipmentIotMutation) SetVersion(i int64) {
	m.version = &i
	m.addversion = nil
}

// Version returns the value of the "version" field in the mutation.
func (m *EquipmentIotMutation) Version() (r int64, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the EquipmentIot entity.
// If the EquipmentIot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EquipmentIotMutation) OldVersion(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// AddVersion adds i to the "version" field.
func (m *EquipmentIotMutation) AddVersion(i int64) {
	if m.addversion != nil {
		*m.addversion += i
	} else {
		m.addversion = &i
	}
}

// AddedVersion returns the value that was added to the "version" field in this mutation.
func (m *EquipmentIotMutation) AddedVersion() (r int64, exists bool) {
	v := m.addversion
	if v == nil {
		return
	}
	return *v, true
}

// ResetVersion resets all changes to the "version" field.
func (m *EquipmentIotMutation) ResetVersion() {
	m.version = nil
	m.addversion = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *EquipmentIotMutation) SetCreatedBy(d datasource.UUID) {
	m.created_by = &d
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *EquipmentIotMutation) CreatedBy() (r datasource.UUID, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the EquipmentIot entity.
// If the EquipmentIot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EquipmentIotMutation) OldCreatedBy(ctx context.Context) (v datasource.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds d to the "created_by" field.
func (m *EquipmentIotMutation) AddCreatedBy(d datasource.UUID) {
	if m.addcreated_by != nil {
		*m.addcreated_by += d
	} else {
		m.addcreated_by = &d
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *EquipmentIotMutation) AddedCreatedBy() (r datasource.UUID, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *EquipmentIotMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *EquipmentIotMutation) SetCreatedAt(i int64) {
	m.created_at = &i
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EquipmentIotMutation) CreatedAt() (r int64, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the EquipmentIot entity.
// If the EquipmentIot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EquipmentIotMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to the "created_at" field.
func (m *EquipmentIotMutation) AddCreatedAt(i int64) {
	if m.addcreated_at != nil {
		*m.addcreated_at += i
	} else {
		m.addcreated_at = &i
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *EquipmentIotMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EquipmentIotMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *EquipmentIotMutation) SetUpdatedBy(d datasource.UUID) {
	m.updated_by = &d
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *EquipmentIotMutation) UpdatedBy() (r datasource.UUID, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the EquipmentIot entity.
// If the EquipmentIot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EquipmentIotMutation) OldUpdatedBy(ctx context.Context) (v datasource.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds d to the "updated_by" field.
func (m *EquipmentIotMutation) AddUpdatedBy(d datasource.UUID) {
	if m.addupdated_by != nil {
		*m.addupdated_by += d
	} else {
		m.addupdated_by = &d
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *EquipmentIotMutation) AddedUpdatedBy() (r datasource.UUID, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *EquipmentIotMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *EquipmentIotMutation) SetUpdatedAt(i int64) {
	m.updated_at = &i
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *EquipmentIotMutation) UpdatedAt() (r int64, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the EquipmentIot entity.
// If the EquipmentIot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EquipmentIotMutation) OldUpdatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to the "updated_at" field.
func (m *EquipmentIotMutation) AddUpdatedAt(i int64) {
	if m.addupdated_at != nil {
		*m.addupdated_at += i
	} else {
		m.addupdated_at = &i
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *EquipmentIotMutation) AddedUpdatedAt() (r int64, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *EquipmentIotMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetIccid sets the "iccid" field.
func (m *EquipmentIotMutation) SetIccid(s string) {
	m.iccid = &s
}

// Iccid returns the value of the "iccid" field in the mutation.
func (m *EquipmentIotMutation) Iccid() (r string, exists bool) {
	v := m.iccid
	if v == nil {
		return
	}
	return *v, true
}

// OldIccid returns the old "iccid" field's value of the EquipmentIot entity.
// If the EquipmentIot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EquipmentIotMutation) OldIccid(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIccid is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIccid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIccid: %w", err)
	}
	return oldValue.Iccid, nil
}

// ClearIccid clears the value of the "iccid" field.
func (m *EquipmentIotMutation) ClearIccid() {
	m.iccid = nil
	m.clearedFields[equipmentiot.FieldIccid] = struct{}{}
}

// IccidCleared returns if the "iccid" field was cleared in this mutation.
func (m *EquipmentIotMutation) IccidCleared() bool {
	_, ok := m.clearedFields[equipmentiot.FieldIccid]
	return ok
}

// ResetIccid resets all changes to the "iccid" field.
func (m *EquipmentIotMutation) ResetIccid() {
	m.iccid = nil
	delete(m.clearedFields, equipmentiot.FieldIccid)
}

// SetImei sets the "imei" field.
func (m *EquipmentIotMutation) SetImei(s string) {
	m.imei = &s
}

// Imei returns the value of the "imei" field in the mutation.
func (m *EquipmentIotMutation) Imei() (r string, exists bool) {
	v := m.imei
	if v == nil {
		return
	}
	return *v, true
}

// OldImei returns the old "imei" field's value of the EquipmentIot entity.
// If the EquipmentIot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EquipmentIotMutation) OldImei(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImei is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImei requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImei: %w", err)
	}
	return oldValue.Imei, nil
}

// ClearImei clears the value of the "imei" field.
func (m *EquipmentIotMutation) ClearImei() {
	m.imei = nil
	m.clearedFields[equipmentiot.FieldImei] = struct{}{}
}

// ImeiCleared returns if the "imei" field was cleared in this mutation.
func (m *EquipmentIotMutation) ImeiCleared() bool {
	_, ok := m.clearedFields[equipmentiot.FieldImei]
	return ok
}

// ResetImei resets all changes to the "imei" field.
func (m *EquipmentIotMutation) ResetImei() {
	m.imei = nil
	delete(m.clearedFields, equipmentiot.FieldImei)
}

// SetRemoteAddress sets the "remote_address" field.
func (m *EquipmentIotMutation) SetRemoteAddress(s string) {
	m.remote_address = &s
}

// RemoteAddress returns the value of the "remote_address" field in the mutation.
func (m *EquipmentIotMutation) RemoteAddress() (r string, exists bool) {
	v := m.remote_address
	if v == nil {
		return
	}
	return *v, true
}

// OldRemoteAddress returns the old "remote_address" field's value of the EquipmentIot entity.
// If the EquipmentIot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EquipmentIotMutation) OldRemoteAddress(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemoteAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemoteAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemoteAddress: %w", err)
	}
	return oldValue.RemoteAddress, nil
}

// ClearRemoteAddress clears the value of the "remote_address" field.
func (m *EquipmentIotMutation) ClearRemoteAddress() {
	m.remote_address = nil
	m.clearedFields[equipmentiot.FieldRemoteAddress] = struct{}{}
}

// RemoteAddressCleared returns if the "remote_address" field was cleared in this mutation.
func (m *EquipmentIotMutation) RemoteAddressCleared() bool {
	_, ok := m.clearedFields[equipmentiot.FieldRemoteAddress]
	return ok
}

// ResetRemoteAddress resets all changes to the "remote_address" field.
func (m *EquipmentIotMutation) ResetRemoteAddress() {
	m.remote_address = nil
	delete(m.clearedFields, equipmentiot.FieldRemoteAddress)
}

// SetEquipmentID sets the "equipment" edge to the Equipment entity by id.
func (m *EquipmentIotMutation) SetEquipmentID(id datasource.UUID) {
	m.equipment = &id
}

// ClearEquipment clears the "equipment" edge to the Equipment entity.
func (m *EquipmentIotMutation) ClearEquipment() {
	m.clearedequipment = true
}

// EquipmentCleared reports if the "equipment" edge to the Equipment entity was cleared.
func (m *EquipmentIotMutation) EquipmentCleared() bool {
	return m.clearedequipment
}

// EquipmentID returns the "equipment" edge ID in the mutation.
func (m *EquipmentIotMutation) EquipmentID() (id datasource.UUID, exists bool) {
	if m.equipment != nil {
		return *m.equipment, true
	}
	return
}

// EquipmentIDs returns the "equipment" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EquipmentID instead. It exists only for internal usage by the builders.
func (m *EquipmentIotMutation) EquipmentIDs() (ids []datasource.UUID) {
	if id := m.equipment; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEquipment resets all changes to the "equipment" edge.
func (m *EquipmentIotMutation) ResetEquipment() {
	m.equipment = nil
	m.clearedequipment = false
}

// Where appends a list predicates to the EquipmentIotMutation builder.
func (m *EquipmentIotMutation) Where(ps ...predicate.EquipmentIot) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *EquipmentIotMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (EquipmentIot).
func (m *EquipmentIotMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EquipmentIotMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.version != nil {
		fields = append(fields, equipmentiot.FieldVersion)
	}
	if m.created_by != nil {
		fields = append(fields, equipmentiot.FieldCreatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, equipmentiot.FieldCreatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, equipmentiot.FieldUpdatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, equipmentiot.FieldUpdatedAt)
	}
	if m.iccid != nil {
		fields = append(fields, equipmentiot.FieldIccid)
	}
	if m.imei != nil {
		fields = append(fields, equipmentiot.FieldImei)
	}
	if m.remote_address != nil {
		fields = append(fields, equipmentiot.FieldRemoteAddress)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EquipmentIotMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case equipmentiot.FieldVersion:
		return m.Version()
	case equipmentiot.FieldCreatedBy:
		return m.CreatedBy()
	case equipmentiot.FieldCreatedAt:
		return m.CreatedAt()
	case equipmentiot.FieldUpdatedBy:
		return m.UpdatedBy()
	case equipmentiot.FieldUpdatedAt:
		return m.UpdatedAt()
	case equipmentiot.FieldIccid:
		return m.Iccid()
	case equipmentiot.FieldImei:
		return m.Imei()
	case equipmentiot.FieldRemoteAddress:
		return m.RemoteAddress()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EquipmentIotMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case equipmentiot.FieldVersion:
		return m.OldVersion(ctx)
	case equipmentiot.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case equipmentiot.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case equipmentiot.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case equipmentiot.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case equipmentiot.FieldIccid:
		return m.OldIccid(ctx)
	case equipmentiot.FieldImei:
		return m.OldImei(ctx)
	case equipmentiot.FieldRemoteAddress:
		return m.OldRemoteAddress(ctx)
	}
	return nil, fmt.Errorf("unknown EquipmentIot field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EquipmentIotMutation) SetField(name string, value ent.Value) error {
	switch name {
	case equipmentiot.FieldVersion:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case equipmentiot.FieldCreatedBy:
		v, ok := value.(datasource.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case equipmentiot.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case equipmentiot.FieldUpdatedBy:
		v, ok := value.(datasource.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case equipmentiot.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case equipmentiot.FieldIccid:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIccid(v)
		return nil
	case equipmentiot.FieldImei:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImei(v)
		return nil
	case equipmentiot.FieldRemoteAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemoteAddress(v)
		return nil
	}
	return fmt.Errorf("unknown EquipmentIot field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EquipmentIotMutation) AddedFields() []string {
	var fields []string
	if m.addversion != nil {
		fields = append(fields, equipmentiot.FieldVersion)
	}
	if m.addcreated_by != nil {
		fields = append(fields, equipmentiot.FieldCreatedBy)
	}
	if m.addcreated_at != nil {
		fields = append(fields, equipmentiot.FieldCreatedAt)
	}
	if m.addupdated_by != nil {
		fields = append(fields, equipmentiot.FieldUpdatedBy)
	}
	if m.addupdated_at != nil {
		fields = append(fields, equipmentiot.FieldUpdatedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EquipmentIotMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case equipmentiot.FieldVersion:
		return m.AddedVersion()
	case equipmentiot.FieldCreatedBy:
		return m.AddedCreatedBy()
	case equipmentiot.FieldCreatedAt:
		return m.AddedCreatedAt()
	case equipmentiot.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case equipmentiot.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EquipmentIotMutation) AddField(name string, value ent.Value) error {
	switch name {
	case equipmentiot.FieldVersion:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVersion(v)
		return nil
	case equipmentiot.FieldCreatedBy:
		v, ok := value.(datasource.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case equipmentiot.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case equipmentiot.FieldUpdatedBy:
		v, ok := value.(datasource.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case equipmentiot.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown EquipmentIot numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EquipmentIotMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(equipmentiot.FieldIccid) {
		fields = append(fields, equipmentiot.FieldIccid)
	}
	if m.FieldCleared(equipmentiot.FieldImei) {
		fields = append(fields, equipmentiot.FieldImei)
	}
	if m.FieldCleared(equipmentiot.FieldRemoteAddress) {
		fields = append(fields, equipmentiot.FieldRemoteAddress)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EquipmentIotMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EquipmentIotMutation) ClearField(name string) error {
	switch name {
	case equipmentiot.FieldIccid:
		m.ClearIccid()
		return nil
	case equipmentiot.FieldImei:
		m.ClearImei()
		return nil
	case equipmentiot.FieldRemoteAddress:
		m.ClearRemoteAddress()
		return nil
	}
	return fmt.Errorf("unknown EquipmentIot nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EquipmentIotMutation) ResetField(name string) error {
	switch name {
	case equipmentiot.FieldVersion:
		m.ResetVersion()
		return nil
	case equipmentiot.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case equipmentiot.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case equipmentiot.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case equipmentiot.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case equipmentiot.FieldIccid:
		m.ResetIccid()
		return nil
	case equipmentiot.FieldImei:
		m.ResetImei()
		return nil
	case equipmentiot.FieldRemoteAddress:
		m.ResetRemoteAddress()
		return nil
	}
	return fmt.Errorf("unknown EquipmentIot field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EquipmentIotMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.equipment != nil {
		edges = append(edges, equipmentiot.EdgeEquipment)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EquipmentIotMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case equipmentiot.EdgeEquipment:
		if id := m.equipment; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EquipmentIotMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EquipmentIotMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EquipmentIotMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedequipment {
		edges = append(edges, equipmentiot.EdgeEquipment)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EquipmentIotMutation) EdgeCleared(name string) bool {
	switch name {
	case equipmentiot.EdgeEquipment:
		return m.clearedequipment
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EquipmentIotMutation) ClearEdge(name string) error {
	switch name {
	case equipmentiot.EdgeEquipment:
		m.ClearEquipment()
		return nil
	}
	return fmt.Errorf("unknown EquipmentIot unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EquipmentIotMutation) ResetEdge(name string) error {
	switch name {
	case equipmentiot.EdgeEquipment:
		m.ResetEquipment()
		return nil
	}
	return fmt.Errorf("unknown EquipmentIot edge %s", name)
}

// EquipmentLogMutation represents an operation that mutates the EquipmentLog nodes in the graph.
type EquipmentLogMutation struct {
	config
	op               Op
	typ              string
	id               *datasource.UUID
	version          *int64
	addversion       *int64
	created_by       *datasource.UUID
	addcreated_by    *datasource.UUID
	created_at       *int64
	addcreated_at    *int64
	updated_by       *datasource.UUID
	addupdated_by    *datasource.UUID
	updated_at       *int64
	addupdated_at    *int64
	requestId        *int64
	addrequestId     *int64
	state            *int
	addstate         *int
	data_link        *datasource.UUID
	adddata_link     *datasource.UUID
	clearedFields    map[string]struct{}
	equipment        *datasource.UUID
	clearedequipment bool
	done             bool
	oldValue         func(context.Context) (*EquipmentLog, error)
	predicates       []predicate.EquipmentLog
}

var _ ent.Mutation = (*EquipmentLogMutation)(nil)

// equipmentlogOption allows management of the mutation configuration using functional options.
type equipmentlogOption func(*EquipmentLogMutation)

// newEquipmentLogMutation creates new mutation for the EquipmentLog entity.
func newEquipmentLogMutation(c config, op Op, opts ...equipmentlogOption) *EquipmentLogMutation {
	m := &EquipmentLogMutation{
		config:        c,
		op:            op,
		typ:           TypeEquipmentLog,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEquipmentLogID sets the ID field of the mutation.
func withEquipmentLogID(id datasource.UUID) equipmentlogOption {
	return func(m *EquipmentLogMutation) {
		var (
			err   error
			once  sync.Once
			value *EquipmentLog
		)
		m.oldValue = func(ctx context.Context) (*EquipmentLog, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().EquipmentLog.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEquipmentLog sets the old EquipmentLog of the mutation.
func withEquipmentLog(node *EquipmentLog) equipmentlogOption {
	return func(m *EquipmentLogMutation) {
		m.oldValue = func(context.Context) (*EquipmentLog, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EquipmentLogMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EquipmentLogMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of EquipmentLog entities.
func (m *EquipmentLogMutation) SetID(id datasource.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EquipmentLogMutation) ID() (id datasource.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EquipmentLogMutation) IDs(ctx context.Context) ([]datasource.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []datasource.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().EquipmentLog.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetVersion sets the "version" field.
func (m *EquipmentLogMutation) SetVersion(i int64) {
	m.version = &i
	m.addversion = nil
}

// Version returns the value of the "version" field in the mutation.
func (m *EquipmentLogMutation) Version() (r int64, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the EquipmentLog entity.
// If the EquipmentLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EquipmentLogMutation) OldVersion(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// AddVersion adds i to the "version" field.
func (m *EquipmentLogMutation) AddVersion(i int64) {
	if m.addversion != nil {
		*m.addversion += i
	} else {
		m.addversion = &i
	}
}

// AddedVersion returns the value that was added to the "version" field in this mutation.
func (m *EquipmentLogMutation) AddedVersion() (r int64, exists bool) {
	v := m.addversion
	if v == nil {
		return
	}
	return *v, true
}

// ResetVersion resets all changes to the "version" field.
func (m *EquipmentLogMutation) ResetVersion() {
	m.version = nil
	m.addversion = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *EquipmentLogMutation) SetCreatedBy(d datasource.UUID) {
	m.created_by = &d
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *EquipmentLogMutation) CreatedBy() (r datasource.UUID, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the EquipmentLog entity.
// If the EquipmentLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EquipmentLogMutation) OldCreatedBy(ctx context.Context) (v datasource.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds d to the "created_by" field.
func (m *EquipmentLogMutation) AddCreatedBy(d datasource.UUID) {
	if m.addcreated_by != nil {
		*m.addcreated_by += d
	} else {
		m.addcreated_by = &d
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *EquipmentLogMutation) AddedCreatedBy() (r datasource.UUID, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *EquipmentLogMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *EquipmentLogMutation) SetCreatedAt(i int64) {
	m.created_at = &i
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EquipmentLogMutation) CreatedAt() (r int64, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the EquipmentLog entity.
// If the EquipmentLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EquipmentLogMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to the "created_at" field.
func (m *EquipmentLogMutation) AddCreatedAt(i int64) {
	if m.addcreated_at != nil {
		*m.addcreated_at += i
	} else {
		m.addcreated_at = &i
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *EquipmentLogMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EquipmentLogMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *EquipmentLogMutation) SetUpdatedBy(d datasource.UUID) {
	m.updated_by = &d
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *EquipmentLogMutation) UpdatedBy() (r datasource.UUID, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the EquipmentLog entity.
// If the EquipmentLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EquipmentLogMutation) OldUpdatedBy(ctx context.Context) (v datasource.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds d to the "updated_by" field.
func (m *EquipmentLogMutation) AddUpdatedBy(d datasource.UUID) {
	if m.addupdated_by != nil {
		*m.addupdated_by += d
	} else {
		m.addupdated_by = &d
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *EquipmentLogMutation) AddedUpdatedBy() (r datasource.UUID, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *EquipmentLogMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *EquipmentLogMutation) SetUpdatedAt(i int64) {
	m.updated_at = &i
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *EquipmentLogMutation) UpdatedAt() (r int64, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the EquipmentLog entity.
// If the EquipmentLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EquipmentLogMutation) OldUpdatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to the "updated_at" field.
func (m *EquipmentLogMutation) AddUpdatedAt(i int64) {
	if m.addupdated_at != nil {
		*m.addupdated_at += i
	} else {
		m.addupdated_at = &i
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *EquipmentLogMutation) AddedUpdatedAt() (r int64, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *EquipmentLogMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetRequestId sets the "requestId" field.
func (m *EquipmentLogMutation) SetRequestId(i int64) {
	m.requestId = &i
	m.addrequestId = nil
}

// RequestId returns the value of the "requestId" field in the mutation.
func (m *EquipmentLogMutation) RequestId() (r int64, exists bool) {
	v := m.requestId
	if v == nil {
		return
	}
	return *v, true
}

// OldRequestId returns the old "requestId" field's value of the EquipmentLog entity.
// If the EquipmentLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EquipmentLogMutation) OldRequestId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequestId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequestId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequestId: %w", err)
	}
	return oldValue.RequestId, nil
}

// AddRequestId adds i to the "requestId" field.
func (m *EquipmentLogMutation) AddRequestId(i int64) {
	if m.addrequestId != nil {
		*m.addrequestId += i
	} else {
		m.addrequestId = &i
	}
}

// AddedRequestId returns the value that was added to the "requestId" field in this mutation.
func (m *EquipmentLogMutation) AddedRequestId() (r int64, exists bool) {
	v := m.addrequestId
	if v == nil {
		return
	}
	return *v, true
}

// ResetRequestId resets all changes to the "requestId" field.
func (m *EquipmentLogMutation) ResetRequestId() {
	m.requestId = nil
	m.addrequestId = nil
}

// SetState sets the "state" field.
func (m *EquipmentLogMutation) SetState(i int) {
	m.state = &i
	m.addstate = nil
}

// State returns the value of the "state" field in the mutation.
func (m *EquipmentLogMutation) State() (r int, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the EquipmentLog entity.
// If the EquipmentLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EquipmentLogMutation) OldState(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// AddState adds i to the "state" field.
func (m *EquipmentLogMutation) AddState(i int) {
	if m.addstate != nil {
		*m.addstate += i
	} else {
		m.addstate = &i
	}
}

// AddedState returns the value that was added to the "state" field in this mutation.
func (m *EquipmentLogMutation) AddedState() (r int, exists bool) {
	v := m.addstate
	if v == nil {
		return
	}
	return *v, true
}

// ResetState resets all changes to the "state" field.
func (m *EquipmentLogMutation) ResetState() {
	m.state = nil
	m.addstate = nil
}

// SetDataLink sets the "data_link" field.
func (m *EquipmentLogMutation) SetDataLink(d datasource.UUID) {
	m.data_link = &d
	m.adddata_link = nil
}

// DataLink returns the value of the "data_link" field in the mutation.
func (m *EquipmentLogMutation) DataLink() (r datasource.UUID, exists bool) {
	v := m.data_link
	if v == nil {
		return
	}
	return *v, true
}

// OldDataLink returns the old "data_link" field's value of the EquipmentLog entity.
// If the EquipmentLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EquipmentLogMutation) OldDataLink(ctx context.Context) (v datasource.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDataLink is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDataLink requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDataLink: %w", err)
	}
	return oldValue.DataLink, nil
}

// AddDataLink adds d to the "data_link" field.
func (m *EquipmentLogMutation) AddDataLink(d datasource.UUID) {
	if m.adddata_link != nil {
		*m.adddata_link += d
	} else {
		m.adddata_link = &d
	}
}

// AddedDataLink returns the value that was added to the "data_link" field in this mutation.
func (m *EquipmentLogMutation) AddedDataLink() (r datasource.UUID, exists bool) {
	v := m.adddata_link
	if v == nil {
		return
	}
	return *v, true
}

// ResetDataLink resets all changes to the "data_link" field.
func (m *EquipmentLogMutation) ResetDataLink() {
	m.data_link = nil
	m.adddata_link = nil
}

// SetEquipmentID sets the "equipment" edge to the Equipment entity by id.
func (m *EquipmentLogMutation) SetEquipmentID(id datasource.UUID) {
	m.equipment = &id
}

// ClearEquipment clears the "equipment" edge to the Equipment entity.
func (m *EquipmentLogMutation) ClearEquipment() {
	m.clearedequipment = true
}

// EquipmentCleared reports if the "equipment" edge to the Equipment entity was cleared.
func (m *EquipmentLogMutation) EquipmentCleared() bool {
	return m.clearedequipment
}

// EquipmentID returns the "equipment" edge ID in the mutation.
func (m *EquipmentLogMutation) EquipmentID() (id datasource.UUID, exists bool) {
	if m.equipment != nil {
		return *m.equipment, true
	}
	return
}

// EquipmentIDs returns the "equipment" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EquipmentID instead. It exists only for internal usage by the builders.
func (m *EquipmentLogMutation) EquipmentIDs() (ids []datasource.UUID) {
	if id := m.equipment; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEquipment resets all changes to the "equipment" edge.
func (m *EquipmentLogMutation) ResetEquipment() {
	m.equipment = nil
	m.clearedequipment = false
}

// Where appends a list predicates to the EquipmentLogMutation builder.
func (m *EquipmentLogMutation) Where(ps ...predicate.EquipmentLog) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *EquipmentLogMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (EquipmentLog).
func (m *EquipmentLogMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EquipmentLogMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.version != nil {
		fields = append(fields, equipmentlog.FieldVersion)
	}
	if m.created_by != nil {
		fields = append(fields, equipmentlog.FieldCreatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, equipmentlog.FieldCreatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, equipmentlog.FieldUpdatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, equipmentlog.FieldUpdatedAt)
	}
	if m.requestId != nil {
		fields = append(fields, equipmentlog.FieldRequestId)
	}
	if m.state != nil {
		fields = append(fields, equipmentlog.FieldState)
	}
	if m.data_link != nil {
		fields = append(fields, equipmentlog.FieldDataLink)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EquipmentLogMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case equipmentlog.FieldVersion:
		return m.Version()
	case equipmentlog.FieldCreatedBy:
		return m.CreatedBy()
	case equipmentlog.FieldCreatedAt:
		return m.CreatedAt()
	case equipmentlog.FieldUpdatedBy:
		return m.UpdatedBy()
	case equipmentlog.FieldUpdatedAt:
		return m.UpdatedAt()
	case equipmentlog.FieldRequestId:
		return m.RequestId()
	case equipmentlog.FieldState:
		return m.State()
	case equipmentlog.FieldDataLink:
		return m.DataLink()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EquipmentLogMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case equipmentlog.FieldVersion:
		return m.OldVersion(ctx)
	case equipmentlog.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case equipmentlog.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case equipmentlog.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case equipmentlog.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case equipmentlog.FieldRequestId:
		return m.OldRequestId(ctx)
	case equipmentlog.FieldState:
		return m.OldState(ctx)
	case equipmentlog.FieldDataLink:
		return m.OldDataLink(ctx)
	}
	return nil, fmt.Errorf("unknown EquipmentLog field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EquipmentLogMutation) SetField(name string, value ent.Value) error {
	switch name {
	case equipmentlog.FieldVersion:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case equipmentlog.FieldCreatedBy:
		v, ok := value.(datasource.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case equipmentlog.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case equipmentlog.FieldUpdatedBy:
		v, ok := value.(datasource.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case equipmentlog.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case equipmentlog.FieldRequestId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequestId(v)
		return nil
	case equipmentlog.FieldState:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	case equipmentlog.FieldDataLink:
		v, ok := value.(datasource.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDataLink(v)
		return nil
	}
	return fmt.Errorf("unknown EquipmentLog field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EquipmentLogMutation) AddedFields() []string {
	var fields []string
	if m.addversion != nil {
		fields = append(fields, equipmentlog.FieldVersion)
	}
	if m.addcreated_by != nil {
		fields = append(fields, equipmentlog.FieldCreatedBy)
	}
	if m.addcreated_at != nil {
		fields = append(fields, equipmentlog.FieldCreatedAt)
	}
	if m.addupdated_by != nil {
		fields = append(fields, equipmentlog.FieldUpdatedBy)
	}
	if m.addupdated_at != nil {
		fields = append(fields, equipmentlog.FieldUpdatedAt)
	}
	if m.addrequestId != nil {
		fields = append(fields, equipmentlog.FieldRequestId)
	}
	if m.addstate != nil {
		fields = append(fields, equipmentlog.FieldState)
	}
	if m.adddata_link != nil {
		fields = append(fields, equipmentlog.FieldDataLink)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EquipmentLogMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case equipmentlog.FieldVersion:
		return m.AddedVersion()
	case equipmentlog.FieldCreatedBy:
		return m.AddedCreatedBy()
	case equipmentlog.FieldCreatedAt:
		return m.AddedCreatedAt()
	case equipmentlog.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case equipmentlog.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case equipmentlog.FieldRequestId:
		return m.AddedRequestId()
	case equipmentlog.FieldState:
		return m.AddedState()
	case equipmentlog.FieldDataLink:
		return m.AddedDataLink()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EquipmentLogMutation) AddField(name string, value ent.Value) error {
	switch name {
	case equipmentlog.FieldVersion:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVersion(v)
		return nil
	case equipmentlog.FieldCreatedBy:
		v, ok := value.(datasource.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case equipmentlog.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case equipmentlog.FieldUpdatedBy:
		v, ok := value.(datasource.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case equipmentlog.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case equipmentlog.FieldRequestId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRequestId(v)
		return nil
	case equipmentlog.FieldState:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddState(v)
		return nil
	case equipmentlog.FieldDataLink:
		v, ok := value.(datasource.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDataLink(v)
		return nil
	}
	return fmt.Errorf("unknown EquipmentLog numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EquipmentLogMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EquipmentLogMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EquipmentLogMutation) ClearField(name string) error {
	return fmt.Errorf("unknown EquipmentLog nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EquipmentLogMutation) ResetField(name string) error {
	switch name {
	case equipmentlog.FieldVersion:
		m.ResetVersion()
		return nil
	case equipmentlog.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case equipmentlog.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case equipmentlog.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case equipmentlog.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case equipmentlog.FieldRequestId:
		m.ResetRequestId()
		return nil
	case equipmentlog.FieldState:
		m.ResetState()
		return nil
	case equipmentlog.FieldDataLink:
		m.ResetDataLink()
		return nil
	}
	return fmt.Errorf("unknown EquipmentLog field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EquipmentLogMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.equipment != nil {
		edges = append(edges, equipmentlog.EdgeEquipment)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EquipmentLogMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case equipmentlog.EdgeEquipment:
		if id := m.equipment; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EquipmentLogMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EquipmentLogMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EquipmentLogMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedequipment {
		edges = append(edges, equipmentlog.EdgeEquipment)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EquipmentLogMutation) EdgeCleared(name string) bool {
	switch name {
	case equipmentlog.EdgeEquipment:
		return m.clearedequipment
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EquipmentLogMutation) ClearEdge(name string) error {
	switch name {
	case equipmentlog.EdgeEquipment:
		m.ClearEquipment()
		return nil
	}
	return fmt.Errorf("unknown EquipmentLog unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EquipmentLogMutation) ResetEdge(name string) error {
	switch name {
	case equipmentlog.EdgeEquipment:
		m.ResetEquipment()
		return nil
	}
	return fmt.Errorf("unknown EquipmentLog edge %s", name)
}

// EvseMutation represents an operation that mutates the Evse nodes in the graph.
type EvseMutation struct {
	config
	op                  Op
	typ                 string
	id                  *datasource.UUID
	version             *int64
	addversion          *int64
	created_by          *datasource.UUID
	addcreated_by       *datasource.UUID
	created_at          *int64
	addcreated_at       *int64
	updated_by          *datasource.UUID
	addupdated_by       *datasource.UUID
	updated_at          *int64
	addupdated_at       *int64
	serial              *string
	connector_number    *int
	addconnector_number *int
	clearedFields       map[string]struct{}
	equipment           *datasource.UUID
	clearedequipment    bool
	connector           map[datasource.UUID]struct{}
	removedconnector    map[datasource.UUID]struct{}
	clearedconnector    bool
	done                bool
	oldValue            func(context.Context) (*Evse, error)
	predicates          []predicate.Evse
}

var _ ent.Mutation = (*EvseMutation)(nil)

// evseOption allows management of the mutation configuration using functional options.
type evseOption func(*EvseMutation)

// newEvseMutation creates new mutation for the Evse entity.
func newEvseMutation(c config, op Op, opts ...evseOption) *EvseMutation {
	m := &EvseMutation{
		config:        c,
		op:            op,
		typ:           TypeEvse,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEvseID sets the ID field of the mutation.
func withEvseID(id datasource.UUID) evseOption {
	return func(m *EvseMutation) {
		var (
			err   error
			once  sync.Once
			value *Evse
		)
		m.oldValue = func(ctx context.Context) (*Evse, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Evse.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEvse sets the old Evse of the mutation.
func withEvse(node *Evse) evseOption {
	return func(m *EvseMutation) {
		m.oldValue = func(context.Context) (*Evse, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EvseMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EvseMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Evse entities.
func (m *EvseMutation) SetID(id datasource.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EvseMutation) ID() (id datasource.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EvseMutation) IDs(ctx context.Context) ([]datasource.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []datasource.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Evse.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetVersion sets the "version" field.
func (m *EvseMutation) SetVersion(i int64) {
	m.version = &i
	m.addversion = nil
}

// Version returns the value of the "version" field in the mutation.
func (m *EvseMutation) Version() (r int64, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the Evse entity.
// If the Evse object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EvseMutation) OldVersion(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// AddVersion adds i to the "version" field.
func (m *EvseMutation) AddVersion(i int64) {
	if m.addversion != nil {
		*m.addversion += i
	} else {
		m.addversion = &i
	}
}

// AddedVersion returns the value that was added to the "version" field in this mutation.
func (m *EvseMutation) AddedVersion() (r int64, exists bool) {
	v := m.addversion
	if v == nil {
		return
	}
	return *v, true
}

// ResetVersion resets all changes to the "version" field.
func (m *EvseMutation) ResetVersion() {
	m.version = nil
	m.addversion = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *EvseMutation) SetCreatedBy(d datasource.UUID) {
	m.created_by = &d
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *EvseMutation) CreatedBy() (r datasource.UUID, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Evse entity.
// If the Evse object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EvseMutation) OldCreatedBy(ctx context.Context) (v datasource.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds d to the "created_by" field.
func (m *EvseMutation) AddCreatedBy(d datasource.UUID) {
	if m.addcreated_by != nil {
		*m.addcreated_by += d
	} else {
		m.addcreated_by = &d
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *EvseMutation) AddedCreatedBy() (r datasource.UUID, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *EvseMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *EvseMutation) SetCreatedAt(i int64) {
	m.created_at = &i
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EvseMutation) CreatedAt() (r int64, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Evse entity.
// If the Evse object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EvseMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to the "created_at" field.
func (m *EvseMutation) AddCreatedAt(i int64) {
	if m.addcreated_at != nil {
		*m.addcreated_at += i
	} else {
		m.addcreated_at = &i
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *EvseMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EvseMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *EvseMutation) SetUpdatedBy(d datasource.UUID) {
	m.updated_by = &d
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *EvseMutation) UpdatedBy() (r datasource.UUID, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Evse entity.
// If the Evse object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EvseMutation) OldUpdatedBy(ctx context.Context) (v datasource.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds d to the "updated_by" field.
func (m *EvseMutation) AddUpdatedBy(d datasource.UUID) {
	if m.addupdated_by != nil {
		*m.addupdated_by += d
	} else {
		m.addupdated_by = &d
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *EvseMutation) AddedUpdatedBy() (r datasource.UUID, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *EvseMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *EvseMutation) SetUpdatedAt(i int64) {
	m.updated_at = &i
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *EvseMutation) UpdatedAt() (r int64, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Evse entity.
// If the Evse object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EvseMutation) OldUpdatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to the "updated_at" field.
func (m *EvseMutation) AddUpdatedAt(i int64) {
	if m.addupdated_at != nil {
		*m.addupdated_at += i
	} else {
		m.addupdated_at = &i
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *EvseMutation) AddedUpdatedAt() (r int64, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *EvseMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetSerial sets the "serial" field.
func (m *EvseMutation) SetSerial(s string) {
	m.serial = &s
}

// Serial returns the value of the "serial" field in the mutation.
func (m *EvseMutation) Serial() (r string, exists bool) {
	v := m.serial
	if v == nil {
		return
	}
	return *v, true
}

// OldSerial returns the old "serial" field's value of the Evse entity.
// If the Evse object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EvseMutation) OldSerial(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSerial is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSerial requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSerial: %w", err)
	}
	return oldValue.Serial, nil
}

// ResetSerial resets all changes to the "serial" field.
func (m *EvseMutation) ResetSerial() {
	m.serial = nil
}

// SetConnectorNumber sets the "connector_number" field.
func (m *EvseMutation) SetConnectorNumber(i int) {
	m.connector_number = &i
	m.addconnector_number = nil
}

// ConnectorNumber returns the value of the "connector_number" field in the mutation.
func (m *EvseMutation) ConnectorNumber() (r int, exists bool) {
	v := m.connector_number
	if v == nil {
		return
	}
	return *v, true
}

// OldConnectorNumber returns the old "connector_number" field's value of the Evse entity.
// If the Evse object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EvseMutation) OldConnectorNumber(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConnectorNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConnectorNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConnectorNumber: %w", err)
	}
	return oldValue.ConnectorNumber, nil
}

// AddConnectorNumber adds i to the "connector_number" field.
func (m *EvseMutation) AddConnectorNumber(i int) {
	if m.addconnector_number != nil {
		*m.addconnector_number += i
	} else {
		m.addconnector_number = &i
	}
}

// AddedConnectorNumber returns the value that was added to the "connector_number" field in this mutation.
func (m *EvseMutation) AddedConnectorNumber() (r int, exists bool) {
	v := m.addconnector_number
	if v == nil {
		return
	}
	return *v, true
}

// ResetConnectorNumber resets all changes to the "connector_number" field.
func (m *EvseMutation) ResetConnectorNumber() {
	m.connector_number = nil
	m.addconnector_number = nil
}

// SetEquipmentID sets the "equipment" edge to the Equipment entity by id.
func (m *EvseMutation) SetEquipmentID(id datasource.UUID) {
	m.equipment = &id
}

// ClearEquipment clears the "equipment" edge to the Equipment entity.
func (m *EvseMutation) ClearEquipment() {
	m.clearedequipment = true
}

// EquipmentCleared reports if the "equipment" edge to the Equipment entity was cleared.
func (m *EvseMutation) EquipmentCleared() bool {
	return m.clearedequipment
}

// EquipmentID returns the "equipment" edge ID in the mutation.
func (m *EvseMutation) EquipmentID() (id datasource.UUID, exists bool) {
	if m.equipment != nil {
		return *m.equipment, true
	}
	return
}

// EquipmentIDs returns the "equipment" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EquipmentID instead. It exists only for internal usage by the builders.
func (m *EvseMutation) EquipmentIDs() (ids []datasource.UUID) {
	if id := m.equipment; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEquipment resets all changes to the "equipment" edge.
func (m *EvseMutation) ResetEquipment() {
	m.equipment = nil
	m.clearedequipment = false
}

// AddConnectorIDs adds the "connector" edge to the Connector entity by ids.
func (m *EvseMutation) AddConnectorIDs(ids ...datasource.UUID) {
	if m.connector == nil {
		m.connector = make(map[datasource.UUID]struct{})
	}
	for i := range ids {
		m.connector[ids[i]] = struct{}{}
	}
}

// ClearConnector clears the "connector" edge to the Connector entity.
func (m *EvseMutation) ClearConnector() {
	m.clearedconnector = true
}

// ConnectorCleared reports if the "connector" edge to the Connector entity was cleared.
func (m *EvseMutation) ConnectorCleared() bool {
	return m.clearedconnector
}

// RemoveConnectorIDs removes the "connector" edge to the Connector entity by IDs.
func (m *EvseMutation) RemoveConnectorIDs(ids ...datasource.UUID) {
	if m.removedconnector == nil {
		m.removedconnector = make(map[datasource.UUID]struct{})
	}
	for i := range ids {
		delete(m.connector, ids[i])
		m.removedconnector[ids[i]] = struct{}{}
	}
}

// RemovedConnector returns the removed IDs of the "connector" edge to the Connector entity.
func (m *EvseMutation) RemovedConnectorIDs() (ids []datasource.UUID) {
	for id := range m.removedconnector {
		ids = append(ids, id)
	}
	return
}

// ConnectorIDs returns the "connector" edge IDs in the mutation.
func (m *EvseMutation) ConnectorIDs() (ids []datasource.UUID) {
	for id := range m.connector {
		ids = append(ids, id)
	}
	return
}

// ResetConnector resets all changes to the "connector" edge.
func (m *EvseMutation) ResetConnector() {
	m.connector = nil
	m.clearedconnector = false
	m.removedconnector = nil
}

// Where appends a list predicates to the EvseMutation builder.
func (m *EvseMutation) Where(ps ...predicate.Evse) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *EvseMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Evse).
func (m *EvseMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EvseMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.version != nil {
		fields = append(fields, evse.FieldVersion)
	}
	if m.created_by != nil {
		fields = append(fields, evse.FieldCreatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, evse.FieldCreatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, evse.FieldUpdatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, evse.FieldUpdatedAt)
	}
	if m.serial != nil {
		fields = append(fields, evse.FieldSerial)
	}
	if m.connector_number != nil {
		fields = append(fields, evse.FieldConnectorNumber)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EvseMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case evse.FieldVersion:
		return m.Version()
	case evse.FieldCreatedBy:
		return m.CreatedBy()
	case evse.FieldCreatedAt:
		return m.CreatedAt()
	case evse.FieldUpdatedBy:
		return m.UpdatedBy()
	case evse.FieldUpdatedAt:
		return m.UpdatedAt()
	case evse.FieldSerial:
		return m.Serial()
	case evse.FieldConnectorNumber:
		return m.ConnectorNumber()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EvseMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case evse.FieldVersion:
		return m.OldVersion(ctx)
	case evse.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case evse.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case evse.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case evse.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case evse.FieldSerial:
		return m.OldSerial(ctx)
	case evse.FieldConnectorNumber:
		return m.OldConnectorNumber(ctx)
	}
	return nil, fmt.Errorf("unknown Evse field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EvseMutation) SetField(name string, value ent.Value) error {
	switch name {
	case evse.FieldVersion:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case evse.FieldCreatedBy:
		v, ok := value.(datasource.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case evse.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case evse.FieldUpdatedBy:
		v, ok := value.(datasource.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case evse.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case evse.FieldSerial:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSerial(v)
		return nil
	case evse.FieldConnectorNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConnectorNumber(v)
		return nil
	}
	return fmt.Errorf("unknown Evse field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EvseMutation) AddedFields() []string {
	var fields []string
	if m.addversion != nil {
		fields = append(fields, evse.FieldVersion)
	}
	if m.addcreated_by != nil {
		fields = append(fields, evse.FieldCreatedBy)
	}
	if m.addcreated_at != nil {
		fields = append(fields, evse.FieldCreatedAt)
	}
	if m.addupdated_by != nil {
		fields = append(fields, evse.FieldUpdatedBy)
	}
	if m.addupdated_at != nil {
		fields = append(fields, evse.FieldUpdatedAt)
	}
	if m.addconnector_number != nil {
		fields = append(fields, evse.FieldConnectorNumber)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EvseMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case evse.FieldVersion:
		return m.AddedVersion()
	case evse.FieldCreatedBy:
		return m.AddedCreatedBy()
	case evse.FieldCreatedAt:
		return m.AddedCreatedAt()
	case evse.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case evse.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case evse.FieldConnectorNumber:
		return m.AddedConnectorNumber()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EvseMutation) AddField(name string, value ent.Value) error {
	switch name {
	case evse.FieldVersion:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVersion(v)
		return nil
	case evse.FieldCreatedBy:
		v, ok := value.(datasource.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case evse.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case evse.FieldUpdatedBy:
		v, ok := value.(datasource.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case evse.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case evse.FieldConnectorNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddConnectorNumber(v)
		return nil
	}
	return fmt.Errorf("unknown Evse numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EvseMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EvseMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EvseMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Evse nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EvseMutation) ResetField(name string) error {
	switch name {
	case evse.FieldVersion:
		m.ResetVersion()
		return nil
	case evse.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case evse.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case evse.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case evse.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case evse.FieldSerial:
		m.ResetSerial()
		return nil
	case evse.FieldConnectorNumber:
		m.ResetConnectorNumber()
		return nil
	}
	return fmt.Errorf("unknown Evse field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EvseMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.equipment != nil {
		edges = append(edges, evse.EdgeEquipment)
	}
	if m.connector != nil {
		edges = append(edges, evse.EdgeConnector)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EvseMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case evse.EdgeEquipment:
		if id := m.equipment; id != nil {
			return []ent.Value{*id}
		}
	case evse.EdgeConnector:
		ids := make([]ent.Value, 0, len(m.connector))
		for id := range m.connector {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EvseMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedconnector != nil {
		edges = append(edges, evse.EdgeConnector)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EvseMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case evse.EdgeConnector:
		ids := make([]ent.Value, 0, len(m.removedconnector))
		for id := range m.removedconnector {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EvseMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedequipment {
		edges = append(edges, evse.EdgeEquipment)
	}
	if m.clearedconnector {
		edges = append(edges, evse.EdgeConnector)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EvseMutation) EdgeCleared(name string) bool {
	switch name {
	case evse.EdgeEquipment:
		return m.clearedequipment
	case evse.EdgeConnector:
		return m.clearedconnector
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EvseMutation) ClearEdge(name string) error {
	switch name {
	case evse.EdgeEquipment:
		m.ClearEquipment()
		return nil
	}
	return fmt.Errorf("unknown Evse unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EvseMutation) ResetEdge(name string) error {
	switch name {
	case evse.EdgeEquipment:
		m.ResetEquipment()
		return nil
	case evse.EdgeConnector:
		m.ResetConnector()
		return nil
	}
	return fmt.Errorf("unknown Evse edge %s", name)
}

// FirmwareMutation represents an operation that mutates the Firmware nodes in the graph.
type FirmwareMutation struct {
	config
	op                               Op
	typ                              string
	id                               *datasource.UUID
	version                          *int64
	addversion                       *int64
	created_by                       *datasource.UUID
	addcreated_by                    *datasource.UUID
	created_at                       *int64
	addcreated_at                    *int64
	updated_by                       *datasource.UUID
	addupdated_by                    *datasource.UUID
	updated_at                       *int64
	addupdated_at                    *int64
	equip_version                    *string
	clearedFields                    map[string]struct{}
	equipment_firmware_effect        map[datasource.UUID]struct{}
	removedequipment_firmware_effect map[datasource.UUID]struct{}
	clearedequipment_firmware_effect bool
	done                             bool
	oldValue                         func(context.Context) (*Firmware, error)
	predicates                       []predicate.Firmware
}

var _ ent.Mutation = (*FirmwareMutation)(nil)

// firmwareOption allows management of the mutation configuration using functional options.
type firmwareOption func(*FirmwareMutation)

// newFirmwareMutation creates new mutation for the Firmware entity.
func newFirmwareMutation(c config, op Op, opts ...firmwareOption) *FirmwareMutation {
	m := &FirmwareMutation{
		config:        c,
		op:            op,
		typ:           TypeFirmware,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFirmwareID sets the ID field of the mutation.
func withFirmwareID(id datasource.UUID) firmwareOption {
	return func(m *FirmwareMutation) {
		var (
			err   error
			once  sync.Once
			value *Firmware
		)
		m.oldValue = func(ctx context.Context) (*Firmware, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Firmware.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFirmware sets the old Firmware of the mutation.
func withFirmware(node *Firmware) firmwareOption {
	return func(m *FirmwareMutation) {
		m.oldValue = func(context.Context) (*Firmware, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FirmwareMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FirmwareMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Firmware entities.
func (m *FirmwareMutation) SetID(id datasource.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FirmwareMutation) ID() (id datasource.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FirmwareMutation) IDs(ctx context.Context) ([]datasource.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []datasource.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Firmware.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetVersion sets the "version" field.
func (m *FirmwareMutation) SetVersion(i int64) {
	m.version = &i
	m.addversion = nil
}

// Version returns the value of the "version" field in the mutation.
func (m *FirmwareMutation) Version() (r int64, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the Firmware entity.
// If the Firmware object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FirmwareMutation) OldVersion(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// AddVersion adds i to the "version" field.
func (m *FirmwareMutation) AddVersion(i int64) {
	if m.addversion != nil {
		*m.addversion += i
	} else {
		m.addversion = &i
	}
}

// AddedVersion returns the value that was added to the "version" field in this mutation.
func (m *FirmwareMutation) AddedVersion() (r int64, exists bool) {
	v := m.addversion
	if v == nil {
		return
	}
	return *v, true
}

// ResetVersion resets all changes to the "version" field.
func (m *FirmwareMutation) ResetVersion() {
	m.version = nil
	m.addversion = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *FirmwareMutation) SetCreatedBy(d datasource.UUID) {
	m.created_by = &d
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *FirmwareMutation) CreatedBy() (r datasource.UUID, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Firmware entity.
// If the Firmware object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FirmwareMutation) OldCreatedBy(ctx context.Context) (v datasource.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds d to the "created_by" field.
func (m *FirmwareMutation) AddCreatedBy(d datasource.UUID) {
	if m.addcreated_by != nil {
		*m.addcreated_by += d
	} else {
		m.addcreated_by = &d
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *FirmwareMutation) AddedCreatedBy() (r datasource.UUID, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *FirmwareMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *FirmwareMutation) SetCreatedAt(i int64) {
	m.created_at = &i
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *FirmwareMutation) CreatedAt() (r int64, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Firmware entity.
// If the Firmware object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FirmwareMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to the "created_at" field.
func (m *FirmwareMutation) AddCreatedAt(i int64) {
	if m.addcreated_at != nil {
		*m.addcreated_at += i
	} else {
		m.addcreated_at = &i
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *FirmwareMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *FirmwareMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *FirmwareMutation) SetUpdatedBy(d datasource.UUID) {
	m.updated_by = &d
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *FirmwareMutation) UpdatedBy() (r datasource.UUID, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Firmware entity.
// If the Firmware object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FirmwareMutation) OldUpdatedBy(ctx context.Context) (v datasource.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds d to the "updated_by" field.
func (m *FirmwareMutation) AddUpdatedBy(d datasource.UUID) {
	if m.addupdated_by != nil {
		*m.addupdated_by += d
	} else {
		m.addupdated_by = &d
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *FirmwareMutation) AddedUpdatedBy() (r datasource.UUID, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *FirmwareMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *FirmwareMutation) SetUpdatedAt(i int64) {
	m.updated_at = &i
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *FirmwareMutation) UpdatedAt() (r int64, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Firmware entity.
// If the Firmware object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FirmwareMutation) OldUpdatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to the "updated_at" field.
func (m *FirmwareMutation) AddUpdatedAt(i int64) {
	if m.addupdated_at != nil {
		*m.addupdated_at += i
	} else {
		m.addupdated_at = &i
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *FirmwareMutation) AddedUpdatedAt() (r int64, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *FirmwareMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetEquipVersion sets the "equip_version" field.
func (m *FirmwareMutation) SetEquipVersion(s string) {
	m.equip_version = &s
}

// EquipVersion returns the value of the "equip_version" field in the mutation.
func (m *FirmwareMutation) EquipVersion() (r string, exists bool) {
	v := m.equip_version
	if v == nil {
		return
	}
	return *v, true
}

// OldEquipVersion returns the old "equip_version" field's value of the Firmware entity.
// If the Firmware object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FirmwareMutation) OldEquipVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEquipVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEquipVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEquipVersion: %w", err)
	}
	return oldValue.EquipVersion, nil
}

// ResetEquipVersion resets all changes to the "equip_version" field.
func (m *FirmwareMutation) ResetEquipVersion() {
	m.equip_version = nil
}

// AddEquipmentFirmwareEffectIDs adds the "equipment_firmware_effect" edge to the EquipmentFirmwareEffect entity by ids.
func (m *FirmwareMutation) AddEquipmentFirmwareEffectIDs(ids ...datasource.UUID) {
	if m.equipment_firmware_effect == nil {
		m.equipment_firmware_effect = make(map[datasource.UUID]struct{})
	}
	for i := range ids {
		m.equipment_firmware_effect[ids[i]] = struct{}{}
	}
}

// ClearEquipmentFirmwareEffect clears the "equipment_firmware_effect" edge to the EquipmentFirmwareEffect entity.
func (m *FirmwareMutation) ClearEquipmentFirmwareEffect() {
	m.clearedequipment_firmware_effect = true
}

// EquipmentFirmwareEffectCleared reports if the "equipment_firmware_effect" edge to the EquipmentFirmwareEffect entity was cleared.
func (m *FirmwareMutation) EquipmentFirmwareEffectCleared() bool {
	return m.clearedequipment_firmware_effect
}

// RemoveEquipmentFirmwareEffectIDs removes the "equipment_firmware_effect" edge to the EquipmentFirmwareEffect entity by IDs.
func (m *FirmwareMutation) RemoveEquipmentFirmwareEffectIDs(ids ...datasource.UUID) {
	if m.removedequipment_firmware_effect == nil {
		m.removedequipment_firmware_effect = make(map[datasource.UUID]struct{})
	}
	for i := range ids {
		delete(m.equipment_firmware_effect, ids[i])
		m.removedequipment_firmware_effect[ids[i]] = struct{}{}
	}
}

// RemovedEquipmentFirmwareEffect returns the removed IDs of the "equipment_firmware_effect" edge to the EquipmentFirmwareEffect entity.
func (m *FirmwareMutation) RemovedEquipmentFirmwareEffectIDs() (ids []datasource.UUID) {
	for id := range m.removedequipment_firmware_effect {
		ids = append(ids, id)
	}
	return
}

// EquipmentFirmwareEffectIDs returns the "equipment_firmware_effect" edge IDs in the mutation.
func (m *FirmwareMutation) EquipmentFirmwareEffectIDs() (ids []datasource.UUID) {
	for id := range m.equipment_firmware_effect {
		ids = append(ids, id)
	}
	return
}

// ResetEquipmentFirmwareEffect resets all changes to the "equipment_firmware_effect" edge.
func (m *FirmwareMutation) ResetEquipmentFirmwareEffect() {
	m.equipment_firmware_effect = nil
	m.clearedequipment_firmware_effect = false
	m.removedequipment_firmware_effect = nil
}

// Where appends a list predicates to the FirmwareMutation builder.
func (m *FirmwareMutation) Where(ps ...predicate.Firmware) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *FirmwareMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Firmware).
func (m *FirmwareMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FirmwareMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.version != nil {
		fields = append(fields, firmware.FieldVersion)
	}
	if m.created_by != nil {
		fields = append(fields, firmware.FieldCreatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, firmware.FieldCreatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, firmware.FieldUpdatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, firmware.FieldUpdatedAt)
	}
	if m.equip_version != nil {
		fields = append(fields, firmware.FieldEquipVersion)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FirmwareMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case firmware.FieldVersion:
		return m.Version()
	case firmware.FieldCreatedBy:
		return m.CreatedBy()
	case firmware.FieldCreatedAt:
		return m.CreatedAt()
	case firmware.FieldUpdatedBy:
		return m.UpdatedBy()
	case firmware.FieldUpdatedAt:
		return m.UpdatedAt()
	case firmware.FieldEquipVersion:
		return m.EquipVersion()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FirmwareMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case firmware.FieldVersion:
		return m.OldVersion(ctx)
	case firmware.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case firmware.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case firmware.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case firmware.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case firmware.FieldEquipVersion:
		return m.OldEquipVersion(ctx)
	}
	return nil, fmt.Errorf("unknown Firmware field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FirmwareMutation) SetField(name string, value ent.Value) error {
	switch name {
	case firmware.FieldVersion:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case firmware.FieldCreatedBy:
		v, ok := value.(datasource.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case firmware.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case firmware.FieldUpdatedBy:
		v, ok := value.(datasource.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case firmware.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case firmware.FieldEquipVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEquipVersion(v)
		return nil
	}
	return fmt.Errorf("unknown Firmware field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FirmwareMutation) AddedFields() []string {
	var fields []string
	if m.addversion != nil {
		fields = append(fields, firmware.FieldVersion)
	}
	if m.addcreated_by != nil {
		fields = append(fields, firmware.FieldCreatedBy)
	}
	if m.addcreated_at != nil {
		fields = append(fields, firmware.FieldCreatedAt)
	}
	if m.addupdated_by != nil {
		fields = append(fields, firmware.FieldUpdatedBy)
	}
	if m.addupdated_at != nil {
		fields = append(fields, firmware.FieldUpdatedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FirmwareMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case firmware.FieldVersion:
		return m.AddedVersion()
	case firmware.FieldCreatedBy:
		return m.AddedCreatedBy()
	case firmware.FieldCreatedAt:
		return m.AddedCreatedAt()
	case firmware.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case firmware.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FirmwareMutation) AddField(name string, value ent.Value) error {
	switch name {
	case firmware.FieldVersion:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVersion(v)
		return nil
	case firmware.FieldCreatedBy:
		v, ok := value.(datasource.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case firmware.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case firmware.FieldUpdatedBy:
		v, ok := value.(datasource.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case firmware.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Firmware numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FirmwareMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FirmwareMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FirmwareMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Firmware nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FirmwareMutation) ResetField(name string) error {
	switch name {
	case firmware.FieldVersion:
		m.ResetVersion()
		return nil
	case firmware.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case firmware.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case firmware.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case firmware.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case firmware.FieldEquipVersion:
		m.ResetEquipVersion()
		return nil
	}
	return fmt.Errorf("unknown Firmware field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FirmwareMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.equipment_firmware_effect != nil {
		edges = append(edges, firmware.EdgeEquipmentFirmwareEffect)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FirmwareMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case firmware.EdgeEquipmentFirmwareEffect:
		ids := make([]ent.Value, 0, len(m.equipment_firmware_effect))
		for id := range m.equipment_firmware_effect {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FirmwareMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedequipment_firmware_effect != nil {
		edges = append(edges, firmware.EdgeEquipmentFirmwareEffect)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FirmwareMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case firmware.EdgeEquipmentFirmwareEffect:
		ids := make([]ent.Value, 0, len(m.removedequipment_firmware_effect))
		for id := range m.removedequipment_firmware_effect {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FirmwareMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedequipment_firmware_effect {
		edges = append(edges, firmware.EdgeEquipmentFirmwareEffect)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FirmwareMutation) EdgeCleared(name string) bool {
	switch name {
	case firmware.EdgeEquipmentFirmwareEffect:
		return m.clearedequipment_firmware_effect
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FirmwareMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Firmware unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FirmwareMutation) ResetEdge(name string) error {
	switch name {
	case firmware.EdgeEquipmentFirmwareEffect:
		m.ResetEquipmentFirmwareEffect()
		return nil
	}
	return fmt.Errorf("unknown Firmware edge %s", name)
}

// ManufacturerMutation represents an operation that mutates the Manufacturer nodes in the graph.
type ManufacturerMutation struct {
	config
	op            Op
	typ           string
	id            *datasource.UUID
	version       *int64
	addversion    *int64
	created_by    *datasource.UUID
	addcreated_by *datasource.UUID
	created_at    *int64
	addcreated_at *int64
	updated_by    *datasource.UUID
	addupdated_by *datasource.UUID
	updated_at    *int64
	addupdated_at *int64
	code          *string
	name          *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Manufacturer, error)
	predicates    []predicate.Manufacturer
}

var _ ent.Mutation = (*ManufacturerMutation)(nil)

// manufacturerOption allows management of the mutation configuration using functional options.
type manufacturerOption func(*ManufacturerMutation)

// newManufacturerMutation creates new mutation for the Manufacturer entity.
func newManufacturerMutation(c config, op Op, opts ...manufacturerOption) *ManufacturerMutation {
	m := &ManufacturerMutation{
		config:        c,
		op:            op,
		typ:           TypeManufacturer,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withManufacturerID sets the ID field of the mutation.
func withManufacturerID(id datasource.UUID) manufacturerOption {
	return func(m *ManufacturerMutation) {
		var (
			err   error
			once  sync.Once
			value *Manufacturer
		)
		m.oldValue = func(ctx context.Context) (*Manufacturer, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Manufacturer.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withManufacturer sets the old Manufacturer of the mutation.
func withManufacturer(node *Manufacturer) manufacturerOption {
	return func(m *ManufacturerMutation) {
		m.oldValue = func(context.Context) (*Manufacturer, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ManufacturerMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ManufacturerMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Manufacturer entities.
func (m *ManufacturerMutation) SetID(id datasource.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ManufacturerMutation) ID() (id datasource.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ManufacturerMutation) IDs(ctx context.Context) ([]datasource.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []datasource.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Manufacturer.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetVersion sets the "version" field.
func (m *ManufacturerMutation) SetVersion(i int64) {
	m.version = &i
	m.addversion = nil
}

// Version returns the value of the "version" field in the mutation.
func (m *ManufacturerMutation) Version() (r int64, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the Manufacturer entity.
// If the Manufacturer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ManufacturerMutation) OldVersion(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// AddVersion adds i to the "version" field.
func (m *ManufacturerMutation) AddVersion(i int64) {
	if m.addversion != nil {
		*m.addversion += i
	} else {
		m.addversion = &i
	}
}

// AddedVersion returns the value that was added to the "version" field in this mutation.
func (m *ManufacturerMutation) AddedVersion() (r int64, exists bool) {
	v := m.addversion
	if v == nil {
		return
	}
	return *v, true
}

// ResetVersion resets all changes to the "version" field.
func (m *ManufacturerMutation) ResetVersion() {
	m.version = nil
	m.addversion = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *ManufacturerMutation) SetCreatedBy(d datasource.UUID) {
	m.created_by = &d
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *ManufacturerMutation) CreatedBy() (r datasource.UUID, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Manufacturer entity.
// If the Manufacturer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ManufacturerMutation) OldCreatedBy(ctx context.Context) (v datasource.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds d to the "created_by" field.
func (m *ManufacturerMutation) AddCreatedBy(d datasource.UUID) {
	if m.addcreated_by != nil {
		*m.addcreated_by += d
	} else {
		m.addcreated_by = &d
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *ManufacturerMutation) AddedCreatedBy() (r datasource.UUID, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *ManufacturerMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ManufacturerMutation) SetCreatedAt(i int64) {
	m.created_at = &i
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ManufacturerMutation) CreatedAt() (r int64, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Manufacturer entity.
// If the Manufacturer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ManufacturerMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to the "created_at" field.
func (m *ManufacturerMutation) AddCreatedAt(i int64) {
	if m.addcreated_at != nil {
		*m.addcreated_at += i
	} else {
		m.addcreated_at = &i
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *ManufacturerMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ManufacturerMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *ManufacturerMutation) SetUpdatedBy(d datasource.UUID) {
	m.updated_by = &d
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *ManufacturerMutation) UpdatedBy() (r datasource.UUID, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Manufacturer entity.
// If the Manufacturer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ManufacturerMutation) OldUpdatedBy(ctx context.Context) (v datasource.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds d to the "updated_by" field.
func (m *ManufacturerMutation) AddUpdatedBy(d datasource.UUID) {
	if m.addupdated_by != nil {
		*m.addupdated_by += d
	} else {
		m.addupdated_by = &d
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *ManufacturerMutation) AddedUpdatedBy() (r datasource.UUID, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *ManufacturerMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ManufacturerMutation) SetUpdatedAt(i int64) {
	m.updated_at = &i
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ManufacturerMutation) UpdatedAt() (r int64, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Manufacturer entity.
// If the Manufacturer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ManufacturerMutation) OldUpdatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to the "updated_at" field.
func (m *ManufacturerMutation) AddUpdatedAt(i int64) {
	if m.addupdated_at != nil {
		*m.addupdated_at += i
	} else {
		m.addupdated_at = &i
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *ManufacturerMutation) AddedUpdatedAt() (r int64, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ManufacturerMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetCode sets the "code" field.
func (m *ManufacturerMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *ManufacturerMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the Manufacturer entity.
// If the Manufacturer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ManufacturerMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *ManufacturerMutation) ResetCode() {
	m.code = nil
}

// SetName sets the "name" field.
func (m *ManufacturerMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ManufacturerMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Manufacturer entity.
// If the Manufacturer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ManufacturerMutation) OldName(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *ManufacturerMutation) ClearName() {
	m.name = nil
	m.clearedFields[manufacturer.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *ManufacturerMutation) NameCleared() bool {
	_, ok := m.clearedFields[manufacturer.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *ManufacturerMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, manufacturer.FieldName)
}

// Where appends a list predicates to the ManufacturerMutation builder.
func (m *ManufacturerMutation) Where(ps ...predicate.Manufacturer) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ManufacturerMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Manufacturer).
func (m *ManufacturerMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ManufacturerMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.version != nil {
		fields = append(fields, manufacturer.FieldVersion)
	}
	if m.created_by != nil {
		fields = append(fields, manufacturer.FieldCreatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, manufacturer.FieldCreatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, manufacturer.FieldUpdatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, manufacturer.FieldUpdatedAt)
	}
	if m.code != nil {
		fields = append(fields, manufacturer.FieldCode)
	}
	if m.name != nil {
		fields = append(fields, manufacturer.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ManufacturerMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case manufacturer.FieldVersion:
		return m.Version()
	case manufacturer.FieldCreatedBy:
		return m.CreatedBy()
	case manufacturer.FieldCreatedAt:
		return m.CreatedAt()
	case manufacturer.FieldUpdatedBy:
		return m.UpdatedBy()
	case manufacturer.FieldUpdatedAt:
		return m.UpdatedAt()
	case manufacturer.FieldCode:
		return m.Code()
	case manufacturer.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ManufacturerMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case manufacturer.FieldVersion:
		return m.OldVersion(ctx)
	case manufacturer.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case manufacturer.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case manufacturer.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case manufacturer.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case manufacturer.FieldCode:
		return m.OldCode(ctx)
	case manufacturer.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown Manufacturer field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ManufacturerMutation) SetField(name string, value ent.Value) error {
	switch name {
	case manufacturer.FieldVersion:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case manufacturer.FieldCreatedBy:
		v, ok := value.(datasource.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case manufacturer.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case manufacturer.FieldUpdatedBy:
		v, ok := value.(datasource.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case manufacturer.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case manufacturer.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case manufacturer.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown Manufacturer field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ManufacturerMutation) AddedFields() []string {
	var fields []string
	if m.addversion != nil {
		fields = append(fields, manufacturer.FieldVersion)
	}
	if m.addcreated_by != nil {
		fields = append(fields, manufacturer.FieldCreatedBy)
	}
	if m.addcreated_at != nil {
		fields = append(fields, manufacturer.FieldCreatedAt)
	}
	if m.addupdated_by != nil {
		fields = append(fields, manufacturer.FieldUpdatedBy)
	}
	if m.addupdated_at != nil {
		fields = append(fields, manufacturer.FieldUpdatedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ManufacturerMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case manufacturer.FieldVersion:
		return m.AddedVersion()
	case manufacturer.FieldCreatedBy:
		return m.AddedCreatedBy()
	case manufacturer.FieldCreatedAt:
		return m.AddedCreatedAt()
	case manufacturer.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case manufacturer.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ManufacturerMutation) AddField(name string, value ent.Value) error {
	switch name {
	case manufacturer.FieldVersion:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVersion(v)
		return nil
	case manufacturer.FieldCreatedBy:
		v, ok := value.(datasource.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case manufacturer.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case manufacturer.FieldUpdatedBy:
		v, ok := value.(datasource.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case manufacturer.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Manufacturer numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ManufacturerMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(manufacturer.FieldName) {
		fields = append(fields, manufacturer.FieldName)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ManufacturerMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ManufacturerMutation) ClearField(name string) error {
	switch name {
	case manufacturer.FieldName:
		m.ClearName()
		return nil
	}
	return fmt.Errorf("unknown Manufacturer nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ManufacturerMutation) ResetField(name string) error {
	switch name {
	case manufacturer.FieldVersion:
		m.ResetVersion()
		return nil
	case manufacturer.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case manufacturer.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case manufacturer.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case manufacturer.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case manufacturer.FieldCode:
		m.ResetCode()
		return nil
	case manufacturer.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown Manufacturer field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ManufacturerMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ManufacturerMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ManufacturerMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ManufacturerMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ManufacturerMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ManufacturerMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ManufacturerMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Manufacturer unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ManufacturerMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Manufacturer edge %s", name)
}

// ModelMutation represents an operation that mutates the Model nodes in the graph.
type ModelMutation struct {
	config
	op               Op
	typ              string
	id               *datasource.UUID
	version          *int64
	addversion       *int64
	created_by       *datasource.UUID
	addcreated_by    *datasource.UUID
	created_at       *int64
	addcreated_at    *int64
	updated_by       *datasource.UUID
	addupdated_by    *datasource.UUID
	updated_at       *int64
	addupdated_at    *int64
	code             *string
	name             *string
	phase_category   *string
	current_category *string
	clearedFields    map[string]struct{}
	done             bool
	oldValue         func(context.Context) (*Model, error)
	predicates       []predicate.Model
}

var _ ent.Mutation = (*ModelMutation)(nil)

// modelOption allows management of the mutation configuration using functional options.
type modelOption func(*ModelMutation)

// newModelMutation creates new mutation for the Model entity.
func newModelMutation(c config, op Op, opts ...modelOption) *ModelMutation {
	m := &ModelMutation{
		config:        c,
		op:            op,
		typ:           TypeModel,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withModelID sets the ID field of the mutation.
func withModelID(id datasource.UUID) modelOption {
	return func(m *ModelMutation) {
		var (
			err   error
			once  sync.Once
			value *Model
		)
		m.oldValue = func(ctx context.Context) (*Model, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Model.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withModel sets the old Model of the mutation.
func withModel(node *Model) modelOption {
	return func(m *ModelMutation) {
		m.oldValue = func(context.Context) (*Model, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ModelMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ModelMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Model entities.
func (m *ModelMutation) SetID(id datasource.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ModelMutation) ID() (id datasource.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ModelMutation) IDs(ctx context.Context) ([]datasource.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []datasource.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Model.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetVersion sets the "version" field.
func (m *ModelMutation) SetVersion(i int64) {
	m.version = &i
	m.addversion = nil
}

// Version returns the value of the "version" field in the mutation.
func (m *ModelMutation) Version() (r int64, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the Model entity.
// If the Model object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModelMutation) OldVersion(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// AddVersion adds i to the "version" field.
func (m *ModelMutation) AddVersion(i int64) {
	if m.addversion != nil {
		*m.addversion += i
	} else {
		m.addversion = &i
	}
}

// AddedVersion returns the value that was added to the "version" field in this mutation.
func (m *ModelMutation) AddedVersion() (r int64, exists bool) {
	v := m.addversion
	if v == nil {
		return
	}
	return *v, true
}

// ResetVersion resets all changes to the "version" field.
func (m *ModelMutation) ResetVersion() {
	m.version = nil
	m.addversion = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *ModelMutation) SetCreatedBy(d datasource.UUID) {
	m.created_by = &d
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *ModelMutation) CreatedBy() (r datasource.UUID, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Model entity.
// If the Model object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModelMutation) OldCreatedBy(ctx context.Context) (v datasource.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds d to the "created_by" field.
func (m *ModelMutation) AddCreatedBy(d datasource.UUID) {
	if m.addcreated_by != nil {
		*m.addcreated_by += d
	} else {
		m.addcreated_by = &d
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *ModelMutation) AddedCreatedBy() (r datasource.UUID, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *ModelMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ModelMutation) SetCreatedAt(i int64) {
	m.created_at = &i
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ModelMutation) CreatedAt() (r int64, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Model entity.
// If the Model object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModelMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to the "created_at" field.
func (m *ModelMutation) AddCreatedAt(i int64) {
	if m.addcreated_at != nil {
		*m.addcreated_at += i
	} else {
		m.addcreated_at = &i
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *ModelMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ModelMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *ModelMutation) SetUpdatedBy(d datasource.UUID) {
	m.updated_by = &d
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *ModelMutation) UpdatedBy() (r datasource.UUID, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Model entity.
// If the Model object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModelMutation) OldUpdatedBy(ctx context.Context) (v datasource.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds d to the "updated_by" field.
func (m *ModelMutation) AddUpdatedBy(d datasource.UUID) {
	if m.addupdated_by != nil {
		*m.addupdated_by += d
	} else {
		m.addupdated_by = &d
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *ModelMutation) AddedUpdatedBy() (r datasource.UUID, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *ModelMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ModelMutation) SetUpdatedAt(i int64) {
	m.updated_at = &i
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ModelMutation) UpdatedAt() (r int64, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Model entity.
// If the Model object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModelMutation) OldUpdatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to the "updated_at" field.
func (m *ModelMutation) AddUpdatedAt(i int64) {
	if m.addupdated_at != nil {
		*m.addupdated_at += i
	} else {
		m.addupdated_at = &i
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *ModelMutation) AddedUpdatedAt() (r int64, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ModelMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetCode sets the "code" field.
func (m *ModelMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *ModelMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the Model entity.
// If the Model object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModelMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *ModelMutation) ResetCode() {
	m.code = nil
}

// SetName sets the "name" field.
func (m *ModelMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ModelMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Model entity.
// If the Model object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModelMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ModelMutation) ResetName() {
	m.name = nil
}

// SetPhaseCategory sets the "phase_category" field.
func (m *ModelMutation) SetPhaseCategory(s string) {
	m.phase_category = &s
}

// PhaseCategory returns the value of the "phase_category" field in the mutation.
func (m *ModelMutation) PhaseCategory() (r string, exists bool) {
	v := m.phase_category
	if v == nil {
		return
	}
	return *v, true
}

// OldPhaseCategory returns the old "phase_category" field's value of the Model entity.
// If the Model object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModelMutation) OldPhaseCategory(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhaseCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhaseCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhaseCategory: %w", err)
	}
	return oldValue.PhaseCategory, nil
}

// ResetPhaseCategory resets all changes to the "phase_category" field.
func (m *ModelMutation) ResetPhaseCategory() {
	m.phase_category = nil
}

// SetCurrentCategory sets the "current_category" field.
func (m *ModelMutation) SetCurrentCategory(s string) {
	m.current_category = &s
}

// CurrentCategory returns the value of the "current_category" field in the mutation.
func (m *ModelMutation) CurrentCategory() (r string, exists bool) {
	v := m.current_category
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrentCategory returns the old "current_category" field's value of the Model entity.
// If the Model object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModelMutation) OldCurrentCategory(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrentCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrentCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrentCategory: %w", err)
	}
	return oldValue.CurrentCategory, nil
}

// ResetCurrentCategory resets all changes to the "current_category" field.
func (m *ModelMutation) ResetCurrentCategory() {
	m.current_category = nil
}

// Where appends a list predicates to the ModelMutation builder.
func (m *ModelMutation) Where(ps ...predicate.Model) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ModelMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Model).
func (m *ModelMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ModelMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.version != nil {
		fields = append(fields, model.FieldVersion)
	}
	if m.created_by != nil {
		fields = append(fields, model.FieldCreatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, model.FieldCreatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, model.FieldUpdatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, model.FieldUpdatedAt)
	}
	if m.code != nil {
		fields = append(fields, model.FieldCode)
	}
	if m.name != nil {
		fields = append(fields, model.FieldName)
	}
	if m.phase_category != nil {
		fields = append(fields, model.FieldPhaseCategory)
	}
	if m.current_category != nil {
		fields = append(fields, model.FieldCurrentCategory)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ModelMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case model.FieldVersion:
		return m.Version()
	case model.FieldCreatedBy:
		return m.CreatedBy()
	case model.FieldCreatedAt:
		return m.CreatedAt()
	case model.FieldUpdatedBy:
		return m.UpdatedBy()
	case model.FieldUpdatedAt:
		return m.UpdatedAt()
	case model.FieldCode:
		return m.Code()
	case model.FieldName:
		return m.Name()
	case model.FieldPhaseCategory:
		return m.PhaseCategory()
	case model.FieldCurrentCategory:
		return m.CurrentCategory()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ModelMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case model.FieldVersion:
		return m.OldVersion(ctx)
	case model.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case model.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case model.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case model.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case model.FieldCode:
		return m.OldCode(ctx)
	case model.FieldName:
		return m.OldName(ctx)
	case model.FieldPhaseCategory:
		return m.OldPhaseCategory(ctx)
	case model.FieldCurrentCategory:
		return m.OldCurrentCategory(ctx)
	}
	return nil, fmt.Errorf("unknown Model field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ModelMutation) SetField(name string, value ent.Value) error {
	switch name {
	case model.FieldVersion:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case model.FieldCreatedBy:
		v, ok := value.(datasource.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case model.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case model.FieldUpdatedBy:
		v, ok := value.(datasource.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case model.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case model.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case model.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case model.FieldPhaseCategory:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhaseCategory(v)
		return nil
	case model.FieldCurrentCategory:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrentCategory(v)
		return nil
	}
	return fmt.Errorf("unknown Model field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ModelMutation) AddedFields() []string {
	var fields []string
	if m.addversion != nil {
		fields = append(fields, model.FieldVersion)
	}
	if m.addcreated_by != nil {
		fields = append(fields, model.FieldCreatedBy)
	}
	if m.addcreated_at != nil {
		fields = append(fields, model.FieldCreatedAt)
	}
	if m.addupdated_by != nil {
		fields = append(fields, model.FieldUpdatedBy)
	}
	if m.addupdated_at != nil {
		fields = append(fields, model.FieldUpdatedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ModelMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case model.FieldVersion:
		return m.AddedVersion()
	case model.FieldCreatedBy:
		return m.AddedCreatedBy()
	case model.FieldCreatedAt:
		return m.AddedCreatedAt()
	case model.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case model.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ModelMutation) AddField(name string, value ent.Value) error {
	switch name {
	case model.FieldVersion:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVersion(v)
		return nil
	case model.FieldCreatedBy:
		v, ok := value.(datasource.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case model.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case model.FieldUpdatedBy:
		v, ok := value.(datasource.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case model.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Model numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ModelMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ModelMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ModelMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Model nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ModelMutation) ResetField(name string) error {
	switch name {
	case model.FieldVersion:
		m.ResetVersion()
		return nil
	case model.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case model.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case model.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case model.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case model.FieldCode:
		m.ResetCode()
		return nil
	case model.FieldName:
		m.ResetName()
		return nil
	case model.FieldPhaseCategory:
		m.ResetPhaseCategory()
		return nil
	case model.FieldCurrentCategory:
		m.ResetCurrentCategory()
		return nil
	}
	return fmt.Errorf("unknown Model field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ModelMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ModelMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ModelMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ModelMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ModelMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ModelMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ModelMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Model unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ModelMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Model edge %s", name)
}

// OrderEventMutation represents an operation that mutates the OrderEvent nodes in the graph.
type OrderEventMutation struct {
	config
	op                Op
	typ               string
	id                *datasource.UUID
	content           *string
	occurrence        *int64
	addoccurrence     *int64
	clearedFields     map[string]struct{}
	order_info        *datasource.UUID
	clearedorder_info bool
	done              bool
	oldValue          func(context.Context) (*OrderEvent, error)
	predicates        []predicate.OrderEvent
}

var _ ent.Mutation = (*OrderEventMutation)(nil)

// ordereventOption allows management of the mutation configuration using functional options.
type ordereventOption func(*OrderEventMutation)

// newOrderEventMutation creates new mutation for the OrderEvent entity.
func newOrderEventMutation(c config, op Op, opts ...ordereventOption) *OrderEventMutation {
	m := &OrderEventMutation{
		config:        c,
		op:            op,
		typ:           TypeOrderEvent,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrderEventID sets the ID field of the mutation.
func withOrderEventID(id datasource.UUID) ordereventOption {
	return func(m *OrderEventMutation) {
		var (
			err   error
			once  sync.Once
			value *OrderEvent
		)
		m.oldValue = func(ctx context.Context) (*OrderEvent, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OrderEvent.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrderEvent sets the old OrderEvent of the mutation.
func withOrderEvent(node *OrderEvent) ordereventOption {
	return func(m *OrderEventMutation) {
		m.oldValue = func(context.Context) (*OrderEvent, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrderEventMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrderEventMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of OrderEvent entities.
func (m *OrderEventMutation) SetID(id datasource.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrderEventMutation) ID() (id datasource.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrderEventMutation) IDs(ctx context.Context) ([]datasource.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []datasource.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OrderEvent.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetContent sets the "content" field.
func (m *OrderEventMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *OrderEventMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the OrderEvent entity.
// If the OrderEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderEventMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ResetContent resets all changes to the "content" field.
func (m *OrderEventMutation) ResetContent() {
	m.content = nil
}

// SetOccurrence sets the "occurrence" field.
func (m *OrderEventMutation) SetOccurrence(i int64) {
	m.occurrence = &i
	m.addoccurrence = nil
}

// Occurrence returns the value of the "occurrence" field in the mutation.
func (m *OrderEventMutation) Occurrence() (r int64, exists bool) {
	v := m.occurrence
	if v == nil {
		return
	}
	return *v, true
}

// OldOccurrence returns the old "occurrence" field's value of the OrderEvent entity.
// If the OrderEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderEventMutation) OldOccurrence(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOccurrence is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOccurrence requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOccurrence: %w", err)
	}
	return oldValue.Occurrence, nil
}

// AddOccurrence adds i to the "occurrence" field.
func (m *OrderEventMutation) AddOccurrence(i int64) {
	if m.addoccurrence != nil {
		*m.addoccurrence += i
	} else {
		m.addoccurrence = &i
	}
}

// AddedOccurrence returns the value that was added to the "occurrence" field in this mutation.
func (m *OrderEventMutation) AddedOccurrence() (r int64, exists bool) {
	v := m.addoccurrence
	if v == nil {
		return
	}
	return *v, true
}

// ResetOccurrence resets all changes to the "occurrence" field.
func (m *OrderEventMutation) ResetOccurrence() {
	m.occurrence = nil
	m.addoccurrence = nil
}

// SetOrderInfoID sets the "order_info" edge to the OrderInfo entity by id.
func (m *OrderEventMutation) SetOrderInfoID(id datasource.UUID) {
	m.order_info = &id
}

// ClearOrderInfo clears the "order_info" edge to the OrderInfo entity.
func (m *OrderEventMutation) ClearOrderInfo() {
	m.clearedorder_info = true
}

// OrderInfoCleared reports if the "order_info" edge to the OrderInfo entity was cleared.
func (m *OrderEventMutation) OrderInfoCleared() bool {
	return m.clearedorder_info
}

// OrderInfoID returns the "order_info" edge ID in the mutation.
func (m *OrderEventMutation) OrderInfoID() (id datasource.UUID, exists bool) {
	if m.order_info != nil {
		return *m.order_info, true
	}
	return
}

// OrderInfoIDs returns the "order_info" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrderInfoID instead. It exists only for internal usage by the builders.
func (m *OrderEventMutation) OrderInfoIDs() (ids []datasource.UUID) {
	if id := m.order_info; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrderInfo resets all changes to the "order_info" edge.
func (m *OrderEventMutation) ResetOrderInfo() {
	m.order_info = nil
	m.clearedorder_info = false
}

// Where appends a list predicates to the OrderEventMutation builder.
func (m *OrderEventMutation) Where(ps ...predicate.OrderEvent) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *OrderEventMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (OrderEvent).
func (m *OrderEventMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrderEventMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.content != nil {
		fields = append(fields, orderevent.FieldContent)
	}
	if m.occurrence != nil {
		fields = append(fields, orderevent.FieldOccurrence)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrderEventMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case orderevent.FieldContent:
		return m.Content()
	case orderevent.FieldOccurrence:
		return m.Occurrence()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrderEventMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case orderevent.FieldContent:
		return m.OldContent(ctx)
	case orderevent.FieldOccurrence:
		return m.OldOccurrence(ctx)
	}
	return nil, fmt.Errorf("unknown OrderEvent field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderEventMutation) SetField(name string, value ent.Value) error {
	switch name {
	case orderevent.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case orderevent.FieldOccurrence:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOccurrence(v)
		return nil
	}
	return fmt.Errorf("unknown OrderEvent field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrderEventMutation) AddedFields() []string {
	var fields []string
	if m.addoccurrence != nil {
		fields = append(fields, orderevent.FieldOccurrence)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrderEventMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case orderevent.FieldOccurrence:
		return m.AddedOccurrence()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderEventMutation) AddField(name string, value ent.Value) error {
	switch name {
	case orderevent.FieldOccurrence:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOccurrence(v)
		return nil
	}
	return fmt.Errorf("unknown OrderEvent numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrderEventMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrderEventMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrderEventMutation) ClearField(name string) error {
	return fmt.Errorf("unknown OrderEvent nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrderEventMutation) ResetField(name string) error {
	switch name {
	case orderevent.FieldContent:
		m.ResetContent()
		return nil
	case orderevent.FieldOccurrence:
		m.ResetOccurrence()
		return nil
	}
	return fmt.Errorf("unknown OrderEvent field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrderEventMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.order_info != nil {
		edges = append(edges, orderevent.EdgeOrderInfo)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrderEventMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case orderevent.EdgeOrderInfo:
		if id := m.order_info; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrderEventMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrderEventMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrderEventMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedorder_info {
		edges = append(edges, orderevent.EdgeOrderInfo)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrderEventMutation) EdgeCleared(name string) bool {
	switch name {
	case orderevent.EdgeOrderInfo:
		return m.clearedorder_info
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrderEventMutation) ClearEdge(name string) error {
	switch name {
	case orderevent.EdgeOrderInfo:
		m.ClearOrderInfo()
		return nil
	}
	return fmt.Errorf("unknown OrderEvent unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrderEventMutation) ResetEdge(name string) error {
	switch name {
	case orderevent.EdgeOrderInfo:
		m.ResetOrderInfo()
		return nil
	}
	return fmt.Errorf("unknown OrderEvent edge %s", name)
}

// OrderInfoMutation represents an operation that mutates the OrderInfo nodes in the graph.
type OrderInfoMutation struct {
	config
	op                           Op
	typ                          string
	id                           *datasource.UUID
	version                      *int64
	addversion                   *int64
	created_by                   *datasource.UUID
	addcreated_by                *datasource.UUID
	created_at                   *int64
	addcreated_at                *int64
	updated_by                   *datasource.UUID
	addupdated_by                *datasource.UUID
	updated_at                   *int64
	addupdated_at                *int64
	remote_start_id              *int64
	addremote_start_id           *int64
	transaction_id               *string
	authorization_id             *string
	customer_id                  *string
	caller_order_id              *string
	total_electricity            *float64
	addtotal_electricity         *float64
	charge_start_electricity     *float64
	addcharge_start_electricity  *float64
	charge_final_electricity     *float64
	addcharge_final_electricity  *float64
	sharp_electricity            *float64
	addsharp_electricity         *float64
	peak_electricity             *float64
	addpeak_electricity          *float64
	flat_electricity             *float64
	addflat_electricity          *float64
	valley_electricity           *float64
	addvalley_electricity        *float64
	stop_reason_code             *int32
	addstop_reason_code          *int32
	offline                      *bool
	price_scheme_release_id      *int64
	addprice_scheme_release_id   *int64
	order_start_time             *int64
	addorder_start_time          *int64
	order_final_time             *int64
	addorder_final_time          *int64
	charge_start_time            *int64
	addcharge_start_time         *int64
	charge_final_time            *int64
	addcharge_final_time         *int64
	intellect_id                 *int64
	addintellect_id              *int64
	station_id                   *datasource.UUID
	addstation_id                *datasource.UUID
	operator_id                  *datasource.UUID
	addoperator_id               *datasource.UUID
	clearedFields                map[string]struct{}
	connector                    *datasource.UUID
	clearedconnector             bool
	equipment                    *datasource.UUID
	clearedequipment             bool
	order_event                  map[datasource.UUID]struct{}
	removedorder_event           map[datasource.UUID]struct{}
	clearedorder_event           bool
	smart_charging_effect        *datasource.UUID
	clearedsmart_charging_effect bool
	done                         bool
	oldValue                     func(context.Context) (*OrderInfo, error)
	predicates                   []predicate.OrderInfo
}

var _ ent.Mutation = (*OrderInfoMutation)(nil)

// orderinfoOption allows management of the mutation configuration using functional options.
type orderinfoOption func(*OrderInfoMutation)

// newOrderInfoMutation creates new mutation for the OrderInfo entity.
func newOrderInfoMutation(c config, op Op, opts ...orderinfoOption) *OrderInfoMutation {
	m := &OrderInfoMutation{
		config:        c,
		op:            op,
		typ:           TypeOrderInfo,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrderInfoID sets the ID field of the mutation.
func withOrderInfoID(id datasource.UUID) orderinfoOption {
	return func(m *OrderInfoMutation) {
		var (
			err   error
			once  sync.Once
			value *OrderInfo
		)
		m.oldValue = func(ctx context.Context) (*OrderInfo, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OrderInfo.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrderInfo sets the old OrderInfo of the mutation.
func withOrderInfo(node *OrderInfo) orderinfoOption {
	return func(m *OrderInfoMutation) {
		m.oldValue = func(context.Context) (*OrderInfo, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrderInfoMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrderInfoMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of OrderInfo entities.
func (m *OrderInfoMutation) SetID(id datasource.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrderInfoMutation) ID() (id datasource.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrderInfoMutation) IDs(ctx context.Context) ([]datasource.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []datasource.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OrderInfo.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetVersion sets the "version" field.
func (m *OrderInfoMutation) SetVersion(i int64) {
	m.version = &i
	m.addversion = nil
}

// Version returns the value of the "version" field in the mutation.
func (m *OrderInfoMutation) Version() (r int64, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the OrderInfo entity.
// If the OrderInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderInfoMutation) OldVersion(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// AddVersion adds i to the "version" field.
func (m *OrderInfoMutation) AddVersion(i int64) {
	if m.addversion != nil {
		*m.addversion += i
	} else {
		m.addversion = &i
	}
}

// AddedVersion returns the value that was added to the "version" field in this mutation.
func (m *OrderInfoMutation) AddedVersion() (r int64, exists bool) {
	v := m.addversion
	if v == nil {
		return
	}
	return *v, true
}

// ResetVersion resets all changes to the "version" field.
func (m *OrderInfoMutation) ResetVersion() {
	m.version = nil
	m.addversion = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *OrderInfoMutation) SetCreatedBy(d datasource.UUID) {
	m.created_by = &d
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *OrderInfoMutation) CreatedBy() (r datasource.UUID, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the OrderInfo entity.
// If the OrderInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderInfoMutation) OldCreatedBy(ctx context.Context) (v datasource.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds d to the "created_by" field.
func (m *OrderInfoMutation) AddCreatedBy(d datasource.UUID) {
	if m.addcreated_by != nil {
		*m.addcreated_by += d
	} else {
		m.addcreated_by = &d
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *OrderInfoMutation) AddedCreatedBy() (r datasource.UUID, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *OrderInfoMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *OrderInfoMutation) SetCreatedAt(i int64) {
	m.created_at = &i
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OrderInfoMutation) CreatedAt() (r int64, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the OrderInfo entity.
// If the OrderInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderInfoMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to the "created_at" field.
func (m *OrderInfoMutation) AddCreatedAt(i int64) {
	if m.addcreated_at != nil {
		*m.addcreated_at += i
	} else {
		m.addcreated_at = &i
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *OrderInfoMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OrderInfoMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *OrderInfoMutation) SetUpdatedBy(d datasource.UUID) {
	m.updated_by = &d
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *OrderInfoMutation) UpdatedBy() (r datasource.UUID, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the OrderInfo entity.
// If the OrderInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderInfoMutation) OldUpdatedBy(ctx context.Context) (v datasource.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds d to the "updated_by" field.
func (m *OrderInfoMutation) AddUpdatedBy(d datasource.UUID) {
	if m.addupdated_by != nil {
		*m.addupdated_by += d
	} else {
		m.addupdated_by = &d
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *OrderInfoMutation) AddedUpdatedBy() (r datasource.UUID, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *OrderInfoMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *OrderInfoMutation) SetUpdatedAt(i int64) {
	m.updated_at = &i
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *OrderInfoMutation) UpdatedAt() (r int64, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the OrderInfo entity.
// If the OrderInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderInfoMutation) OldUpdatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to the "updated_at" field.
func (m *OrderInfoMutation) AddUpdatedAt(i int64) {
	if m.addupdated_at != nil {
		*m.addupdated_at += i
	} else {
		m.addupdated_at = &i
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *OrderInfoMutation) AddedUpdatedAt() (r int64, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *OrderInfoMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetRemoteStartID sets the "remote_start_id" field.
func (m *OrderInfoMutation) SetRemoteStartID(i int64) {
	m.remote_start_id = &i
	m.addremote_start_id = nil
}

// RemoteStartID returns the value of the "remote_start_id" field in the mutation.
func (m *OrderInfoMutation) RemoteStartID() (r int64, exists bool) {
	v := m.remote_start_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRemoteStartID returns the old "remote_start_id" field's value of the OrderInfo entity.
// If the OrderInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderInfoMutation) OldRemoteStartID(ctx context.Context) (v *int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemoteStartID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemoteStartID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemoteStartID: %w", err)
	}
	return oldValue.RemoteStartID, nil
}

// AddRemoteStartID adds i to the "remote_start_id" field.
func (m *OrderInfoMutation) AddRemoteStartID(i int64) {
	if m.addremote_start_id != nil {
		*m.addremote_start_id += i
	} else {
		m.addremote_start_id = &i
	}
}

// AddedRemoteStartID returns the value that was added to the "remote_start_id" field in this mutation.
func (m *OrderInfoMutation) AddedRemoteStartID() (r int64, exists bool) {
	v := m.addremote_start_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearRemoteStartID clears the value of the "remote_start_id" field.
func (m *OrderInfoMutation) ClearRemoteStartID() {
	m.remote_start_id = nil
	m.addremote_start_id = nil
	m.clearedFields[orderinfo.FieldRemoteStartID] = struct{}{}
}

// RemoteStartIDCleared returns if the "remote_start_id" field was cleared in this mutation.
func (m *OrderInfoMutation) RemoteStartIDCleared() bool {
	_, ok := m.clearedFields[orderinfo.FieldRemoteStartID]
	return ok
}

// ResetRemoteStartID resets all changes to the "remote_start_id" field.
func (m *OrderInfoMutation) ResetRemoteStartID() {
	m.remote_start_id = nil
	m.addremote_start_id = nil
	delete(m.clearedFields, orderinfo.FieldRemoteStartID)
}

// SetTransactionID sets the "transaction_id" field.
func (m *OrderInfoMutation) SetTransactionID(s string) {
	m.transaction_id = &s
}

// TransactionID returns the value of the "transaction_id" field in the mutation.
func (m *OrderInfoMutation) TransactionID() (r string, exists bool) {
	v := m.transaction_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTransactionID returns the old "transaction_id" field's value of the OrderInfo entity.
// If the OrderInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderInfoMutation) OldTransactionID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTransactionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTransactionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTransactionID: %w", err)
	}
	return oldValue.TransactionID, nil
}

// ResetTransactionID resets all changes to the "transaction_id" field.
func (m *OrderInfoMutation) ResetTransactionID() {
	m.transaction_id = nil
}

// SetAuthorizationID sets the "authorization_id" field.
func (m *OrderInfoMutation) SetAuthorizationID(s string) {
	m.authorization_id = &s
}

// AuthorizationID returns the value of the "authorization_id" field in the mutation.
func (m *OrderInfoMutation) AuthorizationID() (r string, exists bool) {
	v := m.authorization_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthorizationID returns the old "authorization_id" field's value of the OrderInfo entity.
// If the OrderInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderInfoMutation) OldAuthorizationID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthorizationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthorizationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthorizationID: %w", err)
	}
	return oldValue.AuthorizationID, nil
}

// ClearAuthorizationID clears the value of the "authorization_id" field.
func (m *OrderInfoMutation) ClearAuthorizationID() {
	m.authorization_id = nil
	m.clearedFields[orderinfo.FieldAuthorizationID] = struct{}{}
}

// AuthorizationIDCleared returns if the "authorization_id" field was cleared in this mutation.
func (m *OrderInfoMutation) AuthorizationIDCleared() bool {
	_, ok := m.clearedFields[orderinfo.FieldAuthorizationID]
	return ok
}

// ResetAuthorizationID resets all changes to the "authorization_id" field.
func (m *OrderInfoMutation) ResetAuthorizationID() {
	m.authorization_id = nil
	delete(m.clearedFields, orderinfo.FieldAuthorizationID)
}

// SetCustomerID sets the "customer_id" field.
func (m *OrderInfoMutation) SetCustomerID(s string) {
	m.customer_id = &s
}

// CustomerID returns the value of the "customer_id" field in the mutation.
func (m *OrderInfoMutation) CustomerID() (r string, exists bool) {
	v := m.customer_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCustomerID returns the old "customer_id" field's value of the OrderInfo entity.
// If the OrderInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderInfoMutation) OldCustomerID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCustomerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCustomerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCustomerID: %w", err)
	}
	return oldValue.CustomerID, nil
}

// ClearCustomerID clears the value of the "customer_id" field.
func (m *OrderInfoMutation) ClearCustomerID() {
	m.customer_id = nil
	m.clearedFields[orderinfo.FieldCustomerID] = struct{}{}
}

// CustomerIDCleared returns if the "customer_id" field was cleared in this mutation.
func (m *OrderInfoMutation) CustomerIDCleared() bool {
	_, ok := m.clearedFields[orderinfo.FieldCustomerID]
	return ok
}

// ResetCustomerID resets all changes to the "customer_id" field.
func (m *OrderInfoMutation) ResetCustomerID() {
	m.customer_id = nil
	delete(m.clearedFields, orderinfo.FieldCustomerID)
}

// SetCallerOrderID sets the "caller_order_id" field.
func (m *OrderInfoMutation) SetCallerOrderID(s string) {
	m.caller_order_id = &s
}

// CallerOrderID returns the value of the "caller_order_id" field in the mutation.
func (m *OrderInfoMutation) CallerOrderID() (r string, exists bool) {
	v := m.caller_order_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCallerOrderID returns the old "caller_order_id" field's value of the OrderInfo entity.
// If the OrderInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderInfoMutation) OldCallerOrderID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCallerOrderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCallerOrderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCallerOrderID: %w", err)
	}
	return oldValue.CallerOrderID, nil
}

// ClearCallerOrderID clears the value of the "caller_order_id" field.
func (m *OrderInfoMutation) ClearCallerOrderID() {
	m.caller_order_id = nil
	m.clearedFields[orderinfo.FieldCallerOrderID] = struct{}{}
}

// CallerOrderIDCleared returns if the "caller_order_id" field was cleared in this mutation.
func (m *OrderInfoMutation) CallerOrderIDCleared() bool {
	_, ok := m.clearedFields[orderinfo.FieldCallerOrderID]
	return ok
}

// ResetCallerOrderID resets all changes to the "caller_order_id" field.
func (m *OrderInfoMutation) ResetCallerOrderID() {
	m.caller_order_id = nil
	delete(m.clearedFields, orderinfo.FieldCallerOrderID)
}

// SetTotalElectricity sets the "total_electricity" field.
func (m *OrderInfoMutation) SetTotalElectricity(f float64) {
	m.total_electricity = &f
	m.addtotal_electricity = nil
}

// TotalElectricity returns the value of the "total_electricity" field in the mutation.
func (m *OrderInfoMutation) TotalElectricity() (r float64, exists bool) {
	v := m.total_electricity
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalElectricity returns the old "total_electricity" field's value of the OrderInfo entity.
// If the OrderInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderInfoMutation) OldTotalElectricity(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalElectricity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalElectricity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalElectricity: %w", err)
	}
	return oldValue.TotalElectricity, nil
}

// AddTotalElectricity adds f to the "total_electricity" field.
func (m *OrderInfoMutation) AddTotalElectricity(f float64) {
	if m.addtotal_electricity != nil {
		*m.addtotal_electricity += f
	} else {
		m.addtotal_electricity = &f
	}
}

// AddedTotalElectricity returns the value that was added to the "total_electricity" field in this mutation.
func (m *OrderInfoMutation) AddedTotalElectricity() (r float64, exists bool) {
	v := m.addtotal_electricity
	if v == nil {
		return
	}
	return *v, true
}

// ClearTotalElectricity clears the value of the "total_electricity" field.
func (m *OrderInfoMutation) ClearTotalElectricity() {
	m.total_electricity = nil
	m.addtotal_electricity = nil
	m.clearedFields[orderinfo.FieldTotalElectricity] = struct{}{}
}

// TotalElectricityCleared returns if the "total_electricity" field was cleared in this mutation.
func (m *OrderInfoMutation) TotalElectricityCleared() bool {
	_, ok := m.clearedFields[orderinfo.FieldTotalElectricity]
	return ok
}

// ResetTotalElectricity resets all changes to the "total_electricity" field.
func (m *OrderInfoMutation) ResetTotalElectricity() {
	m.total_electricity = nil
	m.addtotal_electricity = nil
	delete(m.clearedFields, orderinfo.FieldTotalElectricity)
}

// SetChargeStartElectricity sets the "charge_start_electricity" field.
func (m *OrderInfoMutation) SetChargeStartElectricity(f float64) {
	m.charge_start_electricity = &f
	m.addcharge_start_electricity = nil
}

// ChargeStartElectricity returns the value of the "charge_start_electricity" field in the mutation.
func (m *OrderInfoMutation) ChargeStartElectricity() (r float64, exists bool) {
	v := m.charge_start_electricity
	if v == nil {
		return
	}
	return *v, true
}

// OldChargeStartElectricity returns the old "charge_start_electricity" field's value of the OrderInfo entity.
// If the OrderInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderInfoMutation) OldChargeStartElectricity(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChargeStartElectricity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChargeStartElectricity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChargeStartElectricity: %w", err)
	}
	return oldValue.ChargeStartElectricity, nil
}

// AddChargeStartElectricity adds f to the "charge_start_electricity" field.
func (m *OrderInfoMutation) AddChargeStartElectricity(f float64) {
	if m.addcharge_start_electricity != nil {
		*m.addcharge_start_electricity += f
	} else {
		m.addcharge_start_electricity = &f
	}
}

// AddedChargeStartElectricity returns the value that was added to the "charge_start_electricity" field in this mutation.
func (m *OrderInfoMutation) AddedChargeStartElectricity() (r float64, exists bool) {
	v := m.addcharge_start_electricity
	if v == nil {
		return
	}
	return *v, true
}

// ClearChargeStartElectricity clears the value of the "charge_start_electricity" field.
func (m *OrderInfoMutation) ClearChargeStartElectricity() {
	m.charge_start_electricity = nil
	m.addcharge_start_electricity = nil
	m.clearedFields[orderinfo.FieldChargeStartElectricity] = struct{}{}
}

// ChargeStartElectricityCleared returns if the "charge_start_electricity" field was cleared in this mutation.
func (m *OrderInfoMutation) ChargeStartElectricityCleared() bool {
	_, ok := m.clearedFields[orderinfo.FieldChargeStartElectricity]
	return ok
}

// ResetChargeStartElectricity resets all changes to the "charge_start_electricity" field.
func (m *OrderInfoMutation) ResetChargeStartElectricity() {
	m.charge_start_electricity = nil
	m.addcharge_start_electricity = nil
	delete(m.clearedFields, orderinfo.FieldChargeStartElectricity)
}

// SetChargeFinalElectricity sets the "charge_final_electricity" field.
func (m *OrderInfoMutation) SetChargeFinalElectricity(f float64) {
	m.charge_final_electricity = &f
	m.addcharge_final_electricity = nil
}

// ChargeFinalElectricity returns the value of the "charge_final_electricity" field in the mutation.
func (m *OrderInfoMutation) ChargeFinalElectricity() (r float64, exists bool) {
	v := m.charge_final_electricity
	if v == nil {
		return
	}
	return *v, true
}

// OldChargeFinalElectricity returns the old "charge_final_electricity" field's value of the OrderInfo entity.
// If the OrderInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderInfoMutation) OldChargeFinalElectricity(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChargeFinalElectricity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChargeFinalElectricity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChargeFinalElectricity: %w", err)
	}
	return oldValue.ChargeFinalElectricity, nil
}

// AddChargeFinalElectricity adds f to the "charge_final_electricity" field.
func (m *OrderInfoMutation) AddChargeFinalElectricity(f float64) {
	if m.addcharge_final_electricity != nil {
		*m.addcharge_final_electricity += f
	} else {
		m.addcharge_final_electricity = &f
	}
}

// AddedChargeFinalElectricity returns the value that was added to the "charge_final_electricity" field in this mutation.
func (m *OrderInfoMutation) AddedChargeFinalElectricity() (r float64, exists bool) {
	v := m.addcharge_final_electricity
	if v == nil {
		return
	}
	return *v, true
}

// ClearChargeFinalElectricity clears the value of the "charge_final_electricity" field.
func (m *OrderInfoMutation) ClearChargeFinalElectricity() {
	m.charge_final_electricity = nil
	m.addcharge_final_electricity = nil
	m.clearedFields[orderinfo.FieldChargeFinalElectricity] = struct{}{}
}

// ChargeFinalElectricityCleared returns if the "charge_final_electricity" field was cleared in this mutation.
func (m *OrderInfoMutation) ChargeFinalElectricityCleared() bool {
	_, ok := m.clearedFields[orderinfo.FieldChargeFinalElectricity]
	return ok
}

// ResetChargeFinalElectricity resets all changes to the "charge_final_electricity" field.
func (m *OrderInfoMutation) ResetChargeFinalElectricity() {
	m.charge_final_electricity = nil
	m.addcharge_final_electricity = nil
	delete(m.clearedFields, orderinfo.FieldChargeFinalElectricity)
}

// SetSharpElectricity sets the "sharp_electricity" field.
func (m *OrderInfoMutation) SetSharpElectricity(f float64) {
	m.sharp_electricity = &f
	m.addsharp_electricity = nil
}

// SharpElectricity returns the value of the "sharp_electricity" field in the mutation.
func (m *OrderInfoMutation) SharpElectricity() (r float64, exists bool) {
	v := m.sharp_electricity
	if v == nil {
		return
	}
	return *v, true
}

// OldSharpElectricity returns the old "sharp_electricity" field's value of the OrderInfo entity.
// If the OrderInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderInfoMutation) OldSharpElectricity(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSharpElectricity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSharpElectricity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSharpElectricity: %w", err)
	}
	return oldValue.SharpElectricity, nil
}

// AddSharpElectricity adds f to the "sharp_electricity" field.
func (m *OrderInfoMutation) AddSharpElectricity(f float64) {
	if m.addsharp_electricity != nil {
		*m.addsharp_electricity += f
	} else {
		m.addsharp_electricity = &f
	}
}

// AddedSharpElectricity returns the value that was added to the "sharp_electricity" field in this mutation.
func (m *OrderInfoMutation) AddedSharpElectricity() (r float64, exists bool) {
	v := m.addsharp_electricity
	if v == nil {
		return
	}
	return *v, true
}

// ClearSharpElectricity clears the value of the "sharp_electricity" field.
func (m *OrderInfoMutation) ClearSharpElectricity() {
	m.sharp_electricity = nil
	m.addsharp_electricity = nil
	m.clearedFields[orderinfo.FieldSharpElectricity] = struct{}{}
}

// SharpElectricityCleared returns if the "sharp_electricity" field was cleared in this mutation.
func (m *OrderInfoMutation) SharpElectricityCleared() bool {
	_, ok := m.clearedFields[orderinfo.FieldSharpElectricity]
	return ok
}

// ResetSharpElectricity resets all changes to the "sharp_electricity" field.
func (m *OrderInfoMutation) ResetSharpElectricity() {
	m.sharp_electricity = nil
	m.addsharp_electricity = nil
	delete(m.clearedFields, orderinfo.FieldSharpElectricity)
}

// SetPeakElectricity sets the "peak_electricity" field.
func (m *OrderInfoMutation) SetPeakElectricity(f float64) {
	m.peak_electricity = &f
	m.addpeak_electricity = nil
}

// PeakElectricity returns the value of the "peak_electricity" field in the mutation.
func (m *OrderInfoMutation) PeakElectricity() (r float64, exists bool) {
	v := m.peak_electricity
	if v == nil {
		return
	}
	return *v, true
}

// OldPeakElectricity returns the old "peak_electricity" field's value of the OrderInfo entity.
// If the OrderInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderInfoMutation) OldPeakElectricity(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPeakElectricity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPeakElectricity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPeakElectricity: %w", err)
	}
	return oldValue.PeakElectricity, nil
}

// AddPeakElectricity adds f to the "peak_electricity" field.
func (m *OrderInfoMutation) AddPeakElectricity(f float64) {
	if m.addpeak_electricity != nil {
		*m.addpeak_electricity += f
	} else {
		m.addpeak_electricity = &f
	}
}

// AddedPeakElectricity returns the value that was added to the "peak_electricity" field in this mutation.
func (m *OrderInfoMutation) AddedPeakElectricity() (r float64, exists bool) {
	v := m.addpeak_electricity
	if v == nil {
		return
	}
	return *v, true
}

// ClearPeakElectricity clears the value of the "peak_electricity" field.
func (m *OrderInfoMutation) ClearPeakElectricity() {
	m.peak_electricity = nil
	m.addpeak_electricity = nil
	m.clearedFields[orderinfo.FieldPeakElectricity] = struct{}{}
}

// PeakElectricityCleared returns if the "peak_electricity" field was cleared in this mutation.
func (m *OrderInfoMutation) PeakElectricityCleared() bool {
	_, ok := m.clearedFields[orderinfo.FieldPeakElectricity]
	return ok
}

// ResetPeakElectricity resets all changes to the "peak_electricity" field.
func (m *OrderInfoMutation) ResetPeakElectricity() {
	m.peak_electricity = nil
	m.addpeak_electricity = nil
	delete(m.clearedFields, orderinfo.FieldPeakElectricity)
}

// SetFlatElectricity sets the "flat_electricity" field.
func (m *OrderInfoMutation) SetFlatElectricity(f float64) {
	m.flat_electricity = &f
	m.addflat_electricity = nil
}

// FlatElectricity returns the value of the "flat_electricity" field in the mutation.
func (m *OrderInfoMutation) FlatElectricity() (r float64, exists bool) {
	v := m.flat_electricity
	if v == nil {
		return
	}
	return *v, true
}

// OldFlatElectricity returns the old "flat_electricity" field's value of the OrderInfo entity.
// If the OrderInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderInfoMutation) OldFlatElectricity(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFlatElectricity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFlatElectricity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFlatElectricity: %w", err)
	}
	return oldValue.FlatElectricity, nil
}

// AddFlatElectricity adds f to the "flat_electricity" field.
func (m *OrderInfoMutation) AddFlatElectricity(f float64) {
	if m.addflat_electricity != nil {
		*m.addflat_electricity += f
	} else {
		m.addflat_electricity = &f
	}
}

// AddedFlatElectricity returns the value that was added to the "flat_electricity" field in this mutation.
func (m *OrderInfoMutation) AddedFlatElectricity() (r float64, exists bool) {
	v := m.addflat_electricity
	if v == nil {
		return
	}
	return *v, true
}

// ClearFlatElectricity clears the value of the "flat_electricity" field.
func (m *OrderInfoMutation) ClearFlatElectricity() {
	m.flat_electricity = nil
	m.addflat_electricity = nil
	m.clearedFields[orderinfo.FieldFlatElectricity] = struct{}{}
}

// FlatElectricityCleared returns if the "flat_electricity" field was cleared in this mutation.
func (m *OrderInfoMutation) FlatElectricityCleared() bool {
	_, ok := m.clearedFields[orderinfo.FieldFlatElectricity]
	return ok
}

// ResetFlatElectricity resets all changes to the "flat_electricity" field.
func (m *OrderInfoMutation) ResetFlatElectricity() {
	m.flat_electricity = nil
	m.addflat_electricity = nil
	delete(m.clearedFields, orderinfo.FieldFlatElectricity)
}

// SetValleyElectricity sets the "valley_electricity" field.
func (m *OrderInfoMutation) SetValleyElectricity(f float64) {
	m.valley_electricity = &f
	m.addvalley_electricity = nil
}

// ValleyElectricity returns the value of the "valley_electricity" field in the mutation.
func (m *OrderInfoMutation) ValleyElectricity() (r float64, exists bool) {
	v := m.valley_electricity
	if v == nil {
		return
	}
	return *v, true
}

// OldValleyElectricity returns the old "valley_electricity" field's value of the OrderInfo entity.
// If the OrderInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderInfoMutation) OldValleyElectricity(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValleyElectricity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValleyElectricity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValleyElectricity: %w", err)
	}
	return oldValue.ValleyElectricity, nil
}

// AddValleyElectricity adds f to the "valley_electricity" field.
func (m *OrderInfoMutation) AddValleyElectricity(f float64) {
	if m.addvalley_electricity != nil {
		*m.addvalley_electricity += f
	} else {
		m.addvalley_electricity = &f
	}
}

// AddedValleyElectricity returns the value that was added to the "valley_electricity" field in this mutation.
func (m *OrderInfoMutation) AddedValleyElectricity() (r float64, exists bool) {
	v := m.addvalley_electricity
	if v == nil {
		return
	}
	return *v, true
}

// ClearValleyElectricity clears the value of the "valley_electricity" field.
func (m *OrderInfoMutation) ClearValleyElectricity() {
	m.valley_electricity = nil
	m.addvalley_electricity = nil
	m.clearedFields[orderinfo.FieldValleyElectricity] = struct{}{}
}

// ValleyElectricityCleared returns if the "valley_electricity" field was cleared in this mutation.
func (m *OrderInfoMutation) ValleyElectricityCleared() bool {
	_, ok := m.clearedFields[orderinfo.FieldValleyElectricity]
	return ok
}

// ResetValleyElectricity resets all changes to the "valley_electricity" field.
func (m *OrderInfoMutation) ResetValleyElectricity() {
	m.valley_electricity = nil
	m.addvalley_electricity = nil
	delete(m.clearedFields, orderinfo.FieldValleyElectricity)
}

// SetStopReasonCode sets the "stop_reason_code" field.
func (m *OrderInfoMutation) SetStopReasonCode(i int32) {
	m.stop_reason_code = &i
	m.addstop_reason_code = nil
}

// StopReasonCode returns the value of the "stop_reason_code" field in the mutation.
func (m *OrderInfoMutation) StopReasonCode() (r int32, exists bool) {
	v := m.stop_reason_code
	if v == nil {
		return
	}
	return *v, true
}

// OldStopReasonCode returns the old "stop_reason_code" field's value of the OrderInfo entity.
// If the OrderInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderInfoMutation) OldStopReasonCode(ctx context.Context) (v *int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStopReasonCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStopReasonCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStopReasonCode: %w", err)
	}
	return oldValue.StopReasonCode, nil
}

// AddStopReasonCode adds i to the "stop_reason_code" field.
func (m *OrderInfoMutation) AddStopReasonCode(i int32) {
	if m.addstop_reason_code != nil {
		*m.addstop_reason_code += i
	} else {
		m.addstop_reason_code = &i
	}
}

// AddedStopReasonCode returns the value that was added to the "stop_reason_code" field in this mutation.
func (m *OrderInfoMutation) AddedStopReasonCode() (r int32, exists bool) {
	v := m.addstop_reason_code
	if v == nil {
		return
	}
	return *v, true
}

// ClearStopReasonCode clears the value of the "stop_reason_code" field.
func (m *OrderInfoMutation) ClearStopReasonCode() {
	m.stop_reason_code = nil
	m.addstop_reason_code = nil
	m.clearedFields[orderinfo.FieldStopReasonCode] = struct{}{}
}

// StopReasonCodeCleared returns if the "stop_reason_code" field was cleared in this mutation.
func (m *OrderInfoMutation) StopReasonCodeCleared() bool {
	_, ok := m.clearedFields[orderinfo.FieldStopReasonCode]
	return ok
}

// ResetStopReasonCode resets all changes to the "stop_reason_code" field.
func (m *OrderInfoMutation) ResetStopReasonCode() {
	m.stop_reason_code = nil
	m.addstop_reason_code = nil
	delete(m.clearedFields, orderinfo.FieldStopReasonCode)
}

// SetOffline sets the "offline" field.
func (m *OrderInfoMutation) SetOffline(b bool) {
	m.offline = &b
}

// Offline returns the value of the "offline" field in the mutation.
func (m *OrderInfoMutation) Offline() (r bool, exists bool) {
	v := m.offline
	if v == nil {
		return
	}
	return *v, true
}

// OldOffline returns the old "offline" field's value of the OrderInfo entity.
// If the OrderInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderInfoMutation) OldOffline(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOffline is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOffline requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOffline: %w", err)
	}
	return oldValue.Offline, nil
}

// ResetOffline resets all changes to the "offline" field.
func (m *OrderInfoMutation) ResetOffline() {
	m.offline = nil
}

// SetPriceSchemeReleaseID sets the "price_scheme_release_id" field.
func (m *OrderInfoMutation) SetPriceSchemeReleaseID(i int64) {
	m.price_scheme_release_id = &i
	m.addprice_scheme_release_id = nil
}

// PriceSchemeReleaseID returns the value of the "price_scheme_release_id" field in the mutation.
func (m *OrderInfoMutation) PriceSchemeReleaseID() (r int64, exists bool) {
	v := m.price_scheme_release_id
	if v == nil {
		return
	}
	return *v, true
}

// OldPriceSchemeReleaseID returns the old "price_scheme_release_id" field's value of the OrderInfo entity.
// If the OrderInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderInfoMutation) OldPriceSchemeReleaseID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPriceSchemeReleaseID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPriceSchemeReleaseID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPriceSchemeReleaseID: %w", err)
	}
	return oldValue.PriceSchemeReleaseID, nil
}

// AddPriceSchemeReleaseID adds i to the "price_scheme_release_id" field.
func (m *OrderInfoMutation) AddPriceSchemeReleaseID(i int64) {
	if m.addprice_scheme_release_id != nil {
		*m.addprice_scheme_release_id += i
	} else {
		m.addprice_scheme_release_id = &i
	}
}

// AddedPriceSchemeReleaseID returns the value that was added to the "price_scheme_release_id" field in this mutation.
func (m *OrderInfoMutation) AddedPriceSchemeReleaseID() (r int64, exists bool) {
	v := m.addprice_scheme_release_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetPriceSchemeReleaseID resets all changes to the "price_scheme_release_id" field.
func (m *OrderInfoMutation) ResetPriceSchemeReleaseID() {
	m.price_scheme_release_id = nil
	m.addprice_scheme_release_id = nil
}

// SetOrderStartTime sets the "order_start_time" field.
func (m *OrderInfoMutation) SetOrderStartTime(i int64) {
	m.order_start_time = &i
	m.addorder_start_time = nil
}

// OrderStartTime returns the value of the "order_start_time" field in the mutation.
func (m *OrderInfoMutation) OrderStartTime() (r int64, exists bool) {
	v := m.order_start_time
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderStartTime returns the old "order_start_time" field's value of the OrderInfo entity.
// If the OrderInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderInfoMutation) OldOrderStartTime(ctx context.Context) (v *int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderStartTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderStartTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderStartTime: %w", err)
	}
	return oldValue.OrderStartTime, nil
}

// AddOrderStartTime adds i to the "order_start_time" field.
func (m *OrderInfoMutation) AddOrderStartTime(i int64) {
	if m.addorder_start_time != nil {
		*m.addorder_start_time += i
	} else {
		m.addorder_start_time = &i
	}
}

// AddedOrderStartTime returns the value that was added to the "order_start_time" field in this mutation.
func (m *OrderInfoMutation) AddedOrderStartTime() (r int64, exists bool) {
	v := m.addorder_start_time
	if v == nil {
		return
	}
	return *v, true
}

// ClearOrderStartTime clears the value of the "order_start_time" field.
func (m *OrderInfoMutation) ClearOrderStartTime() {
	m.order_start_time = nil
	m.addorder_start_time = nil
	m.clearedFields[orderinfo.FieldOrderStartTime] = struct{}{}
}

// OrderStartTimeCleared returns if the "order_start_time" field was cleared in this mutation.
func (m *OrderInfoMutation) OrderStartTimeCleared() bool {
	_, ok := m.clearedFields[orderinfo.FieldOrderStartTime]
	return ok
}

// ResetOrderStartTime resets all changes to the "order_start_time" field.
func (m *OrderInfoMutation) ResetOrderStartTime() {
	m.order_start_time = nil
	m.addorder_start_time = nil
	delete(m.clearedFields, orderinfo.FieldOrderStartTime)
}

// SetOrderFinalTime sets the "order_final_time" field.
func (m *OrderInfoMutation) SetOrderFinalTime(i int64) {
	m.order_final_time = &i
	m.addorder_final_time = nil
}

// OrderFinalTime returns the value of the "order_final_time" field in the mutation.
func (m *OrderInfoMutation) OrderFinalTime() (r int64, exists bool) {
	v := m.order_final_time
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderFinalTime returns the old "order_final_time" field's value of the OrderInfo entity.
// If the OrderInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderInfoMutation) OldOrderFinalTime(ctx context.Context) (v *int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderFinalTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderFinalTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderFinalTime: %w", err)
	}
	return oldValue.OrderFinalTime, nil
}

// AddOrderFinalTime adds i to the "order_final_time" field.
func (m *OrderInfoMutation) AddOrderFinalTime(i int64) {
	if m.addorder_final_time != nil {
		*m.addorder_final_time += i
	} else {
		m.addorder_final_time = &i
	}
}

// AddedOrderFinalTime returns the value that was added to the "order_final_time" field in this mutation.
func (m *OrderInfoMutation) AddedOrderFinalTime() (r int64, exists bool) {
	v := m.addorder_final_time
	if v == nil {
		return
	}
	return *v, true
}

// ClearOrderFinalTime clears the value of the "order_final_time" field.
func (m *OrderInfoMutation) ClearOrderFinalTime() {
	m.order_final_time = nil
	m.addorder_final_time = nil
	m.clearedFields[orderinfo.FieldOrderFinalTime] = struct{}{}
}

// OrderFinalTimeCleared returns if the "order_final_time" field was cleared in this mutation.
func (m *OrderInfoMutation) OrderFinalTimeCleared() bool {
	_, ok := m.clearedFields[orderinfo.FieldOrderFinalTime]
	return ok
}

// ResetOrderFinalTime resets all changes to the "order_final_time" field.
func (m *OrderInfoMutation) ResetOrderFinalTime() {
	m.order_final_time = nil
	m.addorder_final_time = nil
	delete(m.clearedFields, orderinfo.FieldOrderFinalTime)
}

// SetChargeStartTime sets the "charge_start_time" field.
func (m *OrderInfoMutation) SetChargeStartTime(i int64) {
	m.charge_start_time = &i
	m.addcharge_start_time = nil
}

// ChargeStartTime returns the value of the "charge_start_time" field in the mutation.
func (m *OrderInfoMutation) ChargeStartTime() (r int64, exists bool) {
	v := m.charge_start_time
	if v == nil {
		return
	}
	return *v, true
}

// OldChargeStartTime returns the old "charge_start_time" field's value of the OrderInfo entity.
// If the OrderInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderInfoMutation) OldChargeStartTime(ctx context.Context) (v *int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChargeStartTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChargeStartTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChargeStartTime: %w", err)
	}
	return oldValue.ChargeStartTime, nil
}

// AddChargeStartTime adds i to the "charge_start_time" field.
func (m *OrderInfoMutation) AddChargeStartTime(i int64) {
	if m.addcharge_start_time != nil {
		*m.addcharge_start_time += i
	} else {
		m.addcharge_start_time = &i
	}
}

// AddedChargeStartTime returns the value that was added to the "charge_start_time" field in this mutation.
func (m *OrderInfoMutation) AddedChargeStartTime() (r int64, exists bool) {
	v := m.addcharge_start_time
	if v == nil {
		return
	}
	return *v, true
}

// ClearChargeStartTime clears the value of the "charge_start_time" field.
func (m *OrderInfoMutation) ClearChargeStartTime() {
	m.charge_start_time = nil
	m.addcharge_start_time = nil
	m.clearedFields[orderinfo.FieldChargeStartTime] = struct{}{}
}

// ChargeStartTimeCleared returns if the "charge_start_time" field was cleared in this mutation.
func (m *OrderInfoMutation) ChargeStartTimeCleared() bool {
	_, ok := m.clearedFields[orderinfo.FieldChargeStartTime]
	return ok
}

// ResetChargeStartTime resets all changes to the "charge_start_time" field.
func (m *OrderInfoMutation) ResetChargeStartTime() {
	m.charge_start_time = nil
	m.addcharge_start_time = nil
	delete(m.clearedFields, orderinfo.FieldChargeStartTime)
}

// SetChargeFinalTime sets the "charge_final_time" field.
func (m *OrderInfoMutation) SetChargeFinalTime(i int64) {
	m.charge_final_time = &i
	m.addcharge_final_time = nil
}

// ChargeFinalTime returns the value of the "charge_final_time" field in the mutation.
func (m *OrderInfoMutation) ChargeFinalTime() (r int64, exists bool) {
	v := m.charge_final_time
	if v == nil {
		return
	}
	return *v, true
}

// OldChargeFinalTime returns the old "charge_final_time" field's value of the OrderInfo entity.
// If the OrderInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderInfoMutation) OldChargeFinalTime(ctx context.Context) (v *int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChargeFinalTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChargeFinalTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChargeFinalTime: %w", err)
	}
	return oldValue.ChargeFinalTime, nil
}

// AddChargeFinalTime adds i to the "charge_final_time" field.
func (m *OrderInfoMutation) AddChargeFinalTime(i int64) {
	if m.addcharge_final_time != nil {
		*m.addcharge_final_time += i
	} else {
		m.addcharge_final_time = &i
	}
}

// AddedChargeFinalTime returns the value that was added to the "charge_final_time" field in this mutation.
func (m *OrderInfoMutation) AddedChargeFinalTime() (r int64, exists bool) {
	v := m.addcharge_final_time
	if v == nil {
		return
	}
	return *v, true
}

// ClearChargeFinalTime clears the value of the "charge_final_time" field.
func (m *OrderInfoMutation) ClearChargeFinalTime() {
	m.charge_final_time = nil
	m.addcharge_final_time = nil
	m.clearedFields[orderinfo.FieldChargeFinalTime] = struct{}{}
}

// ChargeFinalTimeCleared returns if the "charge_final_time" field was cleared in this mutation.
func (m *OrderInfoMutation) ChargeFinalTimeCleared() bool {
	_, ok := m.clearedFields[orderinfo.FieldChargeFinalTime]
	return ok
}

// ResetChargeFinalTime resets all changes to the "charge_final_time" field.
func (m *OrderInfoMutation) ResetChargeFinalTime() {
	m.charge_final_time = nil
	m.addcharge_final_time = nil
	delete(m.clearedFields, orderinfo.FieldChargeFinalTime)
}

// SetIntellectID sets the "intellect_id" field.
func (m *OrderInfoMutation) SetIntellectID(i int64) {
	m.intellect_id = &i
	m.addintellect_id = nil
}

// IntellectID returns the value of the "intellect_id" field in the mutation.
func (m *OrderInfoMutation) IntellectID() (r int64, exists bool) {
	v := m.intellect_id
	if v == nil {
		return
	}
	return *v, true
}

// OldIntellectID returns the old "intellect_id" field's value of the OrderInfo entity.
// If the OrderInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderInfoMutation) OldIntellectID(ctx context.Context) (v *int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIntellectID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIntellectID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIntellectID: %w", err)
	}
	return oldValue.IntellectID, nil
}

// AddIntellectID adds i to the "intellect_id" field.
func (m *OrderInfoMutation) AddIntellectID(i int64) {
	if m.addintellect_id != nil {
		*m.addintellect_id += i
	} else {
		m.addintellect_id = &i
	}
}

// AddedIntellectID returns the value that was added to the "intellect_id" field in this mutation.
func (m *OrderInfoMutation) AddedIntellectID() (r int64, exists bool) {
	v := m.addintellect_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearIntellectID clears the value of the "intellect_id" field.
func (m *OrderInfoMutation) ClearIntellectID() {
	m.intellect_id = nil
	m.addintellect_id = nil
	m.clearedFields[orderinfo.FieldIntellectID] = struct{}{}
}

// IntellectIDCleared returns if the "intellect_id" field was cleared in this mutation.
func (m *OrderInfoMutation) IntellectIDCleared() bool {
	_, ok := m.clearedFields[orderinfo.FieldIntellectID]
	return ok
}

// ResetIntellectID resets all changes to the "intellect_id" field.
func (m *OrderInfoMutation) ResetIntellectID() {
	m.intellect_id = nil
	m.addintellect_id = nil
	delete(m.clearedFields, orderinfo.FieldIntellectID)
}

// SetStationID sets the "station_id" field.
func (m *OrderInfoMutation) SetStationID(d datasource.UUID) {
	m.station_id = &d
	m.addstation_id = nil
}

// StationID returns the value of the "station_id" field in the mutation.
func (m *OrderInfoMutation) StationID() (r datasource.UUID, exists bool) {
	v := m.station_id
	if v == nil {
		return
	}
	return *v, true
}

// OldStationID returns the old "station_id" field's value of the OrderInfo entity.
// If the OrderInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderInfoMutation) OldStationID(ctx context.Context) (v *datasource.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStationID: %w", err)
	}
	return oldValue.StationID, nil
}

// AddStationID adds d to the "station_id" field.
func (m *OrderInfoMutation) AddStationID(d datasource.UUID) {
	if m.addstation_id != nil {
		*m.addstation_id += d
	} else {
		m.addstation_id = &d
	}
}

// AddedStationID returns the value that was added to the "station_id" field in this mutation.
func (m *OrderInfoMutation) AddedStationID() (r datasource.UUID, exists bool) {
	v := m.addstation_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearStationID clears the value of the "station_id" field.
func (m *OrderInfoMutation) ClearStationID() {
	m.station_id = nil
	m.addstation_id = nil
	m.clearedFields[orderinfo.FieldStationID] = struct{}{}
}

// StationIDCleared returns if the "station_id" field was cleared in this mutation.
func (m *OrderInfoMutation) StationIDCleared() bool {
	_, ok := m.clearedFields[orderinfo.FieldStationID]
	return ok
}

// ResetStationID resets all changes to the "station_id" field.
func (m *OrderInfoMutation) ResetStationID() {
	m.station_id = nil
	m.addstation_id = nil
	delete(m.clearedFields, orderinfo.FieldStationID)
}

// SetOperatorID sets the "operator_id" field.
func (m *OrderInfoMutation) SetOperatorID(d datasource.UUID) {
	m.operator_id = &d
	m.addoperator_id = nil
}

// OperatorID returns the value of the "operator_id" field in the mutation.
func (m *OrderInfoMutation) OperatorID() (r datasource.UUID, exists bool) {
	v := m.operator_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOperatorID returns the old "operator_id" field's value of the OrderInfo entity.
// If the OrderInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderInfoMutation) OldOperatorID(ctx context.Context) (v *datasource.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperatorID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperatorID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperatorID: %w", err)
	}
	return oldValue.OperatorID, nil
}

// AddOperatorID adds d to the "operator_id" field.
func (m *OrderInfoMutation) AddOperatorID(d datasource.UUID) {
	if m.addoperator_id != nil {
		*m.addoperator_id += d
	} else {
		m.addoperator_id = &d
	}
}

// AddedOperatorID returns the value that was added to the "operator_id" field in this mutation.
func (m *OrderInfoMutation) AddedOperatorID() (r datasource.UUID, exists bool) {
	v := m.addoperator_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearOperatorID clears the value of the "operator_id" field.
func (m *OrderInfoMutation) ClearOperatorID() {
	m.operator_id = nil
	m.addoperator_id = nil
	m.clearedFields[orderinfo.FieldOperatorID] = struct{}{}
}

// OperatorIDCleared returns if the "operator_id" field was cleared in this mutation.
func (m *OrderInfoMutation) OperatorIDCleared() bool {
	_, ok := m.clearedFields[orderinfo.FieldOperatorID]
	return ok
}

// ResetOperatorID resets all changes to the "operator_id" field.
func (m *OrderInfoMutation) ResetOperatorID() {
	m.operator_id = nil
	m.addoperator_id = nil
	delete(m.clearedFields, orderinfo.FieldOperatorID)
}

// SetConnectorID sets the "connector" edge to the Connector entity by id.
func (m *OrderInfoMutation) SetConnectorID(id datasource.UUID) {
	m.connector = &id
}

// ClearConnector clears the "connector" edge to the Connector entity.
func (m *OrderInfoMutation) ClearConnector() {
	m.clearedconnector = true
}

// ConnectorCleared reports if the "connector" edge to the Connector entity was cleared.
func (m *OrderInfoMutation) ConnectorCleared() bool {
	return m.clearedconnector
}

// ConnectorID returns the "connector" edge ID in the mutation.
func (m *OrderInfoMutation) ConnectorID() (id datasource.UUID, exists bool) {
	if m.connector != nil {
		return *m.connector, true
	}
	return
}

// ConnectorIDs returns the "connector" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ConnectorID instead. It exists only for internal usage by the builders.
func (m *OrderInfoMutation) ConnectorIDs() (ids []datasource.UUID) {
	if id := m.connector; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetConnector resets all changes to the "connector" edge.
func (m *OrderInfoMutation) ResetConnector() {
	m.connector = nil
	m.clearedconnector = false
}

// SetEquipmentID sets the "equipment" edge to the Equipment entity by id.
func (m *OrderInfoMutation) SetEquipmentID(id datasource.UUID) {
	m.equipment = &id
}

// ClearEquipment clears the "equipment" edge to the Equipment entity.
func (m *OrderInfoMutation) ClearEquipment() {
	m.clearedequipment = true
}

// EquipmentCleared reports if the "equipment" edge to the Equipment entity was cleared.
func (m *OrderInfoMutation) EquipmentCleared() bool {
	return m.clearedequipment
}

// EquipmentID returns the "equipment" edge ID in the mutation.
func (m *OrderInfoMutation) EquipmentID() (id datasource.UUID, exists bool) {
	if m.equipment != nil {
		return *m.equipment, true
	}
	return
}

// EquipmentIDs returns the "equipment" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EquipmentID instead. It exists only for internal usage by the builders.
func (m *OrderInfoMutation) EquipmentIDs() (ids []datasource.UUID) {
	if id := m.equipment; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEquipment resets all changes to the "equipment" edge.
func (m *OrderInfoMutation) ResetEquipment() {
	m.equipment = nil
	m.clearedequipment = false
}

// AddOrderEventIDs adds the "order_event" edge to the OrderEvent entity by ids.
func (m *OrderInfoMutation) AddOrderEventIDs(ids ...datasource.UUID) {
	if m.order_event == nil {
		m.order_event = make(map[datasource.UUID]struct{})
	}
	for i := range ids {
		m.order_event[ids[i]] = struct{}{}
	}
}

// ClearOrderEvent clears the "order_event" edge to the OrderEvent entity.
func (m *OrderInfoMutation) ClearOrderEvent() {
	m.clearedorder_event = true
}

// OrderEventCleared reports if the "order_event" edge to the OrderEvent entity was cleared.
func (m *OrderInfoMutation) OrderEventCleared() bool {
	return m.clearedorder_event
}

// RemoveOrderEventIDs removes the "order_event" edge to the OrderEvent entity by IDs.
func (m *OrderInfoMutation) RemoveOrderEventIDs(ids ...datasource.UUID) {
	if m.removedorder_event == nil {
		m.removedorder_event = make(map[datasource.UUID]struct{})
	}
	for i := range ids {
		delete(m.order_event, ids[i])
		m.removedorder_event[ids[i]] = struct{}{}
	}
}

// RemovedOrderEvent returns the removed IDs of the "order_event" edge to the OrderEvent entity.
func (m *OrderInfoMutation) RemovedOrderEventIDs() (ids []datasource.UUID) {
	for id := range m.removedorder_event {
		ids = append(ids, id)
	}
	return
}

// OrderEventIDs returns the "order_event" edge IDs in the mutation.
func (m *OrderInfoMutation) OrderEventIDs() (ids []datasource.UUID) {
	for id := range m.order_event {
		ids = append(ids, id)
	}
	return
}

// ResetOrderEvent resets all changes to the "order_event" edge.
func (m *OrderInfoMutation) ResetOrderEvent() {
	m.order_event = nil
	m.clearedorder_event = false
	m.removedorder_event = nil
}

// SetSmartChargingEffectID sets the "smart_charging_effect" edge to the SmartChargingEffect entity by id.
func (m *OrderInfoMutation) SetSmartChargingEffectID(id datasource.UUID) {
	m.smart_charging_effect = &id
}

// ClearSmartChargingEffect clears the "smart_charging_effect" edge to the SmartChargingEffect entity.
func (m *OrderInfoMutation) ClearSmartChargingEffect() {
	m.clearedsmart_charging_effect = true
}

// SmartChargingEffectCleared reports if the "smart_charging_effect" edge to the SmartChargingEffect entity was cleared.
func (m *OrderInfoMutation) SmartChargingEffectCleared() bool {
	return m.clearedsmart_charging_effect
}

// SmartChargingEffectID returns the "smart_charging_effect" edge ID in the mutation.
func (m *OrderInfoMutation) SmartChargingEffectID() (id datasource.UUID, exists bool) {
	if m.smart_charging_effect != nil {
		return *m.smart_charging_effect, true
	}
	return
}

// SmartChargingEffectIDs returns the "smart_charging_effect" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SmartChargingEffectID instead. It exists only for internal usage by the builders.
func (m *OrderInfoMutation) SmartChargingEffectIDs() (ids []datasource.UUID) {
	if id := m.smart_charging_effect; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSmartChargingEffect resets all changes to the "smart_charging_effect" edge.
func (m *OrderInfoMutation) ResetSmartChargingEffect() {
	m.smart_charging_effect = nil
	m.clearedsmart_charging_effect = false
}

// Where appends a list predicates to the OrderInfoMutation builder.
func (m *OrderInfoMutation) Where(ps ...predicate.OrderInfo) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *OrderInfoMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (OrderInfo).
func (m *OrderInfoMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrderInfoMutation) Fields() []string {
	fields := make([]string, 0, 27)
	if m.version != nil {
		fields = append(fields, orderinfo.FieldVersion)
	}
	if m.created_by != nil {
		fields = append(fields, orderinfo.FieldCreatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, orderinfo.FieldCreatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, orderinfo.FieldUpdatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, orderinfo.FieldUpdatedAt)
	}
	if m.remote_start_id != nil {
		fields = append(fields, orderinfo.FieldRemoteStartID)
	}
	if m.transaction_id != nil {
		fields = append(fields, orderinfo.FieldTransactionID)
	}
	if m.authorization_id != nil {
		fields = append(fields, orderinfo.FieldAuthorizationID)
	}
	if m.customer_id != nil {
		fields = append(fields, orderinfo.FieldCustomerID)
	}
	if m.caller_order_id != nil {
		fields = append(fields, orderinfo.FieldCallerOrderID)
	}
	if m.total_electricity != nil {
		fields = append(fields, orderinfo.FieldTotalElectricity)
	}
	if m.charge_start_electricity != nil {
		fields = append(fields, orderinfo.FieldChargeStartElectricity)
	}
	if m.charge_final_electricity != nil {
		fields = append(fields, orderinfo.FieldChargeFinalElectricity)
	}
	if m.sharp_electricity != nil {
		fields = append(fields, orderinfo.FieldSharpElectricity)
	}
	if m.peak_electricity != nil {
		fields = append(fields, orderinfo.FieldPeakElectricity)
	}
	if m.flat_electricity != nil {
		fields = append(fields, orderinfo.FieldFlatElectricity)
	}
	if m.valley_electricity != nil {
		fields = append(fields, orderinfo.FieldValleyElectricity)
	}
	if m.stop_reason_code != nil {
		fields = append(fields, orderinfo.FieldStopReasonCode)
	}
	if m.offline != nil {
		fields = append(fields, orderinfo.FieldOffline)
	}
	if m.price_scheme_release_id != nil {
		fields = append(fields, orderinfo.FieldPriceSchemeReleaseID)
	}
	if m.order_start_time != nil {
		fields = append(fields, orderinfo.FieldOrderStartTime)
	}
	if m.order_final_time != nil {
		fields = append(fields, orderinfo.FieldOrderFinalTime)
	}
	if m.charge_start_time != nil {
		fields = append(fields, orderinfo.FieldChargeStartTime)
	}
	if m.charge_final_time != nil {
		fields = append(fields, orderinfo.FieldChargeFinalTime)
	}
	if m.intellect_id != nil {
		fields = append(fields, orderinfo.FieldIntellectID)
	}
	if m.station_id != nil {
		fields = append(fields, orderinfo.FieldStationID)
	}
	if m.operator_id != nil {
		fields = append(fields, orderinfo.FieldOperatorID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrderInfoMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case orderinfo.FieldVersion:
		return m.Version()
	case orderinfo.FieldCreatedBy:
		return m.CreatedBy()
	case orderinfo.FieldCreatedAt:
		return m.CreatedAt()
	case orderinfo.FieldUpdatedBy:
		return m.UpdatedBy()
	case orderinfo.FieldUpdatedAt:
		return m.UpdatedAt()
	case orderinfo.FieldRemoteStartID:
		return m.RemoteStartID()
	case orderinfo.FieldTransactionID:
		return m.TransactionID()
	case orderinfo.FieldAuthorizationID:
		return m.AuthorizationID()
	case orderinfo.FieldCustomerID:
		return m.CustomerID()
	case orderinfo.FieldCallerOrderID:
		return m.CallerOrderID()
	case orderinfo.FieldTotalElectricity:
		return m.TotalElectricity()
	case orderinfo.FieldChargeStartElectricity:
		return m.ChargeStartElectricity()
	case orderinfo.FieldChargeFinalElectricity:
		return m.ChargeFinalElectricity()
	case orderinfo.FieldSharpElectricity:
		return m.SharpElectricity()
	case orderinfo.FieldPeakElectricity:
		return m.PeakElectricity()
	case orderinfo.FieldFlatElectricity:
		return m.FlatElectricity()
	case orderinfo.FieldValleyElectricity:
		return m.ValleyElectricity()
	case orderinfo.FieldStopReasonCode:
		return m.StopReasonCode()
	case orderinfo.FieldOffline:
		return m.Offline()
	case orderinfo.FieldPriceSchemeReleaseID:
		return m.PriceSchemeReleaseID()
	case orderinfo.FieldOrderStartTime:
		return m.OrderStartTime()
	case orderinfo.FieldOrderFinalTime:
		return m.OrderFinalTime()
	case orderinfo.FieldChargeStartTime:
		return m.ChargeStartTime()
	case orderinfo.FieldChargeFinalTime:
		return m.ChargeFinalTime()
	case orderinfo.FieldIntellectID:
		return m.IntellectID()
	case orderinfo.FieldStationID:
		return m.StationID()
	case orderinfo.FieldOperatorID:
		return m.OperatorID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrderInfoMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case orderinfo.FieldVersion:
		return m.OldVersion(ctx)
	case orderinfo.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case orderinfo.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case orderinfo.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case orderinfo.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case orderinfo.FieldRemoteStartID:
		return m.OldRemoteStartID(ctx)
	case orderinfo.FieldTransactionID:
		return m.OldTransactionID(ctx)
	case orderinfo.FieldAuthorizationID:
		return m.OldAuthorizationID(ctx)
	case orderinfo.FieldCustomerID:
		return m.OldCustomerID(ctx)
	case orderinfo.FieldCallerOrderID:
		return m.OldCallerOrderID(ctx)
	case orderinfo.FieldTotalElectricity:
		return m.OldTotalElectricity(ctx)
	case orderinfo.FieldChargeStartElectricity:
		return m.OldChargeStartElectricity(ctx)
	case orderinfo.FieldChargeFinalElectricity:
		return m.OldChargeFinalElectricity(ctx)
	case orderinfo.FieldSharpElectricity:
		return m.OldSharpElectricity(ctx)
	case orderinfo.FieldPeakElectricity:
		return m.OldPeakElectricity(ctx)
	case orderinfo.FieldFlatElectricity:
		return m.OldFlatElectricity(ctx)
	case orderinfo.FieldValleyElectricity:
		return m.OldValleyElectricity(ctx)
	case orderinfo.FieldStopReasonCode:
		return m.OldStopReasonCode(ctx)
	case orderinfo.FieldOffline:
		return m.OldOffline(ctx)
	case orderinfo.FieldPriceSchemeReleaseID:
		return m.OldPriceSchemeReleaseID(ctx)
	case orderinfo.FieldOrderStartTime:
		return m.OldOrderStartTime(ctx)
	case orderinfo.FieldOrderFinalTime:
		return m.OldOrderFinalTime(ctx)
	case orderinfo.FieldChargeStartTime:
		return m.OldChargeStartTime(ctx)
	case orderinfo.FieldChargeFinalTime:
		return m.OldChargeFinalTime(ctx)
	case orderinfo.FieldIntellectID:
		return m.OldIntellectID(ctx)
	case orderinfo.FieldStationID:
		return m.OldStationID(ctx)
	case orderinfo.FieldOperatorID:
		return m.OldOperatorID(ctx)
	}
	return nil, fmt.Errorf("unknown OrderInfo field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderInfoMutation) SetField(name string, value ent.Value) error {
	switch name {
	case orderinfo.FieldVersion:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case orderinfo.FieldCreatedBy:
		v, ok := value.(datasource.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case orderinfo.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case orderinfo.FieldUpdatedBy:
		v, ok := value.(datasource.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case orderinfo.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case orderinfo.FieldRemoteStartID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemoteStartID(v)
		return nil
	case orderinfo.FieldTransactionID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTransactionID(v)
		return nil
	case orderinfo.FieldAuthorizationID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthorizationID(v)
		return nil
	case orderinfo.FieldCustomerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCustomerID(v)
		return nil
	case orderinfo.FieldCallerOrderID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCallerOrderID(v)
		return nil
	case orderinfo.FieldTotalElectricity:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalElectricity(v)
		return nil
	case orderinfo.FieldChargeStartElectricity:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChargeStartElectricity(v)
		return nil
	case orderinfo.FieldChargeFinalElectricity:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChargeFinalElectricity(v)
		return nil
	case orderinfo.FieldSharpElectricity:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSharpElectricity(v)
		return nil
	case orderinfo.FieldPeakElectricity:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPeakElectricity(v)
		return nil
	case orderinfo.FieldFlatElectricity:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFlatElectricity(v)
		return nil
	case orderinfo.FieldValleyElectricity:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValleyElectricity(v)
		return nil
	case orderinfo.FieldStopReasonCode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStopReasonCode(v)
		return nil
	case orderinfo.FieldOffline:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOffline(v)
		return nil
	case orderinfo.FieldPriceSchemeReleaseID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPriceSchemeReleaseID(v)
		return nil
	case orderinfo.FieldOrderStartTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderStartTime(v)
		return nil
	case orderinfo.FieldOrderFinalTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderFinalTime(v)
		return nil
	case orderinfo.FieldChargeStartTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChargeStartTime(v)
		return nil
	case orderinfo.FieldChargeFinalTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChargeFinalTime(v)
		return nil
	case orderinfo.FieldIntellectID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIntellectID(v)
		return nil
	case orderinfo.FieldStationID:
		v, ok := value.(datasource.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStationID(v)
		return nil
	case orderinfo.FieldOperatorID:
		v, ok := value.(datasource.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperatorID(v)
		return nil
	}
	return fmt.Errorf("unknown OrderInfo field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrderInfoMutation) AddedFields() []string {
	var fields []string
	if m.addversion != nil {
		fields = append(fields, orderinfo.FieldVersion)
	}
	if m.addcreated_by != nil {
		fields = append(fields, orderinfo.FieldCreatedBy)
	}
	if m.addcreated_at != nil {
		fields = append(fields, orderinfo.FieldCreatedAt)
	}
	if m.addupdated_by != nil {
		fields = append(fields, orderinfo.FieldUpdatedBy)
	}
	if m.addupdated_at != nil {
		fields = append(fields, orderinfo.FieldUpdatedAt)
	}
	if m.addremote_start_id != nil {
		fields = append(fields, orderinfo.FieldRemoteStartID)
	}
	if m.addtotal_electricity != nil {
		fields = append(fields, orderinfo.FieldTotalElectricity)
	}
	if m.addcharge_start_electricity != nil {
		fields = append(fields, orderinfo.FieldChargeStartElectricity)
	}
	if m.addcharge_final_electricity != nil {
		fields = append(fields, orderinfo.FieldChargeFinalElectricity)
	}
	if m.addsharp_electricity != nil {
		fields = append(fields, orderinfo.FieldSharpElectricity)
	}
	if m.addpeak_electricity != nil {
		fields = append(fields, orderinfo.FieldPeakElectricity)
	}
	if m.addflat_electricity != nil {
		fields = append(fields, orderinfo.FieldFlatElectricity)
	}
	if m.addvalley_electricity != nil {
		fields = append(fields, orderinfo.FieldValleyElectricity)
	}
	if m.addstop_reason_code != nil {
		fields = append(fields, orderinfo.FieldStopReasonCode)
	}
	if m.addprice_scheme_release_id != nil {
		fields = append(fields, orderinfo.FieldPriceSchemeReleaseID)
	}
	if m.addorder_start_time != nil {
		fields = append(fields, orderinfo.FieldOrderStartTime)
	}
	if m.addorder_final_time != nil {
		fields = append(fields, orderinfo.FieldOrderFinalTime)
	}
	if m.addcharge_start_time != nil {
		fields = append(fields, orderinfo.FieldChargeStartTime)
	}
	if m.addcharge_final_time != nil {
		fields = append(fields, orderinfo.FieldChargeFinalTime)
	}
	if m.addintellect_id != nil {
		fields = append(fields, orderinfo.FieldIntellectID)
	}
	if m.addstation_id != nil {
		fields = append(fields, orderinfo.FieldStationID)
	}
	if m.addoperator_id != nil {
		fields = append(fields, orderinfo.FieldOperatorID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrderInfoMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case orderinfo.FieldVersion:
		return m.AddedVersion()
	case orderinfo.FieldCreatedBy:
		return m.AddedCreatedBy()
	case orderinfo.FieldCreatedAt:
		return m.AddedCreatedAt()
	case orderinfo.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case orderinfo.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case orderinfo.FieldRemoteStartID:
		return m.AddedRemoteStartID()
	case orderinfo.FieldTotalElectricity:
		return m.AddedTotalElectricity()
	case orderinfo.FieldChargeStartElectricity:
		return m.AddedChargeStartElectricity()
	case orderinfo.FieldChargeFinalElectricity:
		return m.AddedChargeFinalElectricity()
	case orderinfo.FieldSharpElectricity:
		return m.AddedSharpElectricity()
	case orderinfo.FieldPeakElectricity:
		return m.AddedPeakElectricity()
	case orderinfo.FieldFlatElectricity:
		return m.AddedFlatElectricity()
	case orderinfo.FieldValleyElectricity:
		return m.AddedValleyElectricity()
	case orderinfo.FieldStopReasonCode:
		return m.AddedStopReasonCode()
	case orderinfo.FieldPriceSchemeReleaseID:
		return m.AddedPriceSchemeReleaseID()
	case orderinfo.FieldOrderStartTime:
		return m.AddedOrderStartTime()
	case orderinfo.FieldOrderFinalTime:
		return m.AddedOrderFinalTime()
	case orderinfo.FieldChargeStartTime:
		return m.AddedChargeStartTime()
	case orderinfo.FieldChargeFinalTime:
		return m.AddedChargeFinalTime()
	case orderinfo.FieldIntellectID:
		return m.AddedIntellectID()
	case orderinfo.FieldStationID:
		return m.AddedStationID()
	case orderinfo.FieldOperatorID:
		return m.AddedOperatorID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderInfoMutation) AddField(name string, value ent.Value) error {
	switch name {
	case orderinfo.FieldVersion:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVersion(v)
		return nil
	case orderinfo.FieldCreatedBy:
		v, ok := value.(datasource.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case orderinfo.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case orderinfo.FieldUpdatedBy:
		v, ok := value.(datasource.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case orderinfo.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case orderinfo.FieldRemoteStartID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRemoteStartID(v)
		return nil
	case orderinfo.FieldTotalElectricity:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalElectricity(v)
		return nil
	case orderinfo.FieldChargeStartElectricity:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddChargeStartElectricity(v)
		return nil
	case orderinfo.FieldChargeFinalElectricity:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddChargeFinalElectricity(v)
		return nil
	case orderinfo.FieldSharpElectricity:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSharpElectricity(v)
		return nil
	case orderinfo.FieldPeakElectricity:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPeakElectricity(v)
		return nil
	case orderinfo.FieldFlatElectricity:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFlatElectricity(v)
		return nil
	case orderinfo.FieldValleyElectricity:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddValleyElectricity(v)
		return nil
	case orderinfo.FieldStopReasonCode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStopReasonCode(v)
		return nil
	case orderinfo.FieldPriceSchemeReleaseID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPriceSchemeReleaseID(v)
		return nil
	case orderinfo.FieldOrderStartTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrderStartTime(v)
		return nil
	case orderinfo.FieldOrderFinalTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrderFinalTime(v)
		return nil
	case orderinfo.FieldChargeStartTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddChargeStartTime(v)
		return nil
	case orderinfo.FieldChargeFinalTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddChargeFinalTime(v)
		return nil
	case orderinfo.FieldIntellectID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIntellectID(v)
		return nil
	case orderinfo.FieldStationID:
		v, ok := value.(datasource.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStationID(v)
		return nil
	case orderinfo.FieldOperatorID:
		v, ok := value.(datasource.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOperatorID(v)
		return nil
	}
	return fmt.Errorf("unknown OrderInfo numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrderInfoMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(orderinfo.FieldRemoteStartID) {
		fields = append(fields, orderinfo.FieldRemoteStartID)
	}
	if m.FieldCleared(orderinfo.FieldAuthorizationID) {
		fields = append(fields, orderinfo.FieldAuthorizationID)
	}
	if m.FieldCleared(orderinfo.FieldCustomerID) {
		fields = append(fields, orderinfo.FieldCustomerID)
	}
	if m.FieldCleared(orderinfo.FieldCallerOrderID) {
		fields = append(fields, orderinfo.FieldCallerOrderID)
	}
	if m.FieldCleared(orderinfo.FieldTotalElectricity) {
		fields = append(fields, orderinfo.FieldTotalElectricity)
	}
	if m.FieldCleared(orderinfo.FieldChargeStartElectricity) {
		fields = append(fields, orderinfo.FieldChargeStartElectricity)
	}
	if m.FieldCleared(orderinfo.FieldChargeFinalElectricity) {
		fields = append(fields, orderinfo.FieldChargeFinalElectricity)
	}
	if m.FieldCleared(orderinfo.FieldSharpElectricity) {
		fields = append(fields, orderinfo.FieldSharpElectricity)
	}
	if m.FieldCleared(orderinfo.FieldPeakElectricity) {
		fields = append(fields, orderinfo.FieldPeakElectricity)
	}
	if m.FieldCleared(orderinfo.FieldFlatElectricity) {
		fields = append(fields, orderinfo.FieldFlatElectricity)
	}
	if m.FieldCleared(orderinfo.FieldValleyElectricity) {
		fields = append(fields, orderinfo.FieldValleyElectricity)
	}
	if m.FieldCleared(orderinfo.FieldStopReasonCode) {
		fields = append(fields, orderinfo.FieldStopReasonCode)
	}
	if m.FieldCleared(orderinfo.FieldOrderStartTime) {
		fields = append(fields, orderinfo.FieldOrderStartTime)
	}
	if m.FieldCleared(orderinfo.FieldOrderFinalTime) {
		fields = append(fields, orderinfo.FieldOrderFinalTime)
	}
	if m.FieldCleared(orderinfo.FieldChargeStartTime) {
		fields = append(fields, orderinfo.FieldChargeStartTime)
	}
	if m.FieldCleared(orderinfo.FieldChargeFinalTime) {
		fields = append(fields, orderinfo.FieldChargeFinalTime)
	}
	if m.FieldCleared(orderinfo.FieldIntellectID) {
		fields = append(fields, orderinfo.FieldIntellectID)
	}
	if m.FieldCleared(orderinfo.FieldStationID) {
		fields = append(fields, orderinfo.FieldStationID)
	}
	if m.FieldCleared(orderinfo.FieldOperatorID) {
		fields = append(fields, orderinfo.FieldOperatorID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrderInfoMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrderInfoMutation) ClearField(name string) error {
	switch name {
	case orderinfo.FieldRemoteStartID:
		m.ClearRemoteStartID()
		return nil
	case orderinfo.FieldAuthorizationID:
		m.ClearAuthorizationID()
		return nil
	case orderinfo.FieldCustomerID:
		m.ClearCustomerID()
		return nil
	case orderinfo.FieldCallerOrderID:
		m.ClearCallerOrderID()
		return nil
	case orderinfo.FieldTotalElectricity:
		m.ClearTotalElectricity()
		return nil
	case orderinfo.FieldChargeStartElectricity:
		m.ClearChargeStartElectricity()
		return nil
	case orderinfo.FieldChargeFinalElectricity:
		m.ClearChargeFinalElectricity()
		return nil
	case orderinfo.FieldSharpElectricity:
		m.ClearSharpElectricity()
		return nil
	case orderinfo.FieldPeakElectricity:
		m.ClearPeakElectricity()
		return nil
	case orderinfo.FieldFlatElectricity:
		m.ClearFlatElectricity()
		return nil
	case orderinfo.FieldValleyElectricity:
		m.ClearValleyElectricity()
		return nil
	case orderinfo.FieldStopReasonCode:
		m.ClearStopReasonCode()
		return nil
	case orderinfo.FieldOrderStartTime:
		m.ClearOrderStartTime()
		return nil
	case orderinfo.FieldOrderFinalTime:
		m.ClearOrderFinalTime()
		return nil
	case orderinfo.FieldChargeStartTime:
		m.ClearChargeStartTime()
		return nil
	case orderinfo.FieldChargeFinalTime:
		m.ClearChargeFinalTime()
		return nil
	case orderinfo.FieldIntellectID:
		m.ClearIntellectID()
		return nil
	case orderinfo.FieldStationID:
		m.ClearStationID()
		return nil
	case orderinfo.FieldOperatorID:
		m.ClearOperatorID()
		return nil
	}
	return fmt.Errorf("unknown OrderInfo nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrderInfoMutation) ResetField(name string) error {
	switch name {
	case orderinfo.FieldVersion:
		m.ResetVersion()
		return nil
	case orderinfo.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case orderinfo.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case orderinfo.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case orderinfo.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case orderinfo.FieldRemoteStartID:
		m.ResetRemoteStartID()
		return nil
	case orderinfo.FieldTransactionID:
		m.ResetTransactionID()
		return nil
	case orderinfo.FieldAuthorizationID:
		m.ResetAuthorizationID()
		return nil
	case orderinfo.FieldCustomerID:
		m.ResetCustomerID()
		return nil
	case orderinfo.FieldCallerOrderID:
		m.ResetCallerOrderID()
		return nil
	case orderinfo.FieldTotalElectricity:
		m.ResetTotalElectricity()
		return nil
	case orderinfo.FieldChargeStartElectricity:
		m.ResetChargeStartElectricity()
		return nil
	case orderinfo.FieldChargeFinalElectricity:
		m.ResetChargeFinalElectricity()
		return nil
	case orderinfo.FieldSharpElectricity:
		m.ResetSharpElectricity()
		return nil
	case orderinfo.FieldPeakElectricity:
		m.ResetPeakElectricity()
		return nil
	case orderinfo.FieldFlatElectricity:
		m.ResetFlatElectricity()
		return nil
	case orderinfo.FieldValleyElectricity:
		m.ResetValleyElectricity()
		return nil
	case orderinfo.FieldStopReasonCode:
		m.ResetStopReasonCode()
		return nil
	case orderinfo.FieldOffline:
		m.ResetOffline()
		return nil
	case orderinfo.FieldPriceSchemeReleaseID:
		m.ResetPriceSchemeReleaseID()
		return nil
	case orderinfo.FieldOrderStartTime:
		m.ResetOrderStartTime()
		return nil
	case orderinfo.FieldOrderFinalTime:
		m.ResetOrderFinalTime()
		return nil
	case orderinfo.FieldChargeStartTime:
		m.ResetChargeStartTime()
		return nil
	case orderinfo.FieldChargeFinalTime:
		m.ResetChargeFinalTime()
		return nil
	case orderinfo.FieldIntellectID:
		m.ResetIntellectID()
		return nil
	case orderinfo.FieldStationID:
		m.ResetStationID()
		return nil
	case orderinfo.FieldOperatorID:
		m.ResetOperatorID()
		return nil
	}
	return fmt.Errorf("unknown OrderInfo field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrderInfoMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.connector != nil {
		edges = append(edges, orderinfo.EdgeConnector)
	}
	if m.equipment != nil {
		edges = append(edges, orderinfo.EdgeEquipment)
	}
	if m.order_event != nil {
		edges = append(edges, orderinfo.EdgeOrderEvent)
	}
	if m.smart_charging_effect != nil {
		edges = append(edges, orderinfo.EdgeSmartChargingEffect)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrderInfoMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case orderinfo.EdgeConnector:
		if id := m.connector; id != nil {
			return []ent.Value{*id}
		}
	case orderinfo.EdgeEquipment:
		if id := m.equipment; id != nil {
			return []ent.Value{*id}
		}
	case orderinfo.EdgeOrderEvent:
		ids := make([]ent.Value, 0, len(m.order_event))
		for id := range m.order_event {
			ids = append(ids, id)
		}
		return ids
	case orderinfo.EdgeSmartChargingEffect:
		if id := m.smart_charging_effect; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrderInfoMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedorder_event != nil {
		edges = append(edges, orderinfo.EdgeOrderEvent)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrderInfoMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case orderinfo.EdgeOrderEvent:
		ids := make([]ent.Value, 0, len(m.removedorder_event))
		for id := range m.removedorder_event {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrderInfoMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedconnector {
		edges = append(edges, orderinfo.EdgeConnector)
	}
	if m.clearedequipment {
		edges = append(edges, orderinfo.EdgeEquipment)
	}
	if m.clearedorder_event {
		edges = append(edges, orderinfo.EdgeOrderEvent)
	}
	if m.clearedsmart_charging_effect {
		edges = append(edges, orderinfo.EdgeSmartChargingEffect)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrderInfoMutation) EdgeCleared(name string) bool {
	switch name {
	case orderinfo.EdgeConnector:
		return m.clearedconnector
	case orderinfo.EdgeEquipment:
		return m.clearedequipment
	case orderinfo.EdgeOrderEvent:
		return m.clearedorder_event
	case orderinfo.EdgeSmartChargingEffect:
		return m.clearedsmart_charging_effect
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrderInfoMutation) ClearEdge(name string) error {
	switch name {
	case orderinfo.EdgeConnector:
		m.ClearConnector()
		return nil
	case orderinfo.EdgeEquipment:
		m.ClearEquipment()
		return nil
	case orderinfo.EdgeSmartChargingEffect:
		m.ClearSmartChargingEffect()
		return nil
	}
	return fmt.Errorf("unknown OrderInfo unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrderInfoMutation) ResetEdge(name string) error {
	switch name {
	case orderinfo.EdgeConnector:
		m.ResetConnector()
		return nil
	case orderinfo.EdgeEquipment:
		m.ResetEquipment()
		return nil
	case orderinfo.EdgeOrderEvent:
		m.ResetOrderEvent()
		return nil
	case orderinfo.EdgeSmartChargingEffect:
		m.ResetSmartChargingEffect()
		return nil
	}
	return fmt.Errorf("unknown OrderInfo edge %s", name)
}

// ReservationMutation represents an operation that mutates the Reservation nodes in the graph.
type ReservationMutation struct {
	config
	op                    Op
	typ                   string
	id                    *datasource.UUID
	version               *int64
	addversion            *int64
	created_by            *datasource.UUID
	addcreated_by         *datasource.UUID
	created_at            *int64
	addcreated_at         *int64
	updated_by            *datasource.UUID
	addupdated_by         *datasource.UUID
	updated_at            *int64
	addupdated_at         *int64
	reservation_id        *int64
	addreservation_id     *int64
	authorization_mode    *int
	addauthorization_mode *int
	authorization_id      *string
	additional            *string
	customer_id           *string
	expired               *int64
	addexpired            *int64
	state                 *int
	addstate              *int
	clearedFields         map[string]struct{}
	equipment             *datasource.UUID
	clearedequipment      bool
	connector             *datasource.UUID
	clearedconnector      bool
	done                  bool
	oldValue              func(context.Context) (*Reservation, error)
	predicates            []predicate.Reservation
}

var _ ent.Mutation = (*ReservationMutation)(nil)

// reservationOption allows management of the mutation configuration using functional options.
type reservationOption func(*ReservationMutation)

// newReservationMutation creates new mutation for the Reservation entity.
func newReservationMutation(c config, op Op, opts ...reservationOption) *ReservationMutation {
	m := &ReservationMutation{
		config:        c,
		op:            op,
		typ:           TypeReservation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withReservationID sets the ID field of the mutation.
func withReservationID(id datasource.UUID) reservationOption {
	return func(m *ReservationMutation) {
		var (
			err   error
			once  sync.Once
			value *Reservation
		)
		m.oldValue = func(ctx context.Context) (*Reservation, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Reservation.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withReservation sets the old Reservation of the mutation.
func withReservation(node *Reservation) reservationOption {
	return func(m *ReservationMutation) {
		m.oldValue = func(context.Context) (*Reservation, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ReservationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ReservationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Reservation entities.
func (m *ReservationMutation) SetID(id datasource.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ReservationMutation) ID() (id datasource.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ReservationMutation) IDs(ctx context.Context) ([]datasource.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []datasource.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Reservation.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetVersion sets the "version" field.
func (m *ReservationMutation) SetVersion(i int64) {
	m.version = &i
	m.addversion = nil
}

// Version returns the value of the "version" field in the mutation.
func (m *ReservationMutation) Version() (r int64, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the Reservation entity.
// If the Reservation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReservationMutation) OldVersion(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// AddVersion adds i to the "version" field.
func (m *ReservationMutation) AddVersion(i int64) {
	if m.addversion != nil {
		*m.addversion += i
	} else {
		m.addversion = &i
	}
}

// AddedVersion returns the value that was added to the "version" field in this mutation.
func (m *ReservationMutation) AddedVersion() (r int64, exists bool) {
	v := m.addversion
	if v == nil {
		return
	}
	return *v, true
}

// ResetVersion resets all changes to the "version" field.
func (m *ReservationMutation) ResetVersion() {
	m.version = nil
	m.addversion = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *ReservationMutation) SetCreatedBy(d datasource.UUID) {
	m.created_by = &d
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *ReservationMutation) CreatedBy() (r datasource.UUID, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Reservation entity.
// If the Reservation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReservationMutation) OldCreatedBy(ctx context.Context) (v datasource.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds d to the "created_by" field.
func (m *ReservationMutation) AddCreatedBy(d datasource.UUID) {
	if m.addcreated_by != nil {
		*m.addcreated_by += d
	} else {
		m.addcreated_by = &d
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *ReservationMutation) AddedCreatedBy() (r datasource.UUID, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *ReservationMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ReservationMutation) SetCreatedAt(i int64) {
	m.created_at = &i
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ReservationMutation) CreatedAt() (r int64, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Reservation entity.
// If the Reservation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReservationMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to the "created_at" field.
func (m *ReservationMutation) AddCreatedAt(i int64) {
	if m.addcreated_at != nil {
		*m.addcreated_at += i
	} else {
		m.addcreated_at = &i
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *ReservationMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ReservationMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *ReservationMutation) SetUpdatedBy(d datasource.UUID) {
	m.updated_by = &d
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *ReservationMutation) UpdatedBy() (r datasource.UUID, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Reservation entity.
// If the Reservation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReservationMutation) OldUpdatedBy(ctx context.Context) (v datasource.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds d to the "updated_by" field.
func (m *ReservationMutation) AddUpdatedBy(d datasource.UUID) {
	if m.addupdated_by != nil {
		*m.addupdated_by += d
	} else {
		m.addupdated_by = &d
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *ReservationMutation) AddedUpdatedBy() (r datasource.UUID, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *ReservationMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ReservationMutation) SetUpdatedAt(i int64) {
	m.updated_at = &i
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ReservationMutation) UpdatedAt() (r int64, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Reservation entity.
// If the Reservation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReservationMutation) OldUpdatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to the "updated_at" field.
func (m *ReservationMutation) AddUpdatedAt(i int64) {
	if m.addupdated_at != nil {
		*m.addupdated_at += i
	} else {
		m.addupdated_at = &i
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *ReservationMutation) AddedUpdatedAt() (r int64, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ReservationMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetReservationID sets the "reservation_id" field.
func (m *ReservationMutation) SetReservationID(i int64) {
	m.reservation_id = &i
	m.addreservation_id = nil
}

// ReservationID returns the value of the "reservation_id" field in the mutation.
func (m *ReservationMutation) ReservationID() (r int64, exists bool) {
	v := m.reservation_id
	if v == nil {
		return
	}
	return *v, true
}

// OldReservationID returns the old "reservation_id" field's value of the Reservation entity.
// If the Reservation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReservationMutation) OldReservationID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReservationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReservationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReservationID: %w", err)
	}
	return oldValue.ReservationID, nil
}

// AddReservationID adds i to the "reservation_id" field.
func (m *ReservationMutation) AddReservationID(i int64) {
	if m.addreservation_id != nil {
		*m.addreservation_id += i
	} else {
		m.addreservation_id = &i
	}
}

// AddedReservationID returns the value that was added to the "reservation_id" field in this mutation.
func (m *ReservationMutation) AddedReservationID() (r int64, exists bool) {
	v := m.addreservation_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetReservationID resets all changes to the "reservation_id" field.
func (m *ReservationMutation) ResetReservationID() {
	m.reservation_id = nil
	m.addreservation_id = nil
}

// SetAuthorizationMode sets the "authorization_mode" field.
func (m *ReservationMutation) SetAuthorizationMode(i int) {
	m.authorization_mode = &i
	m.addauthorization_mode = nil
}

// AuthorizationMode returns the value of the "authorization_mode" field in the mutation.
func (m *ReservationMutation) AuthorizationMode() (r int, exists bool) {
	v := m.authorization_mode
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthorizationMode returns the old "authorization_mode" field's value of the Reservation entity.
// If the Reservation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReservationMutation) OldAuthorizationMode(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthorizationMode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthorizationMode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthorizationMode: %w", err)
	}
	return oldValue.AuthorizationMode, nil
}

// AddAuthorizationMode adds i to the "authorization_mode" field.
func (m *ReservationMutation) AddAuthorizationMode(i int) {
	if m.addauthorization_mode != nil {
		*m.addauthorization_mode += i
	} else {
		m.addauthorization_mode = &i
	}
}

// AddedAuthorizationMode returns the value that was added to the "authorization_mode" field in this mutation.
func (m *ReservationMutation) AddedAuthorizationMode() (r int, exists bool) {
	v := m.addauthorization_mode
	if v == nil {
		return
	}
	return *v, true
}

// ResetAuthorizationMode resets all changes to the "authorization_mode" field.
func (m *ReservationMutation) ResetAuthorizationMode() {
	m.authorization_mode = nil
	m.addauthorization_mode = nil
}

// SetAuthorizationID sets the "authorization_id" field.
func (m *ReservationMutation) SetAuthorizationID(s string) {
	m.authorization_id = &s
}

// AuthorizationID returns the value of the "authorization_id" field in the mutation.
func (m *ReservationMutation) AuthorizationID() (r string, exists bool) {
	v := m.authorization_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthorizationID returns the old "authorization_id" field's value of the Reservation entity.
// If the Reservation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReservationMutation) OldAuthorizationID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthorizationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthorizationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthorizationID: %w", err)
	}
	return oldValue.AuthorizationID, nil
}

// ResetAuthorizationID resets all changes to the "authorization_id" field.
func (m *ReservationMutation) ResetAuthorizationID() {
	m.authorization_id = nil
}

// SetAdditional sets the "additional" field.
func (m *ReservationMutation) SetAdditional(s string) {
	m.additional = &s
}

// Additional returns the value of the "additional" field in the mutation.
func (m *ReservationMutation) Additional() (r string, exists bool) {
	v := m.additional
	if v == nil {
		return
	}
	return *v, true
}

// OldAdditional returns the old "additional" field's value of the Reservation entity.
// If the Reservation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReservationMutation) OldAdditional(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAdditional is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAdditional requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAdditional: %w", err)
	}
	return oldValue.Additional, nil
}

// ClearAdditional clears the value of the "additional" field.
func (m *ReservationMutation) ClearAdditional() {
	m.additional = nil
	m.clearedFields[reservation.FieldAdditional] = struct{}{}
}

// AdditionalCleared returns if the "additional" field was cleared in this mutation.
func (m *ReservationMutation) AdditionalCleared() bool {
	_, ok := m.clearedFields[reservation.FieldAdditional]
	return ok
}

// ResetAdditional resets all changes to the "additional" field.
func (m *ReservationMutation) ResetAdditional() {
	m.additional = nil
	delete(m.clearedFields, reservation.FieldAdditional)
}

// SetCustomerID sets the "customer_id" field.
func (m *ReservationMutation) SetCustomerID(s string) {
	m.customer_id = &s
}

// CustomerID returns the value of the "customer_id" field in the mutation.
func (m *ReservationMutation) CustomerID() (r string, exists bool) {
	v := m.customer_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCustomerID returns the old "customer_id" field's value of the Reservation entity.
// If the Reservation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReservationMutation) OldCustomerID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCustomerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCustomerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCustomerID: %w", err)
	}
	return oldValue.CustomerID, nil
}

// ClearCustomerID clears the value of the "customer_id" field.
func (m *ReservationMutation) ClearCustomerID() {
	m.customer_id = nil
	m.clearedFields[reservation.FieldCustomerID] = struct{}{}
}

// CustomerIDCleared returns if the "customer_id" field was cleared in this mutation.
func (m *ReservationMutation) CustomerIDCleared() bool {
	_, ok := m.clearedFields[reservation.FieldCustomerID]
	return ok
}

// ResetCustomerID resets all changes to the "customer_id" field.
func (m *ReservationMutation) ResetCustomerID() {
	m.customer_id = nil
	delete(m.clearedFields, reservation.FieldCustomerID)
}

// SetExpired sets the "expired" field.
func (m *ReservationMutation) SetExpired(i int64) {
	m.expired = &i
	m.addexpired = nil
}

// Expired returns the value of the "expired" field in the mutation.
func (m *ReservationMutation) Expired() (r int64, exists bool) {
	v := m.expired
	if v == nil {
		return
	}
	return *v, true
}

// OldExpired returns the old "expired" field's value of the Reservation entity.
// If the Reservation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReservationMutation) OldExpired(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpired is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpired requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpired: %w", err)
	}
	return oldValue.Expired, nil
}

// AddExpired adds i to the "expired" field.
func (m *ReservationMutation) AddExpired(i int64) {
	if m.addexpired != nil {
		*m.addexpired += i
	} else {
		m.addexpired = &i
	}
}

// AddedExpired returns the value that was added to the "expired" field in this mutation.
func (m *ReservationMutation) AddedExpired() (r int64, exists bool) {
	v := m.addexpired
	if v == nil {
		return
	}
	return *v, true
}

// ResetExpired resets all changes to the "expired" field.
func (m *ReservationMutation) ResetExpired() {
	m.expired = nil
	m.addexpired = nil
}

// SetState sets the "state" field.
func (m *ReservationMutation) SetState(i int) {
	m.state = &i
	m.addstate = nil
}

// State returns the value of the "state" field in the mutation.
func (m *ReservationMutation) State() (r int, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the Reservation entity.
// If the Reservation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReservationMutation) OldState(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// AddState adds i to the "state" field.
func (m *ReservationMutation) AddState(i int) {
	if m.addstate != nil {
		*m.addstate += i
	} else {
		m.addstate = &i
	}
}

// AddedState returns the value that was added to the "state" field in this mutation.
func (m *ReservationMutation) AddedState() (r int, exists bool) {
	v := m.addstate
	if v == nil {
		return
	}
	return *v, true
}

// ResetState resets all changes to the "state" field.
func (m *ReservationMutation) ResetState() {
	m.state = nil
	m.addstate = nil
}

// SetEquipmentID sets the "equipment" edge to the Equipment entity by id.
func (m *ReservationMutation) SetEquipmentID(id datasource.UUID) {
	m.equipment = &id
}

// ClearEquipment clears the "equipment" edge to the Equipment entity.
func (m *ReservationMutation) ClearEquipment() {
	m.clearedequipment = true
}

// EquipmentCleared reports if the "equipment" edge to the Equipment entity was cleared.
func (m *ReservationMutation) EquipmentCleared() bool {
	return m.clearedequipment
}

// EquipmentID returns the "equipment" edge ID in the mutation.
func (m *ReservationMutation) EquipmentID() (id datasource.UUID, exists bool) {
	if m.equipment != nil {
		return *m.equipment, true
	}
	return
}

// EquipmentIDs returns the "equipment" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EquipmentID instead. It exists only for internal usage by the builders.
func (m *ReservationMutation) EquipmentIDs() (ids []datasource.UUID) {
	if id := m.equipment; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEquipment resets all changes to the "equipment" edge.
func (m *ReservationMutation) ResetEquipment() {
	m.equipment = nil
	m.clearedequipment = false
}

// SetConnectorID sets the "connector" edge to the Connector entity by id.
func (m *ReservationMutation) SetConnectorID(id datasource.UUID) {
	m.connector = &id
}

// ClearConnector clears the "connector" edge to the Connector entity.
func (m *ReservationMutation) ClearConnector() {
	m.clearedconnector = true
}

// ConnectorCleared reports if the "connector" edge to the Connector entity was cleared.
func (m *ReservationMutation) ConnectorCleared() bool {
	return m.clearedconnector
}

// ConnectorID returns the "connector" edge ID in the mutation.
func (m *ReservationMutation) ConnectorID() (id datasource.UUID, exists bool) {
	if m.connector != nil {
		return *m.connector, true
	}
	return
}

// ConnectorIDs returns the "connector" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ConnectorID instead. It exists only for internal usage by the builders.
func (m *ReservationMutation) ConnectorIDs() (ids []datasource.UUID) {
	if id := m.connector; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetConnector resets all changes to the "connector" edge.
func (m *ReservationMutation) ResetConnector() {
	m.connector = nil
	m.clearedconnector = false
}

// Where appends a list predicates to the ReservationMutation builder.
func (m *ReservationMutation) Where(ps ...predicate.Reservation) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ReservationMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Reservation).
func (m *ReservationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ReservationMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.version != nil {
		fields = append(fields, reservation.FieldVersion)
	}
	if m.created_by != nil {
		fields = append(fields, reservation.FieldCreatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, reservation.FieldCreatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, reservation.FieldUpdatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, reservation.FieldUpdatedAt)
	}
	if m.reservation_id != nil {
		fields = append(fields, reservation.FieldReservationID)
	}
	if m.authorization_mode != nil {
		fields = append(fields, reservation.FieldAuthorizationMode)
	}
	if m.authorization_id != nil {
		fields = append(fields, reservation.FieldAuthorizationID)
	}
	if m.additional != nil {
		fields = append(fields, reservation.FieldAdditional)
	}
	if m.customer_id != nil {
		fields = append(fields, reservation.FieldCustomerID)
	}
	if m.expired != nil {
		fields = append(fields, reservation.FieldExpired)
	}
	if m.state != nil {
		fields = append(fields, reservation.FieldState)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ReservationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case reservation.FieldVersion:
		return m.Version()
	case reservation.FieldCreatedBy:
		return m.CreatedBy()
	case reservation.FieldCreatedAt:
		return m.CreatedAt()
	case reservation.FieldUpdatedBy:
		return m.UpdatedBy()
	case reservation.FieldUpdatedAt:
		return m.UpdatedAt()
	case reservation.FieldReservationID:
		return m.ReservationID()
	case reservation.FieldAuthorizationMode:
		return m.AuthorizationMode()
	case reservation.FieldAuthorizationID:
		return m.AuthorizationID()
	case reservation.FieldAdditional:
		return m.Additional()
	case reservation.FieldCustomerID:
		return m.CustomerID()
	case reservation.FieldExpired:
		return m.Expired()
	case reservation.FieldState:
		return m.State()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ReservationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case reservation.FieldVersion:
		return m.OldVersion(ctx)
	case reservation.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case reservation.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case reservation.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case reservation.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case reservation.FieldReservationID:
		return m.OldReservationID(ctx)
	case reservation.FieldAuthorizationMode:
		return m.OldAuthorizationMode(ctx)
	case reservation.FieldAuthorizationID:
		return m.OldAuthorizationID(ctx)
	case reservation.FieldAdditional:
		return m.OldAdditional(ctx)
	case reservation.FieldCustomerID:
		return m.OldCustomerID(ctx)
	case reservation.FieldExpired:
		return m.OldExpired(ctx)
	case reservation.FieldState:
		return m.OldState(ctx)
	}
	return nil, fmt.Errorf("unknown Reservation field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReservationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case reservation.FieldVersion:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case reservation.FieldCreatedBy:
		v, ok := value.(datasource.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case reservation.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case reservation.FieldUpdatedBy:
		v, ok := value.(datasource.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case reservation.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case reservation.FieldReservationID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReservationID(v)
		return nil
	case reservation.FieldAuthorizationMode:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthorizationMode(v)
		return nil
	case reservation.FieldAuthorizationID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthorizationID(v)
		return nil
	case reservation.FieldAdditional:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAdditional(v)
		return nil
	case reservation.FieldCustomerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCustomerID(v)
		return nil
	case reservation.FieldExpired:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpired(v)
		return nil
	case reservation.FieldState:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	}
	return fmt.Errorf("unknown Reservation field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ReservationMutation) AddedFields() []string {
	var fields []string
	if m.addversion != nil {
		fields = append(fields, reservation.FieldVersion)
	}
	if m.addcreated_by != nil {
		fields = append(fields, reservation.FieldCreatedBy)
	}
	if m.addcreated_at != nil {
		fields = append(fields, reservation.FieldCreatedAt)
	}
	if m.addupdated_by != nil {
		fields = append(fields, reservation.FieldUpdatedBy)
	}
	if m.addupdated_at != nil {
		fields = append(fields, reservation.FieldUpdatedAt)
	}
	if m.addreservation_id != nil {
		fields = append(fields, reservation.FieldReservationID)
	}
	if m.addauthorization_mode != nil {
		fields = append(fields, reservation.FieldAuthorizationMode)
	}
	if m.addexpired != nil {
		fields = append(fields, reservation.FieldExpired)
	}
	if m.addstate != nil {
		fields = append(fields, reservation.FieldState)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ReservationMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case reservation.FieldVersion:
		return m.AddedVersion()
	case reservation.FieldCreatedBy:
		return m.AddedCreatedBy()
	case reservation.FieldCreatedAt:
		return m.AddedCreatedAt()
	case reservation.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case reservation.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case reservation.FieldReservationID:
		return m.AddedReservationID()
	case reservation.FieldAuthorizationMode:
		return m.AddedAuthorizationMode()
	case reservation.FieldExpired:
		return m.AddedExpired()
	case reservation.FieldState:
		return m.AddedState()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReservationMutation) AddField(name string, value ent.Value) error {
	switch name {
	case reservation.FieldVersion:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVersion(v)
		return nil
	case reservation.FieldCreatedBy:
		v, ok := value.(datasource.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case reservation.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case reservation.FieldUpdatedBy:
		v, ok := value.(datasource.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case reservation.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case reservation.FieldReservationID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddReservationID(v)
		return nil
	case reservation.FieldAuthorizationMode:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAuthorizationMode(v)
		return nil
	case reservation.FieldExpired:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddExpired(v)
		return nil
	case reservation.FieldState:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddState(v)
		return nil
	}
	return fmt.Errorf("unknown Reservation numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ReservationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(reservation.FieldAdditional) {
		fields = append(fields, reservation.FieldAdditional)
	}
	if m.FieldCleared(reservation.FieldCustomerID) {
		fields = append(fields, reservation.FieldCustomerID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ReservationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ReservationMutation) ClearField(name string) error {
	switch name {
	case reservation.FieldAdditional:
		m.ClearAdditional()
		return nil
	case reservation.FieldCustomerID:
		m.ClearCustomerID()
		return nil
	}
	return fmt.Errorf("unknown Reservation nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ReservationMutation) ResetField(name string) error {
	switch name {
	case reservation.FieldVersion:
		m.ResetVersion()
		return nil
	case reservation.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case reservation.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case reservation.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case reservation.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case reservation.FieldReservationID:
		m.ResetReservationID()
		return nil
	case reservation.FieldAuthorizationMode:
		m.ResetAuthorizationMode()
		return nil
	case reservation.FieldAuthorizationID:
		m.ResetAuthorizationID()
		return nil
	case reservation.FieldAdditional:
		m.ResetAdditional()
		return nil
	case reservation.FieldCustomerID:
		m.ResetCustomerID()
		return nil
	case reservation.FieldExpired:
		m.ResetExpired()
		return nil
	case reservation.FieldState:
		m.ResetState()
		return nil
	}
	return fmt.Errorf("unknown Reservation field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ReservationMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.equipment != nil {
		edges = append(edges, reservation.EdgeEquipment)
	}
	if m.connector != nil {
		edges = append(edges, reservation.EdgeConnector)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ReservationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case reservation.EdgeEquipment:
		if id := m.equipment; id != nil {
			return []ent.Value{*id}
		}
	case reservation.EdgeConnector:
		if id := m.connector; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ReservationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ReservationMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ReservationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedequipment {
		edges = append(edges, reservation.EdgeEquipment)
	}
	if m.clearedconnector {
		edges = append(edges, reservation.EdgeConnector)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ReservationMutation) EdgeCleared(name string) bool {
	switch name {
	case reservation.EdgeEquipment:
		return m.clearedequipment
	case reservation.EdgeConnector:
		return m.clearedconnector
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ReservationMutation) ClearEdge(name string) error {
	switch name {
	case reservation.EdgeEquipment:
		m.ClearEquipment()
		return nil
	case reservation.EdgeConnector:
		m.ClearConnector()
		return nil
	}
	return fmt.Errorf("unknown Reservation unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ReservationMutation) ResetEdge(name string) error {
	switch name {
	case reservation.EdgeEquipment:
		m.ResetEquipment()
		return nil
	case reservation.EdgeConnector:
		m.ResetConnector()
		return nil
	}
	return fmt.Errorf("unknown Reservation edge %s", name)
}

// SmartChargingEffectMutation represents an operation that mutates the SmartChargingEffect nodes in the graph.
type SmartChargingEffectMutation struct {
	config
	op                Op
	typ               string
	id                *datasource.UUID
	version           *int64
	addversion        *int64
	created_by        *datasource.UUID
	addcreated_by     *datasource.UUID
	created_at        *int64
	addcreated_at     *int64
	updated_by        *datasource.UUID
	addupdated_by     *datasource.UUID
	updated_at        *int64
	addupdated_at     *int64
	smart_id          *int64
	addsmart_id       *int64
	start_time        *int64
	addstart_time     *int64
	pid               *datasource.UUID
	addpid            *datasource.UUID
	unit              *string
	equipment_sn      *string
	valid_from        *int64
	addvalid_from     *int64
	valid_to          *int64
	addvalid_to       *int64
	spec              *[]types.ChargingSchedulePeriod
	appendspec        []types.ChargingSchedulePeriod
	clearedFields     map[string]struct{}
	equipment         *datasource.UUID
	clearedequipment  bool
	connector         *datasource.UUID
	clearedconnector  bool
	order_info        *datasource.UUID
	clearedorder_info bool
	done              bool
	oldValue          func(context.Context) (*SmartChargingEffect, error)
	predicates        []predicate.SmartChargingEffect
}

var _ ent.Mutation = (*SmartChargingEffectMutation)(nil)

// smartchargingeffectOption allows management of the mutation configuration using functional options.
type smartchargingeffectOption func(*SmartChargingEffectMutation)

// newSmartChargingEffectMutation creates new mutation for the SmartChargingEffect entity.
func newSmartChargingEffectMutation(c config, op Op, opts ...smartchargingeffectOption) *SmartChargingEffectMutation {
	m := &SmartChargingEffectMutation{
		config:        c,
		op:            op,
		typ:           TypeSmartChargingEffect,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSmartChargingEffectID sets the ID field of the mutation.
func withSmartChargingEffectID(id datasource.UUID) smartchargingeffectOption {
	return func(m *SmartChargingEffectMutation) {
		var (
			err   error
			once  sync.Once
			value *SmartChargingEffect
		)
		m.oldValue = func(ctx context.Context) (*SmartChargingEffect, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SmartChargingEffect.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSmartChargingEffect sets the old SmartChargingEffect of the mutation.
func withSmartChargingEffect(node *SmartChargingEffect) smartchargingeffectOption {
	return func(m *SmartChargingEffectMutation) {
		m.oldValue = func(context.Context) (*SmartChargingEffect, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SmartChargingEffectMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SmartChargingEffectMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of SmartChargingEffect entities.
func (m *SmartChargingEffectMutation) SetID(id datasource.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SmartChargingEffectMutation) ID() (id datasource.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SmartChargingEffectMutation) IDs(ctx context.Context) ([]datasource.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []datasource.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SmartChargingEffect.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetVersion sets the "version" field.
func (m *SmartChargingEffectMutation) SetVersion(i int64) {
	m.version = &i
	m.addversion = nil
}

// Version returns the value of the "version" field in the mutation.
func (m *SmartChargingEffectMutation) Version() (r int64, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the SmartChargingEffect entity.
// If the SmartChargingEffect object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SmartChargingEffectMutation) OldVersion(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// AddVersion adds i to the "version" field.
func (m *SmartChargingEffectMutation) AddVersion(i int64) {
	if m.addversion != nil {
		*m.addversion += i
	} else {
		m.addversion = &i
	}
}

// AddedVersion returns the value that was added to the "version" field in this mutation.
func (m *SmartChargingEffectMutation) AddedVersion() (r int64, exists bool) {
	v := m.addversion
	if v == nil {
		return
	}
	return *v, true
}

// ResetVersion resets all changes to the "version" field.
func (m *SmartChargingEffectMutation) ResetVersion() {
	m.version = nil
	m.addversion = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *SmartChargingEffectMutation) SetCreatedBy(d datasource.UUID) {
	m.created_by = &d
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *SmartChargingEffectMutation) CreatedBy() (r datasource.UUID, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the SmartChargingEffect entity.
// If the SmartChargingEffect object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SmartChargingEffectMutation) OldCreatedBy(ctx context.Context) (v datasource.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds d to the "created_by" field.
func (m *SmartChargingEffectMutation) AddCreatedBy(d datasource.UUID) {
	if m.addcreated_by != nil {
		*m.addcreated_by += d
	} else {
		m.addcreated_by = &d
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *SmartChargingEffectMutation) AddedCreatedBy() (r datasource.UUID, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *SmartChargingEffectMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *SmartChargingEffectMutation) SetCreatedAt(i int64) {
	m.created_at = &i
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SmartChargingEffectMutation) CreatedAt() (r int64, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the SmartChargingEffect entity.
// If the SmartChargingEffect object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SmartChargingEffectMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to the "created_at" field.
func (m *SmartChargingEffectMutation) AddCreatedAt(i int64) {
	if m.addcreated_at != nil {
		*m.addcreated_at += i
	} else {
		m.addcreated_at = &i
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *SmartChargingEffectMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SmartChargingEffectMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *SmartChargingEffectMutation) SetUpdatedBy(d datasource.UUID) {
	m.updated_by = &d
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *SmartChargingEffectMutation) UpdatedBy() (r datasource.UUID, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the SmartChargingEffect entity.
// If the SmartChargingEffect object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SmartChargingEffectMutation) OldUpdatedBy(ctx context.Context) (v datasource.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds d to the "updated_by" field.
func (m *SmartChargingEffectMutation) AddUpdatedBy(d datasource.UUID) {
	if m.addupdated_by != nil {
		*m.addupdated_by += d
	} else {
		m.addupdated_by = &d
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *SmartChargingEffectMutation) AddedUpdatedBy() (r datasource.UUID, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *SmartChargingEffectMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SmartChargingEffectMutation) SetUpdatedAt(i int64) {
	m.updated_at = &i
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SmartChargingEffectMutation) UpdatedAt() (r int64, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the SmartChargingEffect entity.
// If the SmartChargingEffect object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SmartChargingEffectMutation) OldUpdatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to the "updated_at" field.
func (m *SmartChargingEffectMutation) AddUpdatedAt(i int64) {
	if m.addupdated_at != nil {
		*m.addupdated_at += i
	} else {
		m.addupdated_at = &i
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *SmartChargingEffectMutation) AddedUpdatedAt() (r int64, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SmartChargingEffectMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetSmartID sets the "smart_id" field.
func (m *SmartChargingEffectMutation) SetSmartID(i int64) {
	m.smart_id = &i
	m.addsmart_id = nil
}

// SmartID returns the value of the "smart_id" field in the mutation.
func (m *SmartChargingEffectMutation) SmartID() (r int64, exists bool) {
	v := m.smart_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSmartID returns the old "smart_id" field's value of the SmartChargingEffect entity.
// If the SmartChargingEffect object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SmartChargingEffectMutation) OldSmartID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSmartID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSmartID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSmartID: %w", err)
	}
	return oldValue.SmartID, nil
}

// AddSmartID adds i to the "smart_id" field.
func (m *SmartChargingEffectMutation) AddSmartID(i int64) {
	if m.addsmart_id != nil {
		*m.addsmart_id += i
	} else {
		m.addsmart_id = &i
	}
}

// AddedSmartID returns the value that was added to the "smart_id" field in this mutation.
func (m *SmartChargingEffectMutation) AddedSmartID() (r int64, exists bool) {
	v := m.addsmart_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetSmartID resets all changes to the "smart_id" field.
func (m *SmartChargingEffectMutation) ResetSmartID() {
	m.smart_id = nil
	m.addsmart_id = nil
}

// SetStartTime sets the "start_time" field.
func (m *SmartChargingEffectMutation) SetStartTime(i int64) {
	m.start_time = &i
	m.addstart_time = nil
}

// StartTime returns the value of the "start_time" field in the mutation.
func (m *SmartChargingEffectMutation) StartTime() (r int64, exists bool) {
	v := m.start_time
	if v == nil {
		return
	}
	return *v, true
}

// OldStartTime returns the old "start_time" field's value of the SmartChargingEffect entity.
// If the SmartChargingEffect object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SmartChargingEffectMutation) OldStartTime(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartTime: %w", err)
	}
	return oldValue.StartTime, nil
}

// AddStartTime adds i to the "start_time" field.
func (m *SmartChargingEffectMutation) AddStartTime(i int64) {
	if m.addstart_time != nil {
		*m.addstart_time += i
	} else {
		m.addstart_time = &i
	}
}

// AddedStartTime returns the value that was added to the "start_time" field in this mutation.
func (m *SmartChargingEffectMutation) AddedStartTime() (r int64, exists bool) {
	v := m.addstart_time
	if v == nil {
		return
	}
	return *v, true
}

// ResetStartTime resets all changes to the "start_time" field.
func (m *SmartChargingEffectMutation) ResetStartTime() {
	m.start_time = nil
	m.addstart_time = nil
}

// SetPid sets the "pid" field.
func (m *SmartChargingEffectMutation) SetPid(d datasource.UUID) {
	m.pid = &d
	m.addpid = nil
}

// Pid returns the value of the "pid" field in the mutation.
func (m *SmartChargingEffectMutation) Pid() (r datasource.UUID, exists bool) {
	v := m.pid
	if v == nil {
		return
	}
	return *v, true
}

// OldPid returns the old "pid" field's value of the SmartChargingEffect entity.
// If the SmartChargingEffect object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SmartChargingEffectMutation) OldPid(ctx context.Context) (v datasource.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPid is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPid: %w", err)
	}
	return oldValue.Pid, nil
}

// AddPid adds d to the "pid" field.
func (m *SmartChargingEffectMutation) AddPid(d datasource.UUID) {
	if m.addpid != nil {
		*m.addpid += d
	} else {
		m.addpid = &d
	}
}

// AddedPid returns the value that was added to the "pid" field in this mutation.
func (m *SmartChargingEffectMutation) AddedPid() (r datasource.UUID, exists bool) {
	v := m.addpid
	if v == nil {
		return
	}
	return *v, true
}

// ResetPid resets all changes to the "pid" field.
func (m *SmartChargingEffectMutation) ResetPid() {
	m.pid = nil
	m.addpid = nil
}

// SetUnit sets the "unit" field.
func (m *SmartChargingEffectMutation) SetUnit(s string) {
	m.unit = &s
}

// Unit returns the value of the "unit" field in the mutation.
func (m *SmartChargingEffectMutation) Unit() (r string, exists bool) {
	v := m.unit
	if v == nil {
		return
	}
	return *v, true
}

// OldUnit returns the old "unit" field's value of the SmartChargingEffect entity.
// If the SmartChargingEffect object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SmartChargingEffectMutation) OldUnit(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnit: %w", err)
	}
	return oldValue.Unit, nil
}

// ResetUnit resets all changes to the "unit" field.
func (m *SmartChargingEffectMutation) ResetUnit() {
	m.unit = nil
}

// SetEquipmentSn sets the "equipment_sn" field.
func (m *SmartChargingEffectMutation) SetEquipmentSn(s string) {
	m.equipment_sn = &s
}

// EquipmentSn returns the value of the "equipment_sn" field in the mutation.
func (m *SmartChargingEffectMutation) EquipmentSn() (r string, exists bool) {
	v := m.equipment_sn
	if v == nil {
		return
	}
	return *v, true
}

// OldEquipmentSn returns the old "equipment_sn" field's value of the SmartChargingEffect entity.
// If the SmartChargingEffect object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SmartChargingEffectMutation) OldEquipmentSn(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEquipmentSn is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEquipmentSn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEquipmentSn: %w", err)
	}
	return oldValue.EquipmentSn, nil
}

// ResetEquipmentSn resets all changes to the "equipment_sn" field.
func (m *SmartChargingEffectMutation) ResetEquipmentSn() {
	m.equipment_sn = nil
}

// SetValidFrom sets the "valid_from" field.
func (m *SmartChargingEffectMutation) SetValidFrom(i int64) {
	m.valid_from = &i
	m.addvalid_from = nil
}

// ValidFrom returns the value of the "valid_from" field in the mutation.
func (m *SmartChargingEffectMutation) ValidFrom() (r int64, exists bool) {
	v := m.valid_from
	if v == nil {
		return
	}
	return *v, true
}

// OldValidFrom returns the old "valid_from" field's value of the SmartChargingEffect entity.
// If the SmartChargingEffect object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SmartChargingEffectMutation) OldValidFrom(ctx context.Context) (v *int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValidFrom is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValidFrom requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValidFrom: %w", err)
	}
	return oldValue.ValidFrom, nil
}

// AddValidFrom adds i to the "valid_from" field.
func (m *SmartChargingEffectMutation) AddValidFrom(i int64) {
	if m.addvalid_from != nil {
		*m.addvalid_from += i
	} else {
		m.addvalid_from = &i
	}
}

// AddedValidFrom returns the value that was added to the "valid_from" field in this mutation.
func (m *SmartChargingEffectMutation) AddedValidFrom() (r int64, exists bool) {
	v := m.addvalid_from
	if v == nil {
		return
	}
	return *v, true
}

// ClearValidFrom clears the value of the "valid_from" field.
func (m *SmartChargingEffectMutation) ClearValidFrom() {
	m.valid_from = nil
	m.addvalid_from = nil
	m.clearedFields[smartchargingeffect.FieldValidFrom] = struct{}{}
}

// ValidFromCleared returns if the "valid_from" field was cleared in this mutation.
func (m *SmartChargingEffectMutation) ValidFromCleared() bool {
	_, ok := m.clearedFields[smartchargingeffect.FieldValidFrom]
	return ok
}

// ResetValidFrom resets all changes to the "valid_from" field.
func (m *SmartChargingEffectMutation) ResetValidFrom() {
	m.valid_from = nil
	m.addvalid_from = nil
	delete(m.clearedFields, smartchargingeffect.FieldValidFrom)
}

// SetValidTo sets the "valid_to" field.
func (m *SmartChargingEffectMutation) SetValidTo(i int64) {
	m.valid_to = &i
	m.addvalid_to = nil
}

// ValidTo returns the value of the "valid_to" field in the mutation.
func (m *SmartChargingEffectMutation) ValidTo() (r int64, exists bool) {
	v := m.valid_to
	if v == nil {
		return
	}
	return *v, true
}

// OldValidTo returns the old "valid_to" field's value of the SmartChargingEffect entity.
// If the SmartChargingEffect object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SmartChargingEffectMutation) OldValidTo(ctx context.Context) (v *int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValidTo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValidTo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValidTo: %w", err)
	}
	return oldValue.ValidTo, nil
}

// AddValidTo adds i to the "valid_to" field.
func (m *SmartChargingEffectMutation) AddValidTo(i int64) {
	if m.addvalid_to != nil {
		*m.addvalid_to += i
	} else {
		m.addvalid_to = &i
	}
}

// AddedValidTo returns the value that was added to the "valid_to" field in this mutation.
func (m *SmartChargingEffectMutation) AddedValidTo() (r int64, exists bool) {
	v := m.addvalid_to
	if v == nil {
		return
	}
	return *v, true
}

// ClearValidTo clears the value of the "valid_to" field.
func (m *SmartChargingEffectMutation) ClearValidTo() {
	m.valid_to = nil
	m.addvalid_to = nil
	m.clearedFields[smartchargingeffect.FieldValidTo] = struct{}{}
}

// ValidToCleared returns if the "valid_to" field was cleared in this mutation.
func (m *SmartChargingEffectMutation) ValidToCleared() bool {
	_, ok := m.clearedFields[smartchargingeffect.FieldValidTo]
	return ok
}

// ResetValidTo resets all changes to the "valid_to" field.
func (m *SmartChargingEffectMutation) ResetValidTo() {
	m.valid_to = nil
	m.addvalid_to = nil
	delete(m.clearedFields, smartchargingeffect.FieldValidTo)
}

// SetSpec sets the "spec" field.
func (m *SmartChargingEffectMutation) SetSpec(tsp []types.ChargingSchedulePeriod) {
	m.spec = &tsp
	m.appendspec = nil
}

// Spec returns the value of the "spec" field in the mutation.
func (m *SmartChargingEffectMutation) Spec() (r []types.ChargingSchedulePeriod, exists bool) {
	v := m.spec
	if v == nil {
		return
	}
	return *v, true
}

// OldSpec returns the old "spec" field's value of the SmartChargingEffect entity.
// If the SmartChargingEffect object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SmartChargingEffectMutation) OldSpec(ctx context.Context) (v []types.ChargingSchedulePeriod, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSpec is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSpec requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSpec: %w", err)
	}
	return oldValue.Spec, nil
}

// AppendSpec adds tsp to the "spec" field.
func (m *SmartChargingEffectMutation) AppendSpec(tsp []types.ChargingSchedulePeriod) {
	m.appendspec = append(m.appendspec, tsp...)
}

// AppendedSpec returns the list of values that were appended to the "spec" field in this mutation.
func (m *SmartChargingEffectMutation) AppendedSpec() ([]types.ChargingSchedulePeriod, bool) {
	if len(m.appendspec) == 0 {
		return nil, false
	}
	return m.appendspec, true
}

// ResetSpec resets all changes to the "spec" field.
func (m *SmartChargingEffectMutation) ResetSpec() {
	m.spec = nil
	m.appendspec = nil
}

// SetEquipmentID sets the "equipment" edge to the Equipment entity by id.
func (m *SmartChargingEffectMutation) SetEquipmentID(id datasource.UUID) {
	m.equipment = &id
}

// ClearEquipment clears the "equipment" edge to the Equipment entity.
func (m *SmartChargingEffectMutation) ClearEquipment() {
	m.clearedequipment = true
}

// EquipmentCleared reports if the "equipment" edge to the Equipment entity was cleared.
func (m *SmartChargingEffectMutation) EquipmentCleared() bool {
	return m.clearedequipment
}

// EquipmentID returns the "equipment" edge ID in the mutation.
func (m *SmartChargingEffectMutation) EquipmentID() (id datasource.UUID, exists bool) {
	if m.equipment != nil {
		return *m.equipment, true
	}
	return
}

// EquipmentIDs returns the "equipment" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EquipmentID instead. It exists only for internal usage by the builders.
func (m *SmartChargingEffectMutation) EquipmentIDs() (ids []datasource.UUID) {
	if id := m.equipment; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEquipment resets all changes to the "equipment" edge.
func (m *SmartChargingEffectMutation) ResetEquipment() {
	m.equipment = nil
	m.clearedequipment = false
}

// SetConnectorID sets the "connector" edge to the Connector entity by id.
func (m *SmartChargingEffectMutation) SetConnectorID(id datasource.UUID) {
	m.connector = &id
}

// ClearConnector clears the "connector" edge to the Connector entity.
func (m *SmartChargingEffectMutation) ClearConnector() {
	m.clearedconnector = true
}

// ConnectorCleared reports if the "connector" edge to the Connector entity was cleared.
func (m *SmartChargingEffectMutation) ConnectorCleared() bool {
	return m.clearedconnector
}

// ConnectorID returns the "connector" edge ID in the mutation.
func (m *SmartChargingEffectMutation) ConnectorID() (id datasource.UUID, exists bool) {
	if m.connector != nil {
		return *m.connector, true
	}
	return
}

// ConnectorIDs returns the "connector" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ConnectorID instead. It exists only for internal usage by the builders.
func (m *SmartChargingEffectMutation) ConnectorIDs() (ids []datasource.UUID) {
	if id := m.connector; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetConnector resets all changes to the "connector" edge.
func (m *SmartChargingEffectMutation) ResetConnector() {
	m.connector = nil
	m.clearedconnector = false
}

// SetOrderInfoID sets the "order_info" edge to the OrderInfo entity by id.
func (m *SmartChargingEffectMutation) SetOrderInfoID(id datasource.UUID) {
	m.order_info = &id
}

// ClearOrderInfo clears the "order_info" edge to the OrderInfo entity.
func (m *SmartChargingEffectMutation) ClearOrderInfo() {
	m.clearedorder_info = true
}

// OrderInfoCleared reports if the "order_info" edge to the OrderInfo entity was cleared.
func (m *SmartChargingEffectMutation) OrderInfoCleared() bool {
	return m.clearedorder_info
}

// OrderInfoID returns the "order_info" edge ID in the mutation.
func (m *SmartChargingEffectMutation) OrderInfoID() (id datasource.UUID, exists bool) {
	if m.order_info != nil {
		return *m.order_info, true
	}
	return
}

// OrderInfoIDs returns the "order_info" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrderInfoID instead. It exists only for internal usage by the builders.
func (m *SmartChargingEffectMutation) OrderInfoIDs() (ids []datasource.UUID) {
	if id := m.order_info; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrderInfo resets all changes to the "order_info" edge.
func (m *SmartChargingEffectMutation) ResetOrderInfo() {
	m.order_info = nil
	m.clearedorder_info = false
}

// Where appends a list predicates to the SmartChargingEffectMutation builder.
func (m *SmartChargingEffectMutation) Where(ps ...predicate.SmartChargingEffect) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *SmartChargingEffectMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (SmartChargingEffect).
func (m *SmartChargingEffectMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SmartChargingEffectMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.version != nil {
		fields = append(fields, smartchargingeffect.FieldVersion)
	}
	if m.created_by != nil {
		fields = append(fields, smartchargingeffect.FieldCreatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, smartchargingeffect.FieldCreatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, smartchargingeffect.FieldUpdatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, smartchargingeffect.FieldUpdatedAt)
	}
	if m.smart_id != nil {
		fields = append(fields, smartchargingeffect.FieldSmartID)
	}
	if m.start_time != nil {
		fields = append(fields, smartchargingeffect.FieldStartTime)
	}
	if m.pid != nil {
		fields = append(fields, smartchargingeffect.FieldPid)
	}
	if m.unit != nil {
		fields = append(fields, smartchargingeffect.FieldUnit)
	}
	if m.equipment_sn != nil {
		fields = append(fields, smartchargingeffect.FieldEquipmentSn)
	}
	if m.valid_from != nil {
		fields = append(fields, smartchargingeffect.FieldValidFrom)
	}
	if m.valid_to != nil {
		fields = append(fields, smartchargingeffect.FieldValidTo)
	}
	if m.spec != nil {
		fields = append(fields, smartchargingeffect.FieldSpec)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SmartChargingEffectMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case smartchargingeffect.FieldVersion:
		return m.Version()
	case smartchargingeffect.FieldCreatedBy:
		return m.CreatedBy()
	case smartchargingeffect.FieldCreatedAt:
		return m.CreatedAt()
	case smartchargingeffect.FieldUpdatedBy:
		return m.UpdatedBy()
	case smartchargingeffect.FieldUpdatedAt:
		return m.UpdatedAt()
	case smartchargingeffect.FieldSmartID:
		return m.SmartID()
	case smartchargingeffect.FieldStartTime:
		return m.StartTime()
	case smartchargingeffect.FieldPid:
		return m.Pid()
	case smartchargingeffect.FieldUnit:
		return m.Unit()
	case smartchargingeffect.FieldEquipmentSn:
		return m.EquipmentSn()
	case smartchargingeffect.FieldValidFrom:
		return m.ValidFrom()
	case smartchargingeffect.FieldValidTo:
		return m.ValidTo()
	case smartchargingeffect.FieldSpec:
		return m.Spec()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SmartChargingEffectMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case smartchargingeffect.FieldVersion:
		return m.OldVersion(ctx)
	case smartchargingeffect.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case smartchargingeffect.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case smartchargingeffect.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case smartchargingeffect.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case smartchargingeffect.FieldSmartID:
		return m.OldSmartID(ctx)
	case smartchargingeffect.FieldStartTime:
		return m.OldStartTime(ctx)
	case smartchargingeffect.FieldPid:
		return m.OldPid(ctx)
	case smartchargingeffect.FieldUnit:
		return m.OldUnit(ctx)
	case smartchargingeffect.FieldEquipmentSn:
		return m.OldEquipmentSn(ctx)
	case smartchargingeffect.FieldValidFrom:
		return m.OldValidFrom(ctx)
	case smartchargingeffect.FieldValidTo:
		return m.OldValidTo(ctx)
	case smartchargingeffect.FieldSpec:
		return m.OldSpec(ctx)
	}
	return nil, fmt.Errorf("unknown SmartChargingEffect field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SmartChargingEffectMutation) SetField(name string, value ent.Value) error {
	switch name {
	case smartchargingeffect.FieldVersion:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case smartchargingeffect.FieldCreatedBy:
		v, ok := value.(datasource.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case smartchargingeffect.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case smartchargingeffect.FieldUpdatedBy:
		v, ok := value.(datasource.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case smartchargingeffect.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case smartchargingeffect.FieldSmartID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSmartID(v)
		return nil
	case smartchargingeffect.FieldStartTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartTime(v)
		return nil
	case smartchargingeffect.FieldPid:
		v, ok := value.(datasource.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPid(v)
		return nil
	case smartchargingeffect.FieldUnit:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnit(v)
		return nil
	case smartchargingeffect.FieldEquipmentSn:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEquipmentSn(v)
		return nil
	case smartchargingeffect.FieldValidFrom:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValidFrom(v)
		return nil
	case smartchargingeffect.FieldValidTo:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValidTo(v)
		return nil
	case smartchargingeffect.FieldSpec:
		v, ok := value.([]types.ChargingSchedulePeriod)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSpec(v)
		return nil
	}
	return fmt.Errorf("unknown SmartChargingEffect field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SmartChargingEffectMutation) AddedFields() []string {
	var fields []string
	if m.addversion != nil {
		fields = append(fields, smartchargingeffect.FieldVersion)
	}
	if m.addcreated_by != nil {
		fields = append(fields, smartchargingeffect.FieldCreatedBy)
	}
	if m.addcreated_at != nil {
		fields = append(fields, smartchargingeffect.FieldCreatedAt)
	}
	if m.addupdated_by != nil {
		fields = append(fields, smartchargingeffect.FieldUpdatedBy)
	}
	if m.addupdated_at != nil {
		fields = append(fields, smartchargingeffect.FieldUpdatedAt)
	}
	if m.addsmart_id != nil {
		fields = append(fields, smartchargingeffect.FieldSmartID)
	}
	if m.addstart_time != nil {
		fields = append(fields, smartchargingeffect.FieldStartTime)
	}
	if m.addpid != nil {
		fields = append(fields, smartchargingeffect.FieldPid)
	}
	if m.addvalid_from != nil {
		fields = append(fields, smartchargingeffect.FieldValidFrom)
	}
	if m.addvalid_to != nil {
		fields = append(fields, smartchargingeffect.FieldValidTo)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SmartChargingEffectMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case smartchargingeffect.FieldVersion:
		return m.AddedVersion()
	case smartchargingeffect.FieldCreatedBy:
		return m.AddedCreatedBy()
	case smartchargingeffect.FieldCreatedAt:
		return m.AddedCreatedAt()
	case smartchargingeffect.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case smartchargingeffect.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case smartchargingeffect.FieldSmartID:
		return m.AddedSmartID()
	case smartchargingeffect.FieldStartTime:
		return m.AddedStartTime()
	case smartchargingeffect.FieldPid:
		return m.AddedPid()
	case smartchargingeffect.FieldValidFrom:
		return m.AddedValidFrom()
	case smartchargingeffect.FieldValidTo:
		return m.AddedValidTo()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SmartChargingEffectMutation) AddField(name string, value ent.Value) error {
	switch name {
	case smartchargingeffect.FieldVersion:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVersion(v)
		return nil
	case smartchargingeffect.FieldCreatedBy:
		v, ok := value.(datasource.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case smartchargingeffect.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case smartchargingeffect.FieldUpdatedBy:
		v, ok := value.(datasource.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case smartchargingeffect.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case smartchargingeffect.FieldSmartID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSmartID(v)
		return nil
	case smartchargingeffect.FieldStartTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStartTime(v)
		return nil
	case smartchargingeffect.FieldPid:
		v, ok := value.(datasource.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPid(v)
		return nil
	case smartchargingeffect.FieldValidFrom:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddValidFrom(v)
		return nil
	case smartchargingeffect.FieldValidTo:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddValidTo(v)
		return nil
	}
	return fmt.Errorf("unknown SmartChargingEffect numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SmartChargingEffectMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(smartchargingeffect.FieldValidFrom) {
		fields = append(fields, smartchargingeffect.FieldValidFrom)
	}
	if m.FieldCleared(smartchargingeffect.FieldValidTo) {
		fields = append(fields, smartchargingeffect.FieldValidTo)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SmartChargingEffectMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SmartChargingEffectMutation) ClearField(name string) error {
	switch name {
	case smartchargingeffect.FieldValidFrom:
		m.ClearValidFrom()
		return nil
	case smartchargingeffect.FieldValidTo:
		m.ClearValidTo()
		return nil
	}
	return fmt.Errorf("unknown SmartChargingEffect nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SmartChargingEffectMutation) ResetField(name string) error {
	switch name {
	case smartchargingeffect.FieldVersion:
		m.ResetVersion()
		return nil
	case smartchargingeffect.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case smartchargingeffect.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case smartchargingeffect.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case smartchargingeffect.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case smartchargingeffect.FieldSmartID:
		m.ResetSmartID()
		return nil
	case smartchargingeffect.FieldStartTime:
		m.ResetStartTime()
		return nil
	case smartchargingeffect.FieldPid:
		m.ResetPid()
		return nil
	case smartchargingeffect.FieldUnit:
		m.ResetUnit()
		return nil
	case smartchargingeffect.FieldEquipmentSn:
		m.ResetEquipmentSn()
		return nil
	case smartchargingeffect.FieldValidFrom:
		m.ResetValidFrom()
		return nil
	case smartchargingeffect.FieldValidTo:
		m.ResetValidTo()
		return nil
	case smartchargingeffect.FieldSpec:
		m.ResetSpec()
		return nil
	}
	return fmt.Errorf("unknown SmartChargingEffect field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SmartChargingEffectMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.equipment != nil {
		edges = append(edges, smartchargingeffect.EdgeEquipment)
	}
	if m.connector != nil {
		edges = append(edges, smartchargingeffect.EdgeConnector)
	}
	if m.order_info != nil {
		edges = append(edges, smartchargingeffect.EdgeOrderInfo)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SmartChargingEffectMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case smartchargingeffect.EdgeEquipment:
		if id := m.equipment; id != nil {
			return []ent.Value{*id}
		}
	case smartchargingeffect.EdgeConnector:
		if id := m.connector; id != nil {
			return []ent.Value{*id}
		}
	case smartchargingeffect.EdgeOrderInfo:
		if id := m.order_info; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SmartChargingEffectMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SmartChargingEffectMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SmartChargingEffectMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedequipment {
		edges = append(edges, smartchargingeffect.EdgeEquipment)
	}
	if m.clearedconnector {
		edges = append(edges, smartchargingeffect.EdgeConnector)
	}
	if m.clearedorder_info {
		edges = append(edges, smartchargingeffect.EdgeOrderInfo)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SmartChargingEffectMutation) EdgeCleared(name string) bool {
	switch name {
	case smartchargingeffect.EdgeEquipment:
		return m.clearedequipment
	case smartchargingeffect.EdgeConnector:
		return m.clearedconnector
	case smartchargingeffect.EdgeOrderInfo:
		return m.clearedorder_info
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SmartChargingEffectMutation) ClearEdge(name string) error {
	switch name {
	case smartchargingeffect.EdgeEquipment:
		m.ClearEquipment()
		return nil
	case smartchargingeffect.EdgeConnector:
		m.ClearConnector()
		return nil
	case smartchargingeffect.EdgeOrderInfo:
		m.ClearOrderInfo()
		return nil
	}
	return fmt.Errorf("unknown SmartChargingEffect unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SmartChargingEffectMutation) ResetEdge(name string) error {
	switch name {
	case smartchargingeffect.EdgeEquipment:
		m.ResetEquipment()
		return nil
	case smartchargingeffect.EdgeConnector:
		m.ResetConnector()
		return nil
	case smartchargingeffect.EdgeOrderInfo:
		m.ResetOrderInfo()
		return nil
	}
	return fmt.Errorf("unknown SmartChargingEffect edge %s", name)
}
