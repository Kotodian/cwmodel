// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"log"

	"github.com/Kotodian/ent-practice/ent/migrate"
	"github.com/Kotodian/gokit/datasource"

	"github.com/Kotodian/ent-practice/ent/connector"
	"github.com/Kotodian/ent-practice/ent/equipment"
	"github.com/Kotodian/ent-practice/ent/equipmentinfo"
	"github.com/Kotodian/ent-practice/ent/evse"

	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// Connector is the client for interacting with the Connector builders.
	Connector *ConnectorClient
	// Equipment is the client for interacting with the Equipment builders.
	Equipment *EquipmentClient
	// EquipmentInfo is the client for interacting with the EquipmentInfo builders.
	EquipmentInfo *EquipmentInfoClient
	// Evse is the client for interacting with the Evse builders.
	Evse *EvseClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	cfg := config{log: log.Println, hooks: &hooks{}}
	cfg.options(opts...)
	client := &Client{config: cfg}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.Connector = NewConnectorClient(c.config)
	c.Equipment = NewEquipmentClient(c.config)
	c.EquipmentInfo = NewEquipmentInfoClient(c.config)
	c.Evse = NewEvseClient(c.config)
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, fmt.Errorf("ent: cannot start a transaction within a transaction")
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:           ctx,
		config:        cfg,
		Connector:     NewConnectorClient(cfg),
		Equipment:     NewEquipmentClient(cfg),
		EquipmentInfo: NewEquipmentInfoClient(cfg),
		Evse:          NewEvseClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, fmt.Errorf("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:           ctx,
		config:        cfg,
		Connector:     NewConnectorClient(cfg),
		Equipment:     NewEquipmentClient(cfg),
		EquipmentInfo: NewEquipmentInfoClient(cfg),
		Evse:          NewEvseClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		Connector.
//		Query().
//		Count(ctx)
//
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	c.Connector.Use(hooks...)
	c.Equipment.Use(hooks...)
	c.EquipmentInfo.Use(hooks...)
	c.Evse.Use(hooks...)
}

// ConnectorClient is a client for the Connector schema.
type ConnectorClient struct {
	config
}

// NewConnectorClient returns a client for the Connector from the given config.
func NewConnectorClient(c config) *ConnectorClient {
	return &ConnectorClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `connector.Hooks(f(g(h())))`.
func (c *ConnectorClient) Use(hooks ...Hook) {
	c.hooks.Connector = append(c.hooks.Connector, hooks...)
}

// Create returns a create builder for Connector.
func (c *ConnectorClient) Create() *ConnectorCreate {
	mutation := newConnectorMutation(c.config, OpCreate)
	return &ConnectorCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Connector entities.
func (c *ConnectorClient) CreateBulk(builders ...*ConnectorCreate) *ConnectorCreateBulk {
	return &ConnectorCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Connector.
func (c *ConnectorClient) Update() *ConnectorUpdate {
	mutation := newConnectorMutation(c.config, OpUpdate)
	return &ConnectorUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ConnectorClient) UpdateOne(co *Connector) *ConnectorUpdateOne {
	mutation := newConnectorMutation(c.config, OpUpdateOne, withConnector(co))
	return &ConnectorUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ConnectorClient) UpdateOneID(id datasource.UUID) *ConnectorUpdateOne {
	mutation := newConnectorMutation(c.config, OpUpdateOne, withConnectorID(id))
	return &ConnectorUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Connector.
func (c *ConnectorClient) Delete() *ConnectorDelete {
	mutation := newConnectorMutation(c.config, OpDelete)
	return &ConnectorDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *ConnectorClient) DeleteOne(co *Connector) *ConnectorDeleteOne {
	return c.DeleteOneID(co.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *ConnectorClient) DeleteOneID(id datasource.UUID) *ConnectorDeleteOne {
	builder := c.Delete().Where(connector.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ConnectorDeleteOne{builder}
}

// Query returns a query builder for Connector.
func (c *ConnectorClient) Query() *ConnectorQuery {
	return &ConnectorQuery{
		config: c.config,
	}
}

// Get returns a Connector entity by its id.
func (c *ConnectorClient) Get(ctx context.Context, id datasource.UUID) (*Connector, error) {
	return c.Query().Where(connector.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ConnectorClient) GetX(ctx context.Context, id datasource.UUID) *Connector {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryEvse queries the evse edge of a Connector.
func (c *ConnectorClient) QueryEvse(co *Connector) *EvseQuery {
	query := &EvseQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(connector.Table, connector.FieldID, id),
			sqlgraph.To(evse.Table, evse.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, connector.EvseTable, connector.EvseColumn),
		)
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEquipment queries the equipment edge of a Connector.
func (c *ConnectorClient) QueryEquipment(co *Connector) *EquipmentQuery {
	query := &EquipmentQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(connector.Table, connector.FieldID, id),
			sqlgraph.To(equipment.Table, equipment.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, connector.EquipmentTable, connector.EquipmentColumn),
		)
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ConnectorClient) Hooks() []Hook {
	return c.hooks.Connector
}

// EquipmentClient is a client for the Equipment schema.
type EquipmentClient struct {
	config
}

// NewEquipmentClient returns a client for the Equipment from the given config.
func NewEquipmentClient(c config) *EquipmentClient {
	return &EquipmentClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `equipment.Hooks(f(g(h())))`.
func (c *EquipmentClient) Use(hooks ...Hook) {
	c.hooks.Equipment = append(c.hooks.Equipment, hooks...)
}

// Create returns a create builder for Equipment.
func (c *EquipmentClient) Create() *EquipmentCreate {
	mutation := newEquipmentMutation(c.config, OpCreate)
	return &EquipmentCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Equipment entities.
func (c *EquipmentClient) CreateBulk(builders ...*EquipmentCreate) *EquipmentCreateBulk {
	return &EquipmentCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Equipment.
func (c *EquipmentClient) Update() *EquipmentUpdate {
	mutation := newEquipmentMutation(c.config, OpUpdate)
	return &EquipmentUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *EquipmentClient) UpdateOne(e *Equipment) *EquipmentUpdateOne {
	mutation := newEquipmentMutation(c.config, OpUpdateOne, withEquipment(e))
	return &EquipmentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *EquipmentClient) UpdateOneID(id datasource.UUID) *EquipmentUpdateOne {
	mutation := newEquipmentMutation(c.config, OpUpdateOne, withEquipmentID(id))
	return &EquipmentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Equipment.
func (c *EquipmentClient) Delete() *EquipmentDelete {
	mutation := newEquipmentMutation(c.config, OpDelete)
	return &EquipmentDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *EquipmentClient) DeleteOne(e *Equipment) *EquipmentDeleteOne {
	return c.DeleteOneID(e.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *EquipmentClient) DeleteOneID(id datasource.UUID) *EquipmentDeleteOne {
	builder := c.Delete().Where(equipment.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &EquipmentDeleteOne{builder}
}

// Query returns a query builder for Equipment.
func (c *EquipmentClient) Query() *EquipmentQuery {
	return &EquipmentQuery{
		config: c.config,
	}
}

// Get returns a Equipment entity by its id.
func (c *EquipmentClient) Get(ctx context.Context, id datasource.UUID) (*Equipment, error) {
	return c.Query().Where(equipment.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *EquipmentClient) GetX(ctx context.Context, id datasource.UUID) *Equipment {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryEquipmentInfo queries the equipment_info edge of a Equipment.
func (c *EquipmentClient) QueryEquipmentInfo(e *Equipment) *EquipmentInfoQuery {
	query := &EquipmentInfoQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(equipment.Table, equipment.FieldID, id),
			sqlgraph.To(equipmentinfo.Table, equipmentinfo.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, equipment.EquipmentInfoTable, equipment.EquipmentInfoColumn),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEvses queries the evses edge of a Equipment.
func (c *EquipmentClient) QueryEvses(e *Equipment) *EvseQuery {
	query := &EvseQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(equipment.Table, equipment.FieldID, id),
			sqlgraph.To(evse.Table, evse.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, equipment.EvsesTable, equipment.EvsesColumn),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryConnectors queries the connectors edge of a Equipment.
func (c *EquipmentClient) QueryConnectors(e *Equipment) *ConnectorQuery {
	query := &ConnectorQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(equipment.Table, equipment.FieldID, id),
			sqlgraph.To(connector.Table, connector.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, equipment.ConnectorsTable, equipment.ConnectorsColumn),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *EquipmentClient) Hooks() []Hook {
	return c.hooks.Equipment
}

// EquipmentInfoClient is a client for the EquipmentInfo schema.
type EquipmentInfoClient struct {
	config
}

// NewEquipmentInfoClient returns a client for the EquipmentInfo from the given config.
func NewEquipmentInfoClient(c config) *EquipmentInfoClient {
	return &EquipmentInfoClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `equipmentinfo.Hooks(f(g(h())))`.
func (c *EquipmentInfoClient) Use(hooks ...Hook) {
	c.hooks.EquipmentInfo = append(c.hooks.EquipmentInfo, hooks...)
}

// Create returns a create builder for EquipmentInfo.
func (c *EquipmentInfoClient) Create() *EquipmentInfoCreate {
	mutation := newEquipmentInfoMutation(c.config, OpCreate)
	return &EquipmentInfoCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of EquipmentInfo entities.
func (c *EquipmentInfoClient) CreateBulk(builders ...*EquipmentInfoCreate) *EquipmentInfoCreateBulk {
	return &EquipmentInfoCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for EquipmentInfo.
func (c *EquipmentInfoClient) Update() *EquipmentInfoUpdate {
	mutation := newEquipmentInfoMutation(c.config, OpUpdate)
	return &EquipmentInfoUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *EquipmentInfoClient) UpdateOne(ei *EquipmentInfo) *EquipmentInfoUpdateOne {
	mutation := newEquipmentInfoMutation(c.config, OpUpdateOne, withEquipmentInfo(ei))
	return &EquipmentInfoUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *EquipmentInfoClient) UpdateOneID(id datasource.UUID) *EquipmentInfoUpdateOne {
	mutation := newEquipmentInfoMutation(c.config, OpUpdateOne, withEquipmentInfoID(id))
	return &EquipmentInfoUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for EquipmentInfo.
func (c *EquipmentInfoClient) Delete() *EquipmentInfoDelete {
	mutation := newEquipmentInfoMutation(c.config, OpDelete)
	return &EquipmentInfoDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *EquipmentInfoClient) DeleteOne(ei *EquipmentInfo) *EquipmentInfoDeleteOne {
	return c.DeleteOneID(ei.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *EquipmentInfoClient) DeleteOneID(id datasource.UUID) *EquipmentInfoDeleteOne {
	builder := c.Delete().Where(equipmentinfo.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &EquipmentInfoDeleteOne{builder}
}

// Query returns a query builder for EquipmentInfo.
func (c *EquipmentInfoClient) Query() *EquipmentInfoQuery {
	return &EquipmentInfoQuery{
		config: c.config,
	}
}

// Get returns a EquipmentInfo entity by its id.
func (c *EquipmentInfoClient) Get(ctx context.Context, id datasource.UUID) (*EquipmentInfo, error) {
	return c.Query().Where(equipmentinfo.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *EquipmentInfoClient) GetX(ctx context.Context, id datasource.UUID) *EquipmentInfo {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryEquipment queries the equipment edge of a EquipmentInfo.
func (c *EquipmentInfoClient) QueryEquipment(ei *EquipmentInfo) *EquipmentQuery {
	query := &EquipmentQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := ei.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(equipmentinfo.Table, equipmentinfo.FieldID, id),
			sqlgraph.To(equipment.Table, equipment.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, equipmentinfo.EquipmentTable, equipmentinfo.EquipmentColumn),
		)
		fromV = sqlgraph.Neighbors(ei.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *EquipmentInfoClient) Hooks() []Hook {
	return c.hooks.EquipmentInfo
}

// EvseClient is a client for the Evse schema.
type EvseClient struct {
	config
}

// NewEvseClient returns a client for the Evse from the given config.
func NewEvseClient(c config) *EvseClient {
	return &EvseClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `evse.Hooks(f(g(h())))`.
func (c *EvseClient) Use(hooks ...Hook) {
	c.hooks.Evse = append(c.hooks.Evse, hooks...)
}

// Create returns a create builder for Evse.
func (c *EvseClient) Create() *EvseCreate {
	mutation := newEvseMutation(c.config, OpCreate)
	return &EvseCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Evse entities.
func (c *EvseClient) CreateBulk(builders ...*EvseCreate) *EvseCreateBulk {
	return &EvseCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Evse.
func (c *EvseClient) Update() *EvseUpdate {
	mutation := newEvseMutation(c.config, OpUpdate)
	return &EvseUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *EvseClient) UpdateOne(e *Evse) *EvseUpdateOne {
	mutation := newEvseMutation(c.config, OpUpdateOne, withEvse(e))
	return &EvseUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *EvseClient) UpdateOneID(id datasource.UUID) *EvseUpdateOne {
	mutation := newEvseMutation(c.config, OpUpdateOne, withEvseID(id))
	return &EvseUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Evse.
func (c *EvseClient) Delete() *EvseDelete {
	mutation := newEvseMutation(c.config, OpDelete)
	return &EvseDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *EvseClient) DeleteOne(e *Evse) *EvseDeleteOne {
	return c.DeleteOneID(e.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *EvseClient) DeleteOneID(id datasource.UUID) *EvseDeleteOne {
	builder := c.Delete().Where(evse.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &EvseDeleteOne{builder}
}

// Query returns a query builder for Evse.
func (c *EvseClient) Query() *EvseQuery {
	return &EvseQuery{
		config: c.config,
	}
}

// Get returns a Evse entity by its id.
func (c *EvseClient) Get(ctx context.Context, id datasource.UUID) (*Evse, error) {
	return c.Query().Where(evse.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *EvseClient) GetX(ctx context.Context, id datasource.UUID) *Evse {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryEquipment queries the equipment edge of a Evse.
func (c *EvseClient) QueryEquipment(e *Evse) *EquipmentQuery {
	query := &EquipmentQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(evse.Table, evse.FieldID, id),
			sqlgraph.To(equipment.Table, equipment.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, evse.EquipmentTable, evse.EquipmentColumn),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryConnectors queries the connectors edge of a Evse.
func (c *EvseClient) QueryConnectors(e *Evse) *ConnectorQuery {
	query := &ConnectorQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(evse.Table, evse.FieldID, id),
			sqlgraph.To(connector.Table, connector.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, evse.ConnectorsTable, evse.ConnectorsColumn),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *EvseClient) Hooks() []Hook {
	return c.hooks.Evse
}
